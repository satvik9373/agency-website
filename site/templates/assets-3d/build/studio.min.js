var studio = function(e) {
    "use strict";

    function t(e) {
        return e < .5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2
    }
    const n = {
        rootURL: "",
        pixelScale: 3,
        pixelPalette: [
            [0, 0, 0],
            [255, 0, 0],
            [0, 255, 0],
            [0, 0, 255],
            [255, 255, 255]
        ],
        pixelDither: .73,
        _palette: !1,
        _paletteCount: 0,
        defaultAnimateTime: .5,
        defaultAnimateDelay: .5
    };

    function i() {
        n._palette = [], n._paletteCount = 0;
        for (let e = 0; e < n.pixelPalette.length; e++) Array.isArray(n.pixelPalette[e]) && n.pixelPalette[e].length >= 3 && (n._palette.push(n.pixelPalette[e][0]), n._palette.push(n.pixelPalette[e][1]), n._palette.push(n.pixelPalette[e][2]), n._paletteCount += 1)
    }
    const o = 2 * Math.PI,
        a = window.devicePixelRatio ? window.devicePixelRatio : 1,
        r = new THREE.Vector2(window.innerWidth, window.innerHeight),
        l = new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2);
    let s = Date.now(),
        d = 0,
        c = 0;
    const m = document.createElement("canvas"),
        u = m.getContext("2d"),
        f = {
            strokeWidth: 1,
            radius: 2,
            innerWidth: 0,
            innerHeight: 0,
            padding: {
                x: 0,
                y: 0,
                perc: 1.5,
                max: 50
            },
            showOuter: !1,
            mainPadding: {
                x: 0,
                y: 0
            },
            minWidth: 80,
            max: 6,
            x: 6,
            y: 6,
            startY: 0
        },
        h = [];
    let p = !1,
        g = !1,
        v = !1,
        _ = !1,
        x = !1;
    const y = {
            top: 0,
            height: 0,
            bottom: 0
        },
        b = {
            top: 0,
            height: 0,
            bottom: 0
        },
        w = new THREE.Vector2(1, 1),
        E = new THREE.WebGLRenderer({
            antialias: !0,
            alpha: !0
        });
    E.setPixelRatio(a);
    let P = !1;
    const S = new THREE.GLTFLoader,
        T = new THREE.TextureLoader,
        R = new THREE.Scene;
    let C = R;
    const M = new THREE.Scene;
    let z = M;
    const A = new THREE.PerspectiveCamera,
        O = new THREE.Vector2(0, 0),
        D = [],
        F = [],
        H = [],
        L = [],
        B = [],
        $ = [],
        I = {
            u_time: {
                type: "f",
                value: 0
            }
        };
    let k = !0,
        Y = 3,
        N = !1,
        U = !1,
        W = 0,
        G = 0,
        V = window.scrollY;
    const j = {
        scene: R,
        scenePixel: M,
        camera: A,
        mouse: new THREE.Vector2(0, 0),
        sceneSize: w,
        viewSize: r,
        scroll: V,
        mouseAbsolute: new THREE.Vector2(0, 0),
        isMobile: !1,
        t: 0,
        d: 0,
        avoidAmount: 1,
        easeInOutCubic: t
    };

    function X() {
        if (V = window.scrollY, c = Date.now() - s, s += c, c = Math.min(1, .001 * c), d += c, G = Math.pow(3e-4, c), j.mouse.x = j.mouse.x * G + O.x * (1 - G), j.mouse.y = j.mouse.y * G + O.y * (1 - G), j.mouseAbsolute.x = 2 * O.x, j.mouseAbsolute.y = -2 * O.y, N && (N = !1, q()), j.d = c, j.t = d, k) {
            Y -= c, Y < 0 && (k = !1), W = (W + 1) % 5;
            for (let e = 0; e < $.length; e++) ye($[e]);
            for (let e = 0; e < F.length; e++) be(F[e]), F[e].render && (F[e].t += c, F[e].updateTransform());
            for (let e = 0; e < h.length; e++) we(h[e]);
            if (g) {
                const e = _.getBoundingClientRect();
                if (y.top = e.top, y.height = e.height, y.bottom = e.bottom, v) {
                    const e = x.getBoundingClientRect();
                    b.top = e.top, b.height = e.height, b.bottom = e.bottom
                }
            }
            for (let e = 0; e < B.length; e++) B[e]()
        } else
            for (let e = 0; e < F.length; e++) F[e].render && (F[e].t += c, F[e].updateTransform());
        I.u_time.value += c, u.clearRect(0, 0, r.x * a, r.y * a), f.startY = f.padding.y - V % f.height, f.startY = f.startY < f.padding.y ? f.startY + f.height : f.startY, u.beginPath(), f.showOuter && (u.moveTo(~~(f.padding.x * a) - .5, ~~(f.padding.y * a)), u.lineTo(~~(f.padding.x * a) - .5, ~~((f.padding.y + f.innerHeight) * a)), u.moveTo(~~((r.x - f.padding.x) * a) - .5, ~~(f.padding.y * a)), u.lineTo(~~((r.x - f.padding.x) * a) - .5, ~~((f.padding.y + f.innerHeight) * a)));
        for (let e = 0; e <= f.x; e++) u.moveTo(~~((f.mainPadding.x + f.width * e) * a) - .5, ~~(f.mainPadding.y * a)), u.lineTo(~~((f.mainPadding.x + f.width * e) * a) - .5, ~~((f.mainPadding.y + f.innerHeight) * a));
        u.stroke();
        for (let e = f.startY; e < f.innerHeight + f.mainPadding.y + f.height; e += f.height) {
            u.beginPath(), u.moveTo(~~(f.padding.x * a), ~~(e * a) - .5), u.lineTo(~~((f.padding.x + f.outerWidth) * a), ~~(e * a) - .5), u.stroke(), u.beginPath(), f.showOuter && (u.arc(~~(f.padding.x * a) - .5, ~~(e * a) - .5, f.radius, 0, o), u.arc(~~((r.x - f.padding.x) * a) - .5, ~~(e * a) - .5, f.radius, 0, o));
            for (let t = 0; t <= f.x; t++) u.arc(~~((f.mainPadding.x + f.width * t) * a) - .5, ~~(e * a) - .5, f.radius, 0, o);
            u.fill()
        }
        if (p) {
            u.globalCompositeOperation = "source-atop", u.fillStyle = "white";
            for (let e = 0; e < h.length; e++) u.fillRect(h[e].screenBounds.left * a, h[e].screenBounds.top * a, h[e].screenBounds.width * a, h[e].screenBounds.height * a);
            g ? (u.fillRect(0, y.top * a, r.x * a, y.height * a), u.fillStyle = "#1D2027", v && (u.beginPath(), u.roundRect(0, b.top * a, r.x * a, b.height * a, [0, 0, b.height * a, b.height * a]), u.fill()), u.globalCompositeOperation = "source-over") : (u.globalCompositeOperation = "source-over", u.fillStyle = "#1D2027")
        } else g && (u.globalCompositeOperation = "source-atop", u.fillStyle = "white", u.fillRect(0, y.top * a, r.x * a, y.height * a), u.fillStyle = "#1D2027", v && (u.beginPath(), u.roundRect(0, b.top * a, r.x * a, b.height * a, [0, 0, b.height * a, b.height * a]), u.fill()), u.globalCompositeOperation = "source-over");
        for (let e = 0; e < L.length; e++) L[e]();
        E.render(C, A), P && P.render(z, A), U && (U = !1, j.scroll = V, m.style.transform = "translateY(" + V + "px)", E.domElement.style.transform = "translateY(" + V + "px)", P && (P.domElement.style.transform = E.domElement.style.transform)), requestAnimationFrame(X)
    }

    function q() {
        r.set(document.body.clientWidth, window.innerHeight), l.set(r.x / 2, r.y / 2), m.width = r.x * a, m.height = r.y * a, m.style.width = r.x + "px", m.style.height = r.y + "px", u.fillStyle = "#1D2027", u.strokeStyle = "rgba(0,0,0,0.094)", u.lineWidth = f.strokeWidth, f.padding.x = Math.min(f.padding.max, r.x * f.padding.perc * .01), f.padding.y = Math.min(f.padding.max, r.y * f.padding.perc * .01), f.innerWidth = r.x - 2 * f.padding.x, f.outerWidth = f.innerWidth, f.innerWidth > 1270 ? (f.innerWidth = Math.min(f.innerWidth, 1270), f.showOuter = !0, f.mainPadding.x = (r.x - f.innerWidth) / 2, f.mainPadding.y = f.padding.y) : (f.showOuter = !1, f.mainPadding.x = f.padding.x, f.mainPadding.y = f.padding.y), f.innerHeight = r.y - 2 * f.padding.y, f.x = Math.min(Math.floor(f.innerWidth / f.minWidth), f.max), f.x = 2 * Math.round(f.x / 2), f.width = f.innerWidth / f.x, f.y = Math.round(f.innerHeight / f.width), f.height = ~~f.innerHeight / f.y, f.offset = f.strokeWidth / 2 % 1, E.setSize(r.x, r.y), A.aspect = r.x / r.y, A.updateProjectionMatrix(), P && (P.setSize(Math.round(r.x / n.pixelScale), Math.round(r.y / n.pixelScale)), P.domElement.style.width = r.x + "px", P.domElement.style.height = r.y + "px"), w.y = 2 * Math.tan(A.fov * Math.PI / 180 / 2) * A.position.z, w.x = w.y * A.aspect, w.min = Math.min(w.x, w.y), w.max = Math.max(w.x, w.y), j.isMobile = w.isMobile = r.isMobile = r.x < .8 * r.y || r.x < 992;
        for (let e = 0; e < H.length; e++) H[e].mesh.castShadow && (H[e].mesh.shadow.camera.left = -w.x / 2, H[e].mesh.shadow.camera.right = w.x / 2, H[e].mesh.shadow.camera.top = -w.y / 2, H[e].mesh.shadow.camera.bottom = w.y / 2, H[e].mesh.shadow.camera.updateProjectionMatrix(), H[e].mesh.shadow.bias = 3 * -1e-4);
        Q(2)
    }

    function K() {
        N = !0, U = !0
    }

    function J() {
        U = !0
    }

    function Q(e = 1) {
        k = !0, Y = Math.max(Y, 2 * e)
    }
    let Z = {},
        ee = !1,
        te = !1,
        ne = [];

    function ie(e, t) {
        if (Z.hasOwnProperty(e)) return t(Z[e]);
        let i = !1;
        switch (e) {
            case "box":
                i = new THREE.BoxGeometry(1, 1, 1);
                break;
            case "cone":
                i = new THREE.ConeGeometry(1, 1, 36);
                break;
            case "cylinder":
                i = new THREE.CylinderGeometry(.5, .5, 2, 36);
                break;
            case "tetrahedron-flat":
                i = new THREE.TetrahedronGeometry(1);
                break;
            case "octahedron-flat":
                i = new THREE.OctahedronGeometry(1);
                break;
            case "icosahedron-flat":
                i = new THREE.IcosahedronGeometry(1);
                break;
            case "dodecahedron-flat":
                i = new THREE.DodecahedronGeometry(1);
                break;
            case "plane":
                i = new THREE.PlaneGeometry(1);
                break;
            default:
                if (!ee) return function(e) {
                    if (ee) return void e();
                    if (te) return void ne.push(e);
                    te = !0, ne.push(e);
                    let t = {};
                    return S.load(n.rootURL + "models/geo.glb?v=2", (function(e) {
                        e.scene.traverse((function(e) {
                            e.geometry && (t[e.name] = e.geometry)
                        })), ee = t;
                        for (let e = 0; e < ne.length; e++) ne[e].call(null)
                    }), (function(e) {}), (function(e) {
                        ee = {};
                        for (let e = 0; e < ne.length; e++) ne[e].call(null)
                    }))
                }((function() {
                    ie(e, t)
                }));
                if (ee.hasOwnProperty(e)) return t(ee[e]);
                i = new THREE.BoxGeometry(1, 1, 1)
        }
        return Z[e] = i, t(i)
    }
    let oe = {};

    function ae(e, t = null, n = null) {
        const i = e + (t || "") + (n ? JSON.stringify(n) : "");
        if (oe.hasOwnProperty(i)) return oe[i];
        let o = T.load(e);
        if (t && (o.encoding = t), n)
            for (let e in n) o[e] = n[e];
        return oe[i] = o, o
    }
    let re = {};

    function le(e, t, o) {
        if (t.material || (t.material = "basic"), "string" != typeof t.material) return;
        let r = {},
            l = t.material + (t.pixel ? ":pixel:" : ":"),
            s = !0;
        switch ((e.effects || o) && (s = !1), e.animateIn && e.animateIn.includes("fade") && (r.transparent = !0, l += "fade:", s = !1), t.material) {
            case "matcap":
            case "matcap-uv":
                t.map && (r.matcap = ae(t.map, THREE.sRGBEncoding, e.file ? {
                    flipY: !1
                } : null), l += "map:" + t.map);
                break;
            case "shader":
                s = !1, t.vertexShader ? r.vertexShader = t.vertexShader : r.vertexShader = "\n                #include <common>\n                #include <uv_pars_vertex>\n                #include <uv2_pars_vertex>\n                #include <color_pars_vertex>\n\n                void main() {\n\n                    #include <uv_vertex>\n                    #include <uv2_vertex>\n                    #include <color_vertex>\n\n                    #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\n                        #include <beginnormal_vertex>\n                        #include <defaultnormal_vertex>\n\n                    #endif\n\n                    #include <begin_vertex>\n                    #include <project_vertex>\n                    #include <logdepthbuf_vertex>\n\n                    #include <worldpos_vertex>\n                    #include <envmap_vertex>\n                }\n                ", t.fragmentShader ? r.fragmentShader = t.fragmentShader : r.fragmentShader = "";
                break;
            case "basic":
            case "physical":
                t.map && (r.map = ae(t.map, THREE.sRGBEncoding, e.file ? {
                    flipY: !1
                } : null), l += "map:" + t.map), t.alphaMap && (r.alphaMap = ae(t.alphaMap, null, e.file ? {
                    flipY: !1
                } : null), l += "alphaMap:" + t.alphaMap), void 0 !== t.opacity && (r.opacity = t.opacity, l += "o:" + t.opacity), t.color && (r.color = t.color, l += "c:" + t.color), t.transparent && (r.transparent = !!t.transparent, l += (r.transparent, "y"))
        }
        t.overlay && (r.overlay = ae(t.overlay, THREE.sRGBEncoding, e.file ? {
            flipY: !1
        } : null), l += "overlay:" + t.overlay, t.overlayType ? (r.overlayType = t.overlayType, l += t.overlayType) : (r.overlayType = "normal", l += "normal"), t.overlayOpacity ? (r.overlayOpacity = t.overlayOpacity, l += t.overlayOpacity) : l += "1");
        let d = {};
        if (t.hasOwnProperty("depthTest") && (d.depthTest = t.depthTest, l += "dt:" + t.depthTest), t.hasOwnProperty("depthWrite") && (d.depthWrite = t.depthWrite, l += "dw:" + t.depthWrite), t.hasOwnProperty("depthFunc") && (d.depthFunc = t.depthFunc, l += "df:" + t.depthFunc), s && re.hasOwnProperty(l)) return re[l];
        let c = {
            vertex: "",
            vertexPre: "",
            vertexPost: "",
            fragment: "",
            fragmentPre: "",
            fragmentPost: "",
            uniforms: {}
        };
        if (r.overlay) {
            c.uniforms.pixel_aspect_ratio || (c.uniforms.pixel_aspect_ratio = {
                value: a
            }, c.fragment += "uniform float pixel_aspect_ratio;\n"), c.uniforms.overlay = {
                value: r.overlay
            }, c.uniforms.overlay_x = {
                value: 0
            }, c.uniforms.overlay_y = {
                value: 0
            }, c.uniforms.overlay_scale = {
                value: r.overlayScale ? r.overlayScale : 1
            }, c.fragment += "uniform sampler2D overlay;\n", c.fragment += "uniform float overlay_x;\n", c.fragment += "uniform float overlay_y;\n", c.fragment += "uniform float overlay_scale;\n", c.fragmentPost += "\n        ivec2 overlaySize = textureSize(overlay, 0);\n\n        vec4 overlaySource = mapTexelToLinear(\n            texture2D(overlay,\n                mod(\n                    (vec2(\n                        gl_FragCoord.x / pixel_aspect_ratio - overlay_x + float(overlaySize.x) / 2.0,\n                        gl_FragCoord.y / pixel_aspect_ratio - overlay_y + float(overlaySize.y) / 2.0\n                    ) / vec2(float(overlaySize.x), float(overlaySize.y))) / overlay_scale,\n                    1.0\n                )\n            )\n        );";
            let e = !1,
                t = !1;
            r.overlayOpacity && 1 !== r.overlayOpacity && (e = r.overlayOpacity.toFixed(3), t = (1 - r.overlayOpacity).toFixed(3)), "multiply" === r.overlayType ? c.fragmentPost += e ? "gl_FragColor.rgb = (gl_FragColor.rgb * overlaySource.rgb) * " + e + " + gl_FragColor.rgb * " + t + ";\n" : "gl_FragColor.rgb = gl_FragColor.rgb * overlaySource.rgb;\n" : "add" === r.overlayType ? c.fragmentPost += e ? "gl_FragColor.rgb = min(gl_FragColor.rgb + overlaySource.rgb * " + e + ", vec3(1.0));\n" : "gl_FragColor.rgb = min(gl_FragColor.rgb + overlaySource.rgb, vec3(1.0));\n" : "overlay" === r.overlayType ? (c.fragment += "float ovblend(float a, float b) { return a < 0.5 ? (2.0 * a * b ) : (1.0 - 2.0 * (1.0 - a) * (1.0 - b)); }\n", c.fragmentPost += e ? "gl_FragColor.rgb = vec3(ovblend(gl_FragColor.r, overlaySource.r), ovblend(gl_FragColor.g, overlaySource.g), ovblend(gl_FragColor.b, overlaySource.b)) * " + e + " + gl_FragColor.rgb * " + t + ";\n" : "gl_FragColor.rgb = vec3(ovblend(gl_FragColor.r, overlaySource.r), ovblend(gl_FragColor.g, overlaySource.g), ovblend(gl_FragColor.b, overlaySource.b));\n") : c.fragmentPost += e ? "gl_FragColor.rgb = overlaySource.rgb * " + e + " + gl_FragColor.rgb * " + t + ";\n" : "gl_FragColor.rgb = overlaySource.rgb;\n", d.map = !0, d.hasOverlay = !0
        }
        if (e.effects)
            for (let i = 0; i < e.effects.length; i++) switch (e.effects[i].type) {
                case "distort":
                    c.vertex += "uniform float u_time;\n", c.vertex += "vec3 ef_dst_hash( vec3 p ) {\n                        p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n                                  dot(p,vec3(269.5,183.3,246.1)),\n                                  dot(p,vec3(113.5,271.9,124.6)));\n                        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n                    }\n                    float ef_dst_noise( in vec3 p ) {\n                        vec3 i = floor( p );\n                        vec3 f = fract( p );\n                        vec3 u = f*f*(3.0-2.0*f);\n                        return mix( mix( mix( dot( ef_dst_hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                                                dot( ef_dst_hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                                            mix( dot( ef_dst_hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                                                dot( ef_dst_hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                                    mix( mix( dot( ef_dst_hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                                                dot( ef_dst_hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                                            mix( dot( ef_dst_hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                                                dot( ef_dst_hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n                    }\n";
                    let r = (e.effects[i].distort_speed || 1).toFixed(3),
                        l = (e.effects[i].distort_amount || 1).toFixed(3),
                        s = (e.effects[i].distort_scale || 3).toFixed(3),
                        m = "";
                    e.animateIn && e.animateIn.includes("fade") && (c.vertex += "uniform float obj_opacity;\n", m = "obj_opacity * ");
                    const u = (Math.round(1e3 * Math.random()) / 100).toString();
                    c.vertexPost += `\n                    vec3 ef_dst_noisePosition = vec3(\n                        transformed.x,\n                        transformed.y,\n                        transformed.z * 0.3\n                    );\n\n                    vec3 ef_dst_displacement = vec3(\n                        ef_dst_noise(+vec3(ef_dst_noisePosition.xyz) / (${s} * 2.0) - (u_time / 100.0 + ${u}) * ${r}),\n                        ef_dst_noise(+vec3(ef_dst_noisePosition.yzx) / (${s} * 2.0) - (u_time / 100.0 + ${u}) * ${r}),\n                        ef_dst_noise(-vec3(ef_dst_noisePosition.zxy) / (${s} * 2.0) + (u_time / 100.0 + ${u}) * ${r})\n                    ) * ${l};\n\n                    mvPosition.x += ${m}ef_dst_displacement.x;\n                    mvPosition.y += ${m}ef_dst_displacement.y;\n                    mvPosition.z += ${m}ef_dst_displacement.z * 0.2;\n\n                    transformed.x += ${m}ef_dst_displacement.x;\n                    transformed.y += ${m}ef_dst_displacement.y;\n                    transformed.z += ${m}ef_dst_displacement.z * 0.2;\n\n                    ef_dst_noisePosition = vec3(\n                        transformed.x,\n                        transformed.y,\n                        transformed.z * 0.3\n                    );\n\n                    ef_dst_displacement = vec3(\n                        ef_dst_noise(+vec3(ef_dst_noisePosition.xyz) / ${s} - (u_time / 100.0 + ${u}) * ${r}),\n                        ef_dst_noise(+vec3(ef_dst_noisePosition.yzx) / ${s} - (u_time / 100.0 + ${u}) * ${r}),\n                        ef_dst_noise(-vec3(ef_dst_noisePosition.zxy) / ${s} + (u_time / 100.0 + ${u}) * ${r})\n                    ) * 0.5 * ${l};\n\n                    mvPosition.x += ${m}ef_dst_displacement.x;\n                    mvPosition.y += ${m}ef_dst_displacement.y;\n                    mvPosition.z += ${m}ef_dst_displacement.z * 0.2;\n                    `, c.vertexPost += "gl_Position = projectionMatrix * mvPosition;\n";
                    break;
                case "split":
                    c.uniforms.split_angle = {
                        value: Math.PI / 180 * 45
                    }, c.uniforms.split_angle = {
                        value: Math.PI / 180 * 45
                    }, c.uniforms.split_x = {
                        value: 0
                    }, c.uniforms.split_y = {
                        value: 0
                    }, c.uniforms.split_width = {
                        value: 10
                    }, c.uniforms.pixel_aspect_ratio || (c.uniforms.pixel_aspect_ratio = {
                        value: a
                    }, c.fragment += "uniform float pixel_aspect_ratio;\n"), c.fragment += "uniform float split_angle;\n", c.fragment += "uniform float split_x;\n", c.fragment += "uniform float split_y;\n", c.fragment += "uniform float split_width;\n", t.pixel ? c.fragmentPre += "float splitdistance = ((gl_FragCoord.x * " + n.pixelScale.toFixed(2) + ") / pixel_aspect_ratio - split_x) * sin(split_angle) - ((gl_FragCoord.y * " + n.pixelScale.toFixed(2) + ") / pixel_aspect_ratio - split_y) * cos(split_angle);\n" : c.fragmentPre += "float splitdistance = (gl_FragCoord.x / pixel_aspect_ratio - split_x) * sin(split_angle) - (gl_FragCoord.y / pixel_aspect_ratio - split_y) * cos(split_angle);\n", o && "split" === o.type ? c.fragmentPre += "if (splitdistance > -split_width * (0.5 + pixel_aspect_ratio * 0.5)) discard;\n" : c.fragmentPre += "if (splitdistance < split_width * (0.5 + pixel_aspect_ratio * 0.5)) discard;\n", t.pixel || (c.fragmentPost += "gl_FragColor.a *= min(1.0, abs(splitdistance) - split_width * (0.5 + pixel_aspect_ratio * 0.5));\n"), d.hasSplit = !0
            }
        if (t.pixel) {
            n._palette || i();
            let e = "",
                o = 1;
            if (t.palette) {
                e = [], o = 0;
                for (let n = 0; n < t.palette.length; n++) Array.isArray(t.palette[n]) && t.palette[n].length >= 3 && (0 !== n && (e += ","), e += (t.palette[n][0] / 255).toFixed(4), e += ",", e += (t.palette[n][1] / 255).toFixed(4), e += ",", e += (t.palette[n][2] / 255).toFixed(4), o += 1)
            } else {
                for (let t = 0; t < n._palette.length; t++) 0 !== t && (e += ","), e += (n._palette[t] / 255).toFixed(4);
                o = n._paletteCount
            }
            let a = ((1 - n.pixelDither) / 1).toFixed(3),
                r = n.pixelDither.toFixed(3);
            c.fragment += "const float palette[" + 3 * o + "] = float[](" + e + ");\n", c.fragment += "const int paletteCount = " + o + ";\n", c.fragment += "const int ditherMatrix[16] = int[](0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5);\n", c.fragment += "float ditherValue() { return float( ditherMatrix[ int(mod(gl_FragCoord.x, 4.0)) + int(mod(gl_FragCoord.y, 4.0)) * 4 ]) / 16.0; }\n", c.fragment += "\n            vec3 dither(vec3 color) {\n                //R, G, B, diff\n                vec4 opt1 = vec4(0.0, 0.0, 0.0, 3.0);\n                vec4 opt2 = vec4(0.0, 0.0, 0.0, 3.0);\n\n                for (int i = 0; i < paletteCount; i++) {\n                    float diff = (abs(palette[i * 3] - color.r) + abs(palette[i * 3 + 1] - color.g) + abs(palette[i * 3 + 2] - color.b)) / 3.0;\n\n                    if (diff < opt1.w) {\n                        opt2 = opt1;\n                        opt1 = vec4(palette[i * 3], palette[i * 3 + 1], palette[i * 3 + 2], diff);\n                    } else if (diff < opt2.w) {\n                        opt2 = vec4(palette[i * 3], palette[i * 3 + 1], palette[i * 3 + 2], diff);\n                    }\n                }\n                float comp = " + a + " + ditherValue() * " + r + ";\n                float dist = (opt1.w / ((abs(opt2.r - opt1.r) + abs(opt2.g - opt1.g) + abs(opt2.b - opt1.b)) / 3.0));\n                return dist < comp ? opt1.rgb : opt2.rgb;\n            }\n            ", c.fragmentPost += "gl_FragColor = vec4(dither(gl_FragColor.rgb), gl_FragColor.a);", d.hasPixel = !0
        }
        switch (e.animateIn && e.animateIn.includes("fade") && (c.uniforms.obj_opacity = {
            value: 0
        }, c.fragment += "uniform float obj_opacity;\n", t.pixel ? c.fragmentPre += "if (obj_opacity <= 0.0 || ditherValue() >= obj_opacity) discard;\n" : (c.fragmentPre += "if (obj_opacity <= 0.0) discard;\n", c.fragmentPost += "gl_FragColor.a *= obj_opacity;\n"), c.hasFade = !0), c.vertex && (c.vertex += "\n"), c.fragment && (c.fragment += "\n"), t.material) {
            case "shader":
                c.vertex += r.vertexShader.replace(/void\s+main\(\)\s*{/gm, "void main() {"), c.fragment += r.fragmentShader.replace(/void\s+main\(\)\s*{/gm, "void main() {");
                let e = "void main() {",
                    t = c.vertex.indexOf(e); - 1 !== t && (t += e.length, c.vertex = c.vertex.substring(0, t) + "\n#{PRE}\n" + c.vertex.substring(t)), t = c.vertex.lastIndexOf("}"), -1 !== t && (c.vertex = c.vertex.substring(0, t) + "\n#{POST}\n" + c.vertex.substring(t)), t = c.fragment.indexOf(e), -1 !== t && (t += e.length, c.fragment = c.fragment.substring(0, t) + "\n#{PRE}\n" + c.fragment.substring(t)), t = c.fragment.lastIndexOf("}"), -1 !== t && (c.fragment = c.fragment.substring(0, t) + "\n#{POST}\n" + c.fragment.substring(t));
                break;
            case "matcap":
                c.uniforms.matcap = {
                    value: r.matcap
                }, c.vertex += "#define MATCAP\n            varying vec3 vViewPosition;\n\n            #include <common>\n            #include <normal_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n\n            void main() {\n                #{PRE}\n\n                #include <beginnormal_vertex>\n                #include <defaultnormal_vertex>\n                #include <normal_vertex>\n\n                #include <begin_vertex>\n                #include <project_vertex>\n\n                #include <logdepthbuf_vertex>\n\n                vViewPosition = - mvPosition.xyz;\n\n                #{POST}\n            }", c.fragment += "#define MATCAP\n            uniform sampler2D matcap;\n            varying vec3 vViewPosition;\n\n            #include <common>\n            #include <dithering_pars_fragment>\n            #include <normal_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n\n            void main() {\n                #{PRE}\n\n                vec4 diffuseColor = vec4( 1.0);\n\n                #include <logdepthbuf_fragment>\n                #include <normal_fragment_begin>\n\n                vec3 viewDir = normalize( vViewPosition );\n                vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n                vec3 y = cross( viewDir, x );\n                vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n                vec4 matcapColor = texture2D( matcap, uv );\n                matcapColor = matcapTexelToLinear( matcapColor );\n\n                vec3 outgoingLight =  matcapColor.rgb;\n\n                #include <output_fragment>\n\n                #{POST}\n\n                #include <tonemapping_fragment>\n                #include <encodings_fragment>\n                #include <premultiplied_alpha_fragment>\n                #include <dithering_fragment>\n            }", d.matcap = !0;
                break;
            case "matcap-uv":
                c.uniforms.matcap = {
                    value: r.matcap
                }, c.vertex += "#define MATCAP\n            varying vec3 vViewPosition;\n\n            #include <common>\n\n\t\t\tvarying vec2 vUv;\n\t\t\tuniform mat3 uvTransform;\n\n            #include <normal_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n\n            void main() {\n                #{PRE}\n\n\t\t\t\tvUv = uv;\n\n                #include <beginnormal_vertex>\n                #include <defaultnormal_vertex>\n                #include <normal_vertex>\n\n                #include <begin_vertex>\n                #include <project_vertex>\n\n                #include <logdepthbuf_vertex>\n\n                vViewPosition = - mvPosition.xyz;\n\n                #{POST}\n            }", c.fragment += "#define MATCAP\n            uniform sampler2D matcap;\n            varying vec3 vViewPosition;\n\t\t\tvarying vec2 vUv;\n\n            #include <common>\n            #include <dithering_pars_fragment>\n\n            #include <normal_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n\n            void main() {\n                #{PRE}\n\n                vec4 diffuseColor = vec4( 1.0);\n\n                #include <logdepthbuf_fragment>\n                #include <normal_fragment_begin>\n\n                vec3 viewDir = normalize( vViewPosition );\n\n\t\t\t\tviewDir = normalize(\n\t\t\t\t\tviewDir +\n\t\t\t\t\tvec3((vUv - 0.5) * 1.0, 0.0)\n\t\t\t\t);\n\n                vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n                vec3 y = cross( viewDir, x );\n                vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n                vec4 matcapColor = texture2D( matcap, uv );\n                matcapColor = matcapTexelToLinear( matcapColor );\n\n                vec3 outgoingLight =  matcapColor.rgb;\n\n                #include <output_fragment>\n\n                #{POST}\n\n                #include <tonemapping_fragment>\n                #include <encodings_fragment>\n                #include <premultiplied_alpha_fragment>\n                #include <dithering_fragment>\n            }", d.matcap = !0;
                break;
            case "physical":
                c.vertex += "\n            #define STANDARD\n\n            varying vec3 vViewPosition;\n\n            #ifdef USE_TRANSMISSION\n                varying vec3 vWorldPosition;\n            #endif\n\n            #include <common>\n            #include <uv_pars_vertex>\n            #include <uv2_pars_vertex>\n            #include <displacementmap_pars_vertex>\n            #include <color_pars_vertex>\n            #include <normal_pars_vertex>\n            #include <shadowmap_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n\n            void main() {\n                #{PRE}\n\n                #include <uv_vertex>\n                #include <uv2_vertex>\n                #include <color_vertex>\n\n                #include <beginnormal_vertex>\n                #include <defaultnormal_vertex>\n                #include <normal_vertex>\n\n                #include <begin_vertex>\n                #include <displacementmap_vertex>\n                #include <project_vertex>\n                #include <logdepthbuf_vertex>\n\n                vViewPosition = - mvPosition.xyz;\n\n                #include <worldpos_vertex>\n                #include <shadowmap_vertex>\n\n                #ifdef USE_TRANSMISSION\n                    vWorldPosition = worldPosition.xyz;\n                #endif\n\n                #{POST}\n            }\n            ", c.fragment += "\n            #define STANDARD\n\n            #ifdef PHYSICAL\n                #define IOR\n                #define SPECULAR\n            #endif\n\n            uniform vec3 diffuse;\n            uniform vec3 emissive;\n            uniform float roughness;\n            uniform float metalness;\n            uniform float opacity;\n\n            #ifdef IOR\n                uniform float ior;\n            #endif\n\n            #ifdef SPECULAR\n                uniform float specularIntensity;\n                uniform vec3 specularColor;\n\n                #ifdef USE_SPECULARINTENSITYMAP\n                    uniform sampler2D specularIntensityMap;\n                #endif\n\n                #ifdef USE_SPECULARCOLORMAP\n                    uniform sampler2D specularColorMap;\n                #endif\n            #endif\n\n            #ifdef USE_CLEARCOAT\n                uniform float clearcoat;\n                uniform float clearcoatRoughness;\n            #endif\n\n            #ifdef USE_SHEEN\n                uniform vec3 sheenColor;\n                uniform float sheenRoughness;\n\n                #ifdef USE_SHEENCOLORMAP\n                    uniform sampler2D sheenColorMap;\n                #endif\n\n                #ifdef USE_SHEENROUGHNESSMAP\n                    uniform sampler2D sheenRoughnessMap;\n                #endif\n            #endif\n\n            varying vec3 vViewPosition;\n\n            #include <common>\n            #include <packing>\n            #include <dithering_pars_fragment>\n            #include <color_pars_fragment>\n            #include <uv_pars_fragment>\n            #include <uv2_pars_fragment>\n            #include <map_pars_fragment>\n            #include <alphamap_pars_fragment>\n            #include <alphatest_pars_fragment>\n            #include <aomap_pars_fragment>\n            #include <lightmap_pars_fragment>\n            #include <emissivemap_pars_fragment>\n            #include <bsdfs>\n            #include <cube_uv_reflection_fragment>\n            #include <envmap_common_pars_fragment>\n            #include <envmap_physical_pars_fragment>\n            #include <fog_pars_fragment>\n            #include <lights_pars_begin>\n            #include <normal_pars_fragment>\n            #include <lights_physical_pars_fragment>\n            #include <transmission_pars_fragment>\n            #include <shadowmap_pars_fragment>\n            #include <bumpmap_pars_fragment>\n            #include <normalmap_pars_fragment>\n            #include <clearcoat_pars_fragment>\n            #include <roughnessmap_pars_fragment>\n            #include <metalnessmap_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n\n            void main() {\n                #{PRE}\n\n                vec4 diffuseColor = vec4( diffuse, opacity );\n                ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n                vec3 totalEmissiveRadiance = emissive;\n\n                #include <logdepthbuf_fragment>\n                #include <map_fragment>\n                #include <color_fragment>\n                #include <alphamap_fragment>\n                #include <alphatest_fragment>\n                #include <roughnessmap_fragment>\n                #include <metalnessmap_fragment>\n                #include <normal_fragment_begin>\n                #include <normal_fragment_maps>\n                #include <clearcoat_normal_fragment_begin>\n                #include <clearcoat_normal_fragment_maps>\n                #include <emissivemap_fragment>\n\n                // accumulation\n                #include <lights_physical_fragment>\n                #include <lights_fragment_begin>\n                #include <lights_fragment_maps>\n                #include <lights_fragment_end>\n\n                // modulation\n                #include <aomap_fragment>\n\n                vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n                vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n                #include <transmission_fragment>\n\n                vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n                #ifdef USE_SHEEN\n                    // Sheen energy compensation approximation calculation can be found at the end of\n                    // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\n                    float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\n                    outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n                #endif\n\n                #ifdef USE_CLEARCOAT\n                    float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n                    vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\n                    outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n                #endif\n\n                #include <output_fragment>\n\n                #{POST}\n\n                #include <tonemapping_fragment>\n                #include <encodings_fragment>\n                #include <premultiplied_alpha_fragment>\n                #include <dithering_fragment>\n            }\n            ";
                break;
            default:
                r.map && (c.uniforms.map = {
                    value: r.map
                }, d.map = c.uniforms.map.value), void 0 !== r.opacity ? c.uniforms.opacity = {
                    value: r.opacity
                } : c.uniforms.opacity = {
                    value: 1
                }, r.color ? c.uniforms.diffuse = {
                    value: new THREE.Color(r.color)
                } : c.uniforms.diffuse = {
                    value: new THREE.Color("#ffffff")
                }, c.uniforms.uvTransform = {
                    value: new THREE.Matrix3
                }, c.vertex += "\n            #include <common>\n            #include <uv_pars_vertex>\n            #include <uv2_pars_vertex>\n            #include <envmap_pars_vertex>\n            #include <color_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n\n            void main() {\n                #{PRE}\n\n                #include <uv_vertex>\n                #include <uv2_vertex>\n                #include <color_vertex>\n\n                #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\n                    #include <beginnormal_vertex>\n                    #include <defaultnormal_vertex>\n\n                #endif\n\n                #include <begin_vertex>\n                #include <project_vertex>\n                #include <logdepthbuf_vertex>\n\n                #include <worldpos_vertex>\n                #include <envmap_vertex>\n\n                #{POST}\n            }", c.fragment += "\n            uniform vec3 diffuse;\n            uniform float opacity;\n\n            #ifndef FLAT_SHADED\n                varying vec3 vNormal;\n            #endif\n\n            #include <common>\n            #include <dithering_pars_fragment>\n            #include <color_pars_fragment>\n            #include <uv_pars_fragment>\n            #include <uv2_pars_fragment>\n            #include <map_pars_fragment>\n            #include <alphamap_pars_fragment>\n            #include <alphatest_pars_fragment>\n            #include <aomap_pars_fragment>\n            #include <lightmap_pars_fragment>\n            #include <envmap_common_pars_fragment>\n            #include <envmap_pars_fragment>\n            #include <cube_uv_reflection_fragment>\n            #include <fog_pars_fragment>\n            #include <specularmap_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n\n            void main() {\n                #{PRE}\n\n                vec4 diffuseColor = vec4( diffuse, opacity );\n\n                #include <logdepthbuf_fragment>\n                #include <map_fragment>\n                #include <color_fragment>\n                #include <alphamap_fragment>\n                #include <alphatest_fragment>\n                #include <specularmap_fragment>\n\n                ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n                // accumulation (baked indirect lighting only)\n                #ifdef USE_LIGHTMAP\n                    vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n                    reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n                #else\n                    reflectedLight.indirectDiffuse += vec3( 1.0 );\n                #endif\n\n                // modulation\n                #include <aomap_fragment>\n\n                reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n                vec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n                #include <envmap_fragment>\n\n                #include <output_fragment>\n                #include <tonemapping_fragment>\n                #include <encodings_fragment>\n                #include <premultiplied_alpha_fragment>\n                #include <dithering_fragment>\n\n                #{POST}\n            }"
        }
        c.vertex = c.vertex.replace("#{PRE}", c.vertexPre), c.vertex = c.vertex.replace("#{POST}", c.vertexPost), c.fragment = c.fragment.replace("#{PRE}", c.fragmentPre), c.fragment = c.fragment.replace("#{POST}", c.fragmentPost);
        for (let e in I) !1 === c.vertex.indexOf(e) && !1 === c.fragment.indexOf(e) || (c.uniforms[e] = I[e]);
        !1 === c.vertex.indexOf("vUv") && !1 === c.fragment.indexOf("vUv") || d.map || (d.map = !0);
        let m = new THREE.ShaderMaterial({
            uniforms: c.uniforms,
            vertexShader: c.vertex,
            fragmentShader: c.fragment
        });
        for (let e in d) d.hasOwnProperty(e) && (m[e] = d[e]);
        return s && (re[l] = m), m
    }
    let se = {};
    let de = new THREE.Box3;
    const ce = ["(", ")", "+", "-", "*", "/", ","],
        me = {
            cos: "Math.cos",
            sin: "Math.sin",
            max: "Math.max",
            min: "Math.min"
        },
        ue = {
            vw: "(context.sceneSize.x * 0.01)",
            vh: "(context.sceneSize.y * 0.01)",
            vmin: "(context.sceneSize.min * 0.01)",
            vmax: "(context.sceneSize.max * 0.01)",
            "%": "((this.bounds.width + (this.bounds.height ? this.bounds.height : this.bounds.width * 0.5)) / 200)",
            "%x": "(this.bounds.width * 0.01)",
            "%w": "(this.bounds.width * 0.01)",
            "%y": "(this.bounds.height * 0.01)",
            "%h": "(this.bounds.height * 0.01)",
            t: "this.t",
            x: "(this.mesh.position.x / context.sceneSize.x)",
            y: "(this.mesh.position.y / context.sceneSize.y)",
            mrx: "this.mouse.x",
            mry: "-this.mouse.y",
            mx: "context.mouse.x",
            my: "-context.mouse.y"
        },
        fe = ["[", "]", "`", '"', "'", ";", "{", "}", "this", "function", "new", "eval"],
        he = new RegExp(/\d+(\.\d*)?/);

    function pe() {
        this.mesh.position.set(this.bounds.x, this.bounds.y)
    }

    function ge(e) {
        if ("string" != typeof e) return "0";
        for (let t = 0; t < fe.length; t++) e = e.replaceAll(fe[t], "");
        for (let t = 0; t < ce.length; t++) e = e.replaceAll(ce[t], " " + ce[t] + " ");
        let t = (e = e.trim().replace(/\s+/g, " ")).split(" "),
            n = [];
        for (let e = 0; e < t.length; e++)
            if (-1 !== ce.indexOf(t[e])) n.push(t[e]);
            else if (me.hasOwnProperty(t[e].toLowerCase())) n.push(me[t[e].toLowerCase()]);
        else if (ue.hasOwnProperty(t[e].toLowerCase())) n.push(ue[t[e].toLowerCase()]);
        else {
            let i = t[e].match(he);
            if (i) {
                i = i[0];
                let o = parseFloat(i),
                    a = t[e].replace(i, "").trim();
                isFinite(o) || (o = 1), a && (a = ue.hasOwnProperty(a.toLowerCase()) ? ue[a.toLowerCase()] : ""), a ? n.push("(" + o.toString() + " * " + a + ")") : n.push(o.toString())
            } else n.push("1")
        }
        n = n.join(" ");
        for (let e in me) n = n.replaceAll(me[e] + " (", me[e] + "(");
        let i = (n.match(/\(/g) || "").length,
            o = (n.match(/\)/g) || "").length;
        return i > o && (n += ")".repeat(i - o)), o > i && (n = "(".repeat(i - o) + n), n
    }

    function ve(e, i, o) {
        let a = {
                file: !!o.file,
                mesh: i,
                element: e,
                bounds: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                t: 0,
                render: 0,
                scrollPerc: 0,
                animateTime: o.animateTime ? o.animateTime : n.defaultAnimateTime,
                viewPerc: 0,
                _viewPerc: 0,
                absolute: !(!o.position || !o.position.absolute)
            },
            r = "",
            l = "",
            s = "",
            d = "",
            c = "",
            m = "",
            u = "",
            f = "",
            h = "";
        o.animateIn && (o.animateDelay >= 0 && isFinite(o.animateDelay) ? a._viewPerc -= 1 / a.animateTime * o.animateDelay : a._viewPerc -= 1 / a.animateTime * n.defaultAnimateDelay, o.animateIn.includes("scale") && (u = "{out} * this.viewPerc", f = "{out} * this.viewPerc", h = "{out} * this.viewPerc"), o.animateIn.includes("up") && (s = "{out} - (1 - this.viewPerc) * " + ge("20vmin"), d = "{out} + (1 - this.viewPerc) * " + ge("20vmin")), o.animateIn.includes("down") && (s = "{out} + (1 - this.viewPerc) * " + ge("20vmin"), d = "{out} - (1 - this.viewPerc) * " + ge("20vmin")), o.animateIn.includes("left") && (l = "{out} + (1 - this.viewPerc) * " + ge("20vmin")), o.animateIn.includes("right") && (l = "{out} - (1 - this.viewPerc) * " + ge("20vmin")), o.animateIn.includes("flip") && (o.animateIn.includes("down") ? c = "{out} + (1 - this.viewPerc) * 90" : o.animateIn.includes("left") && !o.animateIn.includes("up") ? m = "{out} - (1 - this.viewPerc) * 90" : o.animateIn.includes("right") && !o.animateIn.includes("up") ? m = "{out} + (1 - this.viewPerc) * 90" : c = "{out} - (1 - this.viewPerc) * 90"));
        let p = "1",
            g = 1,
            v = 1;
        if (o.size && (p = ge(o.size), o.mobile && o.mobile.size && (p = "context.isMobile ? (" + ge(o.mobile.size) + ") : " + (p ? "(" + p + ")" : "1"))), !i.type.includes("Light")) {
            de.setFromObject(i);
            let e = (de.max.x - de.min.x + (de.max.y - de.min.y)) / 2;
            g = (de.max.x - de.min.x) / e, v = (de.max.y - de.min.y) / e, p = "1" === p ? Math.round(1 / e * 1e3) / 1e3 : "(" + p + ") / " + Math.round(1e3 * e) / 1e3
        }
        let _ = "",
            x = "",
            y = "";
        if (o.position ? (o.position.x && (_ = ge(o.position.x)), o.position.y && (x = ge(o.position.y)), o.position.z && (y = ge(o.position.z)), o.mobile && o.mobile.position && (o.mobile.position.x && (_ = "context.isMobile ? (" + ge(o.mobile.position.x) + ") : " + (_ ? "(" + _ + ")" : "0")), o.mobile.position.y && (x = "context.isMobile ? (" + ge(o.mobile.position.y) + ") : " + (x ? "(" + x + ")" : "0")), o.mobile.position.z && (y = "context.isMobile ? (" + ge(o.mobile.position.z) + ") : " + (y ? "(" + y + ")" : "0"))), o.position.absolute ? a.absolute = !0 : (_ = "this.bounds.x" + (_ ? " + (" + _ + ")" : ""), x = "this.bounds.y" + (x ? " + (" + x + ")" : "")), "light" === o.type ? y = "context.camera.position.z / 2" + (y ? " + (" + y + ")" : "") : y || (y = "0")) : (_ = "this.bounds.x", x = "this.bounds.y", y = "0", "light" === o.type && (y = "context.camera.position.z / 2")), o.avoid && o.avoid.length > 0) {
            a.avoid = o.avoid;
            for (let e = 0; e < o.avoid.length; e++) $.includes(o.avoid[e]) || $.push(o.avoid[e]);
            r += "this.posX = " + _.replace(".mouse.x", ".mouse.x * 0").replace(".mouse.y", ".mouse.y * 0") + ";\n", r += "this.posY = " + x.replace(".mouse.x", ".mouse.x * 0").replace(".mouse.y", ".mouse.y * 0") + ";\n", r += "this.posZ = " + y + ";\n", r += "this.avoidX = 0;\n", r += "this.avoidY = 0;\n";
            let e = .8;
            r += `\n\t\tfor (let i = 0; i < this.avoid.length; i++) {\n\t\t\tthis._avoidX = 0;\n\t\t\tthis._avoidY = 0;\n\n\t\t\tif (this.posY + ${p} * ${v} * ${e} > this.avoid[i].y - this.avoid[i].halfHeight &&\n\t\t\t\tthis.posY - ${p} * ${v} * ${e} < this.avoid[i].y + this.avoid[i].halfHeight &&\n\t\t\t\tthis.posX + ${p} * ${g} * ${e} > this.avoid[i].x - this.avoid[i].halfWidth &&\n\t\t\t\tthis.posX - ${p} * ${g} * ${e} < this.avoid[i].x + this.avoid[i].halfWidth) {\n\n\t\t\t\tif (this.posX > this.avoid[i].x) {\n\t\t\t\t\tthis._avoidX = (this.avoid[i].x + this.avoid[i].halfWidth + ${p} * ${g} * ${e}) - this.posX;\n\t\t\t\t} else {\n\t\t\t\t\tthis._avoidX = (this.avoid[i].x - this.avoid[i].halfWidth - ${p} * ${g} * ${e}) - this.posX;\n\t\t\t\t}\n\n\t\t\t\tif (this.posY > this.avoid[i].y) {\n\t\t\t\t\tthis._avoidY = (this.avoid[i].y + this.avoid[i].halfHeight + ${p} * ${v} * ${e}) - this.posY;\n\t\t\t\t} else {\n\t\t\t\t\tthis._avoidY = (this.avoid[i].y - this.avoid[i].halfHeight - ${p} * ${v} * ${e}) - this.posY;\n\t\t\t\t}\n\n\t\t\t\tthis._distX = Math.abs(this.posX - this.avoid[i].x);\n\t\t\t\tthis._distY = Math.abs(this.posY - this.avoid[i].y);\n\n\t\t\t\tif (this._distX > this._distY * 1.5) {\n\t\t\t\t\tthis.avoidX += this._avoidX;\n\t\t\t\t} else if (this._distY > this._distX * 1.5) {\n\t\t\t\t\tthis.avoidY += this._avoidY;\n\t\t\t\t} else if (Math.abs(this._avoidX) < Math.abs(this._avoidY)) {\n\t\t\t\t\tthis.avoidX += this._avoidX;\n\t\t\t\t} else {\n\t\t\t\t\tthis.avoidY += this._avoidY;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t`;
            let t = "context.avoidAmount";
            "number" == typeof o.avoidAmount && o.avoidAmount >= 0 && o.avoidAmount <= 10 && (t += " * " + o.avoidAmount.toString()), r += "this.mesh.position.set(\n" + (l ? l.replace("{out}", `${_} + this.avoidX * ${t} `) : `${_} + this.avoidX * ${t} `) + ",\n" + (s ? s.replace("{out}", `${x} + this.avoidY * ${t}`) : `${x} + this.avoidY * ${t}`) + ",\n" + y + "\n)\n"
        } else r += "this.mesh.position.set(\n" + (l ? l.replace("{out}", _) : _) + ",\n" + (s ? s.replace("{out}", x) : x) + ",\n" + y + "\n)\n";
        let b = "",
            w = "",
            S = "";
        if (o.rotation && (o.rotation.x && (b += ge(o.rotation.x)), o.rotation.y && (w += ge(o.rotation.y)), o.rotation.z && (S += ge(o.rotation.z)), o.mobile && o.mobile.rotation && (o.mobile.rotation.x && (b = "context.isMobile ? (" + ge(o.mobile.rotation.x) + ") : " + (b ? "(" + b + ")" : "0")), o.mobile.rotation.y && (w = "context.isMobile ? (" + ge(o.mobile.rotation.y) + ") : " + (w ? "(" + w + ")" : "0")), o.mobile.rotation.z && (S = "context.isMobile ? (" + ge(o.mobile.rotation.z) + ") : " + (S ? "(" + S + ")" : "0")))), o.lookAt) {
            let e = !0;
            switch (o.lookAt) {
                case "camera":
                    r += "this.mesh.lookAt(context.camera.position);\n";
                    break;
                case "element":
                    r += "this.mesh.lookAt(this.bounds.x, this.bounds.y, 0);\n";
                    break;
                case "center":
                    r += "this.mesh.lookAt(0, 0, 0);\n";
                    break;
                default:
                    e = !1
            }
            let t = "";
            if (e && o.lookAtAmount && 1 != o.lookAtAmount) {
                let e = parseFloat(o.lookAtAmount);
                isFinite(e) && (t = " * " + e)
            }
            t && (b = "(this.mesh.rotation.x" + t + ")" + (b ? " + " + b : ""), w = "(this.mesh.rotation.y" + t + ")" + (w ? " + " + w : ""), S = "(this.mesh.rotation.z" + t + ")" + (S ? " + " + S : ""))
        }(b || w || S || c || m) && (b = b || "0", w = w || "0", S = S || "0", b = c ? c.replace("{out}", b) : b, w = m ? m.replace("{out}", w) : w, S = S, "0" !== b && (b = "(" + b + ") * THREE.MathUtils.DEG2RAD"), "0" !== w && (w = "(" + w + ") * THREE.MathUtils.DEG2RAD"), "0" !== S && (S = "(" + S + ") * THREE.MathUtils.DEG2RAD"), r += "this.mesh.rotation.set(\n" + b + ",\n" + w + ",\n" + S + "\n)\n"), o.mobile && o.mobile.hide && (p = "context.isMobile ? 0 : " + (p ? "(" + p + ")" : "1")), o.shadows && (i.traverse((function(e) {
            e.isMesh ? (e.castShadow = !0, e.receiveShadow = !0, e.material && (e.material.needsUpdate = !0)) : e.isLight && (e.castShadow = !0)
        })), E.shadowMap.enabled || (E.shadowMap.enabled = !0));
        let T = p,
            C = p,
            z = p;
        if (o.scale && (o.scale.x && (T += " * (" + ge(o.scale.x) + ")"), o.scale.y && (C += " * (" + ge(o.scale.y) + ")"), o.scale.z && (z += " * (" + ge(o.scale.z) + ")")), ("1" !== T || "1" !== C || "1" !== z || u || f || h) && (r += "this.mesh.scale.set(\n" + (u ? u.replace("{out}", T) : T) + ",\n" + (f ? f.replace("{out}", C) : C) + ",\n" + (h ? h.replace("{out}", z) : z) + "\n)\n"), o.effects)
            for (let t = 0; t < o.effects.length; t++)
                if ("split" === o.effects[t].type) {
                    a.mesh2 = new THREE.Mesh(i.geometry, le(o, o.effects[t].material ? o.effects[t].material : o.material, o.effects[t])), a.lineElement = document.createElement("div"), a.lineElement.style.background = "#1d2027", a.lineElement.style.height = "3px", a.lineElement.style.width = "34%", a.lineElement.style.position = "fixed", e.appendChild(a.lineElement), a.viewBounds = {
                        x: 0,
                        y: 0
                    }, a.angle = Math.PI / 180 * 45, r = "this.viewBounds.x = (this.bounds.x / context.sceneSize.x + 0.5) * context.viewSize.x;\n" + r, r = "this.viewBounds.y = (this.bounds.y / context.sceneSize.y + 0.5) * context.viewSize.y;\n" + r, r = "this.viewBounds.size = ((this.screenBounds.width + (this.screenBounds.height ? this.screenBounds.height : this.screenBounds.width * 0.5)) / 6);\n" + r;
                    let n = "";
                    a.mesh.material.hasOverlay && (n += "this.mesh.material.uniforms.overlay_x.value = "), a.mesh2.material.hasOverlay && (n += "this.mesh2.material.uniforms.overlay_x.value = "), n += "this.mesh.material.uniforms.split_x.value = this.mesh2.material.uniforms.split_x.value = this.viewBounds.x", o.position && o.position.x ? n += " + ((" + ge(o.position.x) + ") / context.sceneSize.x) * context.viewSize.x;\n" : n += ";\n", a.mesh.material.hasOverlay && (n += "this.mesh.material.uniforms.overlay_y.value = "), a.mesh2.material.hasOverlay && (n += "this.mesh2.material.uniforms.overlay_y.value = "), n += "this.mesh.material.uniforms.split_y.value = this.mesh2.material.uniforms.split_y.value = this.viewBounds.y", o.position && o.position.y ? n += " + ((" + ge(o.position.y) + ") / context.sceneSize.y) * context.viewSize.y;\n" : n += ";\n", n += "this.mesh2.material.uniforms.split_angle.value = this.mesh.material.uniforms.split_angle.value = this.angle = (45 -this.mouse.x * 20 + this.mouse.y * 5) * Math.PI / 180", r += n + ";\n", r += "this.lineElement.style.left = this.viewBounds.x", o.position && o.position.x ? r += " + ((" + ge(o.position.x) + ") / context.sceneSize.y) * context.viewSize.y + 'px';\n" : r += " + 'px';\n", r += "this.lineElement.style.top = (context.viewSize.y - this.viewBounds.y)", o.position && o.position.y ? r += " - ((" + ge(o.position.y) + ") / context.sceneSize.y) * context.viewSize.y + 'px';\n" : r += " + 'px';\n", r += "this.lineElement.style.transform = 'translate(-50%,-50%) rotate(' + (this.angle * -1) + 'rad)';\n", r += "this.mesh2.position.set(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z)\n", (b || w || S || c || m) && (r += "this.mesh2.rotation.set(this.mesh.rotation.x, this.mesh.rotation.y, this.mesh.rotation.z)\n"), ("1" !== T || "1" !== C || "1" !== z || u || f || h) && (r += "this.mesh2.scale.set(this.mesh.scale.x, this.mesh.scale.y, this.mesh.scale.z)\n")
                }
        if (r.includes("this.mouse") && (a.mx = 0, a.my = 0, r.includes("this.mouse.y") && (r = "this.my = context.mouse.y - (this.bounds.y * -1) / context.sceneSize.y\n" + r), r.includes("this.mouse.x") && (r = "this.mx = context.mouse.x - this.bounds.x / context.sceneSize.x;\n" + r), r = r.replace(/(this\.mouse\.x)/g, "this.mx"), r = r.replace(/(this\.mouse\.y)/g, "this.my")), o.animateIn) {
            if (a.absolute) r += "this._viewPerc < 1 ? (this._viewPerc = Math.min(1, this._viewPerc + context.d / this.animateTime), this.viewPerc = ease(Math.max(0, this._viewPerc))) : null;\n";
            else {
                let e = "";
                d ? (e = d.replace("{out}", "this.mesh.position.y") + " > context.sceneSize.y * -0.51", e += " && ", e += d.replace("{out}", "this.mesh.position.y") + " < context.sceneSize.y * 0.51") : (e = "this.mesh.position.y > context.sceneSize.y * -0.51", e += " && ", e += "this.mesh.position.y < context.sceneSize.y * 0.51"), r += "if (this._viewPerc < 1 && (this._viewPerc > 0 || (" + e + "))) {\nthis._viewPerc = Math.min(1, this._viewPerc + context.d / this.animateTime);\nthis.viewPerc = ease(Math.max(0, this._viewPerc));\n}\n"
            }
            if (o.animateIn.includes("fade")) {
                let e = function(e, t, n, i, o, r) {
                    o.uniforms.obj_opacity.value = a.viewPerc
                };
                i.isGroup ? i.traverse((function(t) {
                    t.onBeforeRender = e
                })) : i.onBeforeRender = e, a.mesh2 && (a.mesh2.isGroup ? a.mesh2.traverse((function(t) {
                    t.onBeforeRender = e
                })) : a.mesh2.onBeforeRender = e)
            }
        }
        be(a);
        try {
            a.updateTransform = Function("context", "ease", r).bind(a, j, t)
        } catch (e) {
            a.updateTransform = pe.bind(a)
        }
        try {
            a.updateTransform()
        } catch (e) {
            a.updateTransform = pe.bind(a)
        }
        o.replace && (e.style.opacity = 0), F.push(a), i.isLight && (o.default || H.push(a)), a.mesh.material && a.mesh.material.hasPixel || o.material && o.material.pixel ? (M.add(a.mesh), P || Ae()) : R.add(a.mesh), a.mesh2 && (a.mesh2.material && a.mesh2.material.hasPixel ? (M.add(a.mesh2), P || Ae()) : R.add(a.mesh2)), o.onAdd && "function" == typeof o.onAdd && o.onAdd.call(a, j), o.onRender && "function" == typeof o.onRender && L.push(o.onRender.bind(a, j)), o.onRefresh && "function" == typeof o.onRefresh && B.push(o.onRefresh.bind(a, j))
    }
    let _e = ["bg", "frame-text"];

    function xe(e, t = null) {
        if (Array.isArray(e)) {
            for (let n = 0; n < e.length; n++) xe(e[n], t);
            return
        }
        if (e.element && (t = document.querySelector(e.element)), e.mobile && e.mobile.hide && j.isMobile) return void(t && "DIV" === t.tagName && 0 === t.childElementCount && "" === t.textContent && (t.__mobileUnused = !0, D.push(t)));
        if (t && "DIV" === t.tagName && 0 === t.childElementCount && "" === t.textContent && (t.__mobileUsed = !0), Array.isArray(e.scripts) && e.scripts.length > 0) return function(e, t) {
            if ("function" != typeof t) return !1;
            if (se.hasOwnProperty(e)) return se[e].loaded ? t() : (se[e].callbacks.push(t), !0);
            let n = {
                loaded: !1,
                tag: document.createElement("script"),
                callbacks: [t]
            };
            se[e] = n, n.tag.onload = function() {
                for (let e = 0; e < n.callbacks.length; e++) n.callbacks[e]()
            }, n.tag.src = e, document.head.appendChild(n.tag)
        }(e.scripts.pop(), xe.bind(null, e, t));
        let n = !1;
        if (e.element) {
            if (t) {
                n = [];
                let e = t.querySelectorAll("p, h1, h2, h3, h4, h5, h6, ul, ol, form");
                for (let t = 0; t < e.length; t++) {
                    let i = !1;
                    for (let n = 0; n < _e.length; n++) e[t].className.includes(_e[n]) && (i = !0);
                    if (!i && ("DIV" === e[t].parentNode.tagName && !n.includes(e[t].parentNode))) {
                        for (let n = 0; n < _e.length; n++) e[t].parentNode.className.includes(_e[n]) && (i = !0);
                        i || n.push(e[t].parentNode)
                    }
                }
            }
        } else null === t && (t = document.body);
        if (n && n.length > 0 && ("number" == typeof e.avoidAmount && 0 === e.avoidAmount || (e.avoid = n)), t && "object" == typeof t && "function" == typeof t.getBoundingClientRect) {
            if ("light" === e.type) {
                let n = !1;
                return n = e.ambient ? new THREE.AmbientLight(e.color ? e.color : 16777215, e.intensity) : new THREE.DirectionalLight(e.color ? e.color : 16777215, e.intensity), ve(t, n, e)
            }
            if (e.file) return S.load(e.file, (function(n) {
                let i = n.scene;
                for (; i.isGroup && 1 === i.children.length;) i = i.children[0];
                if (e.material) {
                    let t = le(e, e.material);
                    n.scene.traverse((function(e) {
                        e.material && (e.material = t)
                    }))
                }
                ve(t, i, e)
            }), (function(e) {}), (function(e) {})); {
                let n = "sphere";
                "image" === e.type ? n = "plane" : e.geo ? n = e.geo : e.type && (n = e.type), ie(n, (function(n) {
                    n && ve(t, new THREE.Mesh(n, le(e, e.material)), e)
                }))
            }
        }
    }

    function ye(e) {
        e.__refreshId !== W && (e.screenBounds = e.getBoundingClientRect(), e.__refreshId = W), e.x = (e.screenBounds.x + e.screenBounds.width / 2 - l.x) / r.x * w.x, e.y = (e.screenBounds.y + e.screenBounds.height / 2 - l.y) / r.y * w.y * -1, e.width = e.screenBounds.width / r.x * w.x, e.height = e.screenBounds.height / r.y * w.y, e.halfWidth = e.width / 2, e.halfHeight = e.height / 2
    }

    function be(e) {
        e.element.__refreshId !== W && (e.element.screenBounds = e.element.getBoundingClientRect(), e.element.__refreshId = W), e.screenBounds = e.element.screenBounds, e.bounds.x = (e.screenBounds.x + e.screenBounds.width / 2 - l.x) / r.x * w.x, e.bounds.y = (e.screenBounds.y + e.screenBounds.height / 2 - l.y) / r.y * w.y * -1, e.bounds.width = e.screenBounds.width / r.x * w.x, e.bounds.height = e.screenBounds.height / r.y * w.y, e.absolute ? (e.render = !0, e.scrollPerc = 1) : (e.render = e.screenBounds.y < 1.5 * window.innerHeight && e.screenBounds.y + e.screenBounds.height > .5 * -window.innerHeight, e.viewMinDist = Math.min(e.screenBounds.height / 2, r.y / 3), e.scrollPerc = 1 - Math.min(1, Math.max(0, Math.abs(r.y / 2 - (e.screenBounds.y + e.screenBounds.height / 2)) - e.viewMinDist, Math.abs(r.y / 2 - (e.screenBounds.y + e.screenBounds.height / 2)) - e.viewMinDist) / e.viewMinDist)), e.render && !e.mesh.visible ? e.mesh.visible = !0 : !e.render && e.mesh.visible && (e.mesh.visible = !1)
    }

    function we(e) {
        e.__refreshId !== W && (e.screenBounds = e.getBoundingClientRect(), e.__refreshId = W)
    }
    let Ee = !1,
        Pe = 0,
        Se = 0;

    function Te() {
        for (; Se < 3 && Pe + Se < window.studio_add3D.length;) xe(window.studio_add3D[Pe + Se]), Se += 1;
        Pe += Se, Se = 0, Pe < window.studio_add3D.length ? requestAnimationFrame(Te) : Re()
    }

    function Re() {
        for (let e = 0; e < D.length; e++) D[e].__mobileUsed || (D[e].style.display = "none")
    }

    function Ce() {
        function e(e) {
            O.set(e.clientX / r.x - .5, e.clientY / r.y - .5)
        }
        Ee || (Ee = !0, window.studio_set && De(window.studio_set), m.style.display = "block", m.style.position = "absolute", m.style.transform = "translateY(" + V + "px)", m.style.top = 0, m.style.left = 0, m.style.pointerEvents = "none", m.style.userSelect = "none", m.style.zIndex = -1, m.className = "studio-canvas-grid", E.outputEncoding = THREE.sRGBEncoding, E.toneMappingExposure = 1, A.position.z = 30, A.lookAt(0, 0, 0), E.domElement.style.position = "absolute", E.domElement.style.transform = "translateY(" + V + "px)", E.domElement.style.top = 0, E.domElement.style.left = 0, E.domElement.style.pointerEvents = "none", E.domElement.style.userSelect = "none", E.domElement.className = "studio-canvas-3d", window.addEventListener("scroll", (function() {
            Q()
        }), {
            passive: !0
        }), document.body.addEventListener("pointermove", e, {
            passive: !0
        }), document.body.addEventListener("touchmove", (function(t) {
            e(t.touches[0])
        }), {
            passive: !0
        }), document.body.addEventListener("pointerdown", e, {
            passive: !0
        }), document.body.addEventListener("pointerup", e, {
            passive: !0
        }), window.addEventListener("resize", K), window.addEventListener("scroll", J), requestAnimationFrame(X), Q(3), function() {
            let e = document.querySelectorAll(".project-slider, .cta");
            for (let t = 0; t < e.length; t++) h.push(e[t]);
            p = h.length > 0, _ = document.querySelector("footer"), _ && (g = !0, x = _.querySelector(".shape"), x && (v = !0))
        }(), q(), J(), document.body.firstElementChild ? (document.body.insertBefore(E.domElement, document.body.firstElementChild), document.body.insertBefore(m, document.body.firstElementChild)) : (document.body.appendChild(E.domElement), document.body.appendChild(m)), ze && Ae(), window.studio_add3D ? Te() : Re())
    }
    let Me = !1,
        ze = !1;

    function Ae() {
        Ee ? Me || (Me = !0, P = new THREE.WebGLRenderer({
            antialias: !1,
            alpha: !0
        }), P.isPixel = !0, P.domElement.style.position = "absolute", P.domElement.style.transform = "translateY(" + V + "px)", P.domElement.style.top = 0, P.domElement.style.left = 0, P.domElement.style.pointerEvents = "none", P.domElement.style.userSelect = "none", P.domElement.style.imageRendering = "pixelated", P.domElement.className = "studio-canvas-pixel", document.body.firstElementChild ? document.body.insertBefore(P.domElement, document.body.firstElementChild) : document.body.appendChild(P.domElement), K()) : ze = !0
    }

    function Oe(e) {
        for (let t in e) "_" !== t.substring(0, 1) && "padding" !== t && "mainPadding" !== t && f.hasOwnProperty(t) && typeof f[t] == typeof e[t] && (f[t] = e[t])
    }

    function De(e) {
        for (let t in e) "_" !== t.substring(0, 1) && ("grid" !== t ? ("debug" === t || n.hasOwnProperty(t) && typeof n[t] == typeof e[t] && (n[t] = e[t]), "pixelScale" === t ? K() : "pixelPalette" === t && i(), "avoidAmount" === t && "number" == typeof e[t] && (j.avoidAmount = e[t])) : Oe(e[t]))
    }
    return "interactive" === document.readyState || "complete" === document.readyState ? Ce() : document.addEventListener("DOMContentLoaded", (function() {
        Ce()
    })), e.add3D = xe, e.context = j, e.getMaterial = le, e.getObject = function(e, t) {
        if ("function" != typeof t) return !1;
        if ("light" === e.type) {
            let n = !1;
            return n = e.ambient ? new THREE.AmbientLight(e.color ? e.color : 16777215, e.intensity) : new THREE.DirectionalLight(e.color ? e.color : 16777215, e.intensity), t(n, e)
        }
        if (e.file) return S.load(e.file, (function(n) {
            let i = n.scene;
            for (; i.isGroup && 1 === i.children.length;) i = i.children[0];
            if (e.material) {
                let t = le(e, e.material);
                n.scene.traverse((function(e) {
                    e.material && (e.material = t)
                }))
            }
            t(i, e)
        }), (function(e) {}), (function(e) {})); {
            let n = "sphere";
            "image" === e.type ? n = "plane" : e.geo ? n = e.geo : e.type && (n = e.type), ie(n, (function(n) {
                n && t(new THREE.Mesh(n, le(e, e.material)))
            }))
        }
    }, e.initPixel = Ae, e.set = De, Object.defineProperty(e, "__esModule", {
        value: !0
    }), e
}({});