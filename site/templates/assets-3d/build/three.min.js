var THREE = function(e) {
    "use strict";
    const t = 100,
        n = 301,
        i = 302,
        r = 303,
        a = 304,
        s = 306,
        o = 307,
        l = 1e3,
        c = 1001,
        h = 1002,
        u = 1003,
        d = 1004,
        p = 1005,
        m = 1006,
        f = 1007,
        g = 1008,
        _ = 1009,
        v = 1012,
        x = 1014,
        y = 1015,
        M = 1016,
        S = 1020,
        T = 1022,
        b = 1023,
        E = 1026,
        w = 1027,
        A = 33776,
        R = 33777,
        L = 33778,
        C = 33779,
        P = 35840,
        D = 35841,
        N = 35842,
        I = 35843,
        U = 37492,
        F = 37496,
        O = 3e3,
        B = 3001,
        z = 7680,
        G = 35044,
        H = "300 es",
        V = [];
    for (let e = 0; e < 256; e++) V[e] = (e < 16 ? "0" : "") + e.toString(16);
    const k = Math.PI / 180,
        W = 180 / Math.PI;

    function X() {
        const e = 4294967295 * Math.random() | 0,
            t = 4294967295 * Math.random() | 0,
            n = 4294967295 * Math.random() | 0,
            i = 4294967295 * Math.random() | 0;
        return (V[255 & e] + V[e >> 8 & 255] + V[e >> 16 & 255] + V[e >> 24 & 255] + "-" + V[255 & t] + V[t >> 8 & 255] + "-" + V[t >> 16 & 15 | 64] + V[t >> 24 & 255] + "-" + V[63 & n | 128] + V[n >> 8 & 255] + "-" + V[n >> 16 & 255] + V[n >> 24 & 255] + V[255 & i] + V[i >> 8 & 255] + V[i >> 16 & 255] + V[i >> 24 & 255]).toUpperCase()
    }

    function j(e, t, n) {
        return Math.max(t, Math.min(n, e))
    }

    function q(e, t, n) {
        return (1 - n) * e + n * t
    }

    function Y(e) {
        return 0 == (e & e - 1) && 0 !== e
    }

    function K(e) {
        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
    }
    class Z {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            this._x = e, this._y = t, this._z = n, this._w = i
        }
        static slerp(e, t, n, i) {
            return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, i)
        }
        static slerpFlat(e, t, n, i, r, a, s) {
            let o = n[i + 0],
                l = n[i + 1],
                c = n[i + 2],
                h = n[i + 3];
            const u = r[a + 0],
                d = r[a + 1],
                p = r[a + 2],
                m = r[a + 3];
            if (0 === s) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = h);
            if (1 === s) return e[t + 0] = u, e[t + 1] = d, e[t + 2] = p, void(e[t + 3] = m);
            if (h !== m || o !== u || l !== d || c !== p) {
                let e = 1 - s;
                const t = o * u + l * d + c * p + h * m,
                    n = t >= 0 ? 1 : -1,
                    i = 1 - t * t;
                if (i > Number.EPSILON) {
                    const r = Math.sqrt(i),
                        a = Math.atan2(r, t * n);
                    e = Math.sin(e * a) / r, s = Math.sin(s * a) / r
                }
                const r = s * n;
                if (o = o * e + u * r, l = l * e + d * r, c = c * e + p * r, h = h * e + m * r, e === 1 - s) {
                    const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                    o *= e, l *= e, c *= e, h *= e
                }
            }
            e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, a) {
            const s = n[i],
                o = n[i + 1],
                l = n[i + 2],
                c = n[i + 3],
                h = r[a],
                u = r[a + 1],
                d = r[a + 2],
                p = r[a + 3];
            return e[t] = s * p + c * h + o * d - l * u, e[t + 1] = o * p + c * u + l * h - s * d, e[t + 2] = l * p + c * d + s * u - o * h, e[t + 3] = c * p - s * h - o * u - l * d, e
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e, this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(e) {
            this._w = e, this._onChangeCallback()
        }
        set(e, t, n, i) {
            return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
        }
        setFromEuler(e, t) {
            if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            const n = e._x,
                i = e._y,
                r = e._z,
                a = e._order,
                s = Math.cos,
                o = Math.sin,
                l = s(n / 2),
                c = s(i / 2),
                h = s(r / 2),
                u = o(n / 2),
                d = o(i / 2),
                p = o(r / 2);
            switch (a) {
                case "XYZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "YXZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "ZXY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "ZYX":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "YZX":
                    this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "XZY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
            }
            return !1 !== t && this._onChangeCallback(), this
        }
        setFromAxisAngle(e, t) {
            const n = t / 2,
                i = Math.sin(n);
            return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        }
        setFromRotationMatrix(e) {
            const t = e.elements,
                n = t[0],
                i = t[4],
                r = t[8],
                a = t[1],
                s = t[5],
                o = t[9],
                l = t[2],
                c = t[6],
                h = t[10],
                u = n + s + h;
            if (u > 0) {
                const e = .5 / Math.sqrt(u + 1);
                this._w = .25 / e, this._x = (c - o) * e, this._y = (r - l) * e, this._z = (a - i) * e
            } else if (n > s && n > h) {
                const e = 2 * Math.sqrt(1 + n - s - h);
                this._w = (c - o) / e, this._x = .25 * e, this._y = (i + a) / e, this._z = (r + l) / e
            } else if (s > h) {
                const e = 2 * Math.sqrt(1 + s - n - h);
                this._w = (r - l) / e, this._x = (i + a) / e, this._y = .25 * e, this._z = (o + c) / e
            } else {
                const e = 2 * Math.sqrt(1 + h - n - s);
                this._w = (a - i) / e, this._x = (r + l) / e, this._y = (o + c) / e, this._z = .25 * e
            }
            return this._onChangeCallback(), this
        }
        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
        }
        angleTo(e) {
            return 2 * Math.acos(Math.abs(j(this.dot(e), -1, 1)))
        }
        rotateTowards(e, t) {
            const n = this.angleTo(e);
            if (0 === n) return this;
            const i = Math.min(1, t / n);
            return this.slerp(e, i), this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        }
        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let e = this.length();
            return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
        }
        multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        }
        premultiply(e) {
            return this.multiplyQuaternions(e, this)
        }
        multiplyQuaternions(e, t) {
            const n = e._x,
                i = e._y,
                r = e._z,
                a = e._w,
                s = t._x,
                o = t._y,
                l = t._z,
                c = t._w;
            return this._x = n * c + a * s + i * l - r * o, this._y = i * c + a * o + r * s - n * l, this._z = r * c + a * l + n * o - i * s, this._w = a * c - n * s - i * o - r * l, this._onChangeCallback(), this
        }
        slerp(e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            const n = this._x,
                i = this._y,
                r = this._z,
                a = this._w;
            let s = a * e._w + n * e._x + i * e._y + r * e._z;
            if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
            const o = 1 - s * s;
            if (o <= Number.EPSILON) {
                const e = 1 - t;
                return this._w = e * a + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this._onChangeCallback(), this
            }
            const l = Math.sqrt(o),
                c = Math.atan2(l, s),
                h = Math.sin((1 - t) * c) / l,
                u = Math.sin(t * c) / l;
            return this._w = a * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
        }
        slerpQuaternions(e, t, n) {
            this.copy(e).slerp(t, n)
        }
        random() {
            const e = Math.random(),
                t = Math.sqrt(1 - e),
                n = Math.sqrt(e),
                i = 2 * Math.PI * Math.random(),
                r = 2 * Math.PI * Math.random();
            return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i))
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        }
        fromArray(e, t = 0) {
            return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        }
        fromBufferAttribute(e, t) {
            return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
        }
        _onChange(e) {
            return this._onChangeCallback = e, this
        }
        _onChangeCallback() {}
    }
    Z.prototype.isQuaternion = !0;
    class J {
        constructor(e = 0, t = 0, n = 0) {
            this.x = e, this.y = t, this.z = n
        }
        set(e, t, n) {
            return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setZ(e) {
            return this.z = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        }
        add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        }
        sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        }
        multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        }
        multiplyVectors(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        }
        applyEuler(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion($.setFromEuler(e))
        }
        applyAxisAngle(e, t) {
            return this.applyQuaternion($.setFromAxisAngle(e, t))
        }
        applyMatrix3(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
        }
        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize()
        }
        applyMatrix4(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = e.elements,
                a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a, this
        }
        applyQuaternion(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = e.x,
                a = e.y,
                s = e.z,
                o = e.w,
                l = o * t + a * i - s * n,
                c = o * n + s * t - r * i,
                h = o * i + r * n - a * t,
                u = -r * t - a * n - s * i;
            return this.x = l * o + u * -r + c * -s - h * -a, this.y = c * o + u * -a + h * -r - l * -s, this.z = h * o + u * -s + l * -a - c * -r, this
        }
        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        }
        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        }
        transformDirection(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = e.elements;
            return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
        }
        cross(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
        }
        crossVectors(e, t) {
            const n = e.x,
                i = e.y,
                r = e.z,
                a = t.x,
                s = t.y,
                o = t.z;
            return this.x = i * o - r * s, this.y = r * a - n * o, this.z = n * s - i * a, this
        }
        projectOnVector(e) {
            const t = e.lengthSq();
            if (0 === t) return this.set(0, 0, 0);
            const n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n)
        }
        projectOnPlane(e) {
            return Q.copy(this).projectOnVector(e), this.sub(Q)
        }
        reflect(e) {
            return this.sub(Q.copy(e).multiplyScalar(2 * this.dot(e)))
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (0 === t) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(j(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x,
                n = this.y - e.y,
                i = this.z - e.z;
            return t * t + n * n + i * i
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        }
        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        }
        setFromSphericalCoords(e, t, n) {
            const i = Math.sin(t) * e;
            return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
        }
        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        }
        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this
        }
        setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length(),
                n = this.setFromMatrixColumn(e, 1).length(),
                i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = i, this
        }
        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, 4 * t)
        }
        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, 3 * t)
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        }
        fromBufferAttribute(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
        randomDirection() {
            const e = 2 * (Math.random() - .5),
                t = Math.random() * Math.PI * 2,
                n = Math.sqrt(1 - e ** 2);
            return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z
        }
    }
    J.prototype.isVector3 = !0;
    const Q = new J,
        $ = new Z;
    class ee {
        constructor(e = new J(1 / 0, 1 / 0, 1 / 0), t = new J(-1 / 0, -1 / 0, -1 / 0)) {
            this.min = e, this.max = t
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        }
        setFromArray(e) {
            let t = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                r = -1 / 0,
                a = -1 / 0,
                s = -1 / 0;
            for (let o = 0, l = e.length; o < l; o += 3) {
                const l = e[o],
                    c = e[o + 1],
                    h = e[o + 2];
                l < t && (t = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > a && (a = c), h > s && (s = h)
            }
            return this.min.set(t, n, i), this.max.set(r, a, s), this
        }
        setFromBufferAttribute(e) {
            let t = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                r = -1 / 0,
                a = -1 / 0,
                s = -1 / 0;
            for (let o = 0, l = e.count; o < l; o++) {
                const l = e.getX(o),
                    c = e.getY(o),
                    h = e.getZ(o);
                l < t && (t = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > a && (a = c), h > s && (s = h)
            }
            return this.min.set(t, n, i), this.max.set(r, a, s), this
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        }
        setFromCenterAndSize(e, t) {
            const n = ne.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
        }
        setFromObject(e) {
            return this.makeEmpty(), this.expandByObject(e)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        }
        expandByObject(e) {
            e.updateWorldMatrix(!1, !1);
            const t = e.geometry;
            void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), ie.copy(t.boundingBox), ie.applyMatrix4(e.matrixWorld), this.union(ie));
            const n = e.children;
            for (let e = 0, t = n.length; e < t; e++) this.expandByObject(n[e]);
            return this
        }
        containsPoint(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        }
        intersectsSphere(e) {
            return this.clampPoint(e.center, ne), ne.distanceToSquared(e.center) <= e.radius * e.radius
        }
        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
        }
        intersectsTriangle(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(he), ue.subVectors(this.max, he), re.subVectors(e.a, he), ae.subVectors(e.b, he), se.subVectors(e.c, he), oe.subVectors(ae, re), le.subVectors(se, ae), ce.subVectors(re, se);
            let t = [0, -oe.z, oe.y, 0, -le.z, le.y, 0, -ce.z, ce.y, oe.z, 0, -oe.x, le.z, 0, -le.x, ce.z, 0, -ce.x, -oe.y, oe.x, 0, -le.y, le.x, 0, -ce.y, ce.x, 0];
            return !!me(t, re, ae, se, ue) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!me(t, re, ae, se, ue) && (de.crossVectors(oe, le), t = [de.x, de.y, de.z], me(t, re, ae, se, ue)))
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max)
        }
        distanceToPoint(e) {
            return ne.copy(e).clamp(this.min, this.max).sub(e).length()
        }
        getBoundingSphere(e) {
            return this.getCenter(e.center), e.radius = .5 * this.getSize(ne).length(), e
        }
        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        }
        applyMatrix4(e) {
            return this.isEmpty() || (te[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), te[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), te[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), te[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), te[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), te[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), te[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), te[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(te)), this
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }
    ee.prototype.isBox3 = !0;
    const te = [new J, new J, new J, new J, new J, new J, new J, new J],
        ne = new J,
        ie = new ee,
        re = new J,
        ae = new J,
        se = new J,
        oe = new J,
        le = new J,
        ce = new J,
        he = new J,
        ue = new J,
        de = new J,
        pe = new J;

    function me(e, t, n, i, r) {
        for (let a = 0, s = e.length - 3; a <= s; a += 3) {
            pe.fromArray(e, a);
            const s = r.x * Math.abs(pe.x) + r.y * Math.abs(pe.y) + r.z * Math.abs(pe.z),
                o = t.dot(pe),
                l = n.dot(pe),
                c = i.dot(pe);
            if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s) return !1
        }
        return !0
    }
    const fe = new ee,
        ge = new J,
        _e = new J,
        ve = new J;
    class xe {
        constructor(e = new J, t = -1) {
            this.center = e, this.radius = t
        }
        set(e, t) {
            return this.center.copy(e), this.radius = t, this
        }
        setFromPoints(e, t) {
            const n = this.center;
            void 0 !== t ? n.copy(t) : fe.setFromPoints(e).getCenter(n);
            let i = 0;
            for (let t = 0, r = e.length; t < r; t++) i = Math.max(i, n.distanceToSquared(e[t]));
            return this.radius = Math.sqrt(i), this
        }
        copy(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this
        }
        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius
        }
        intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        }
        intersectsBox(e) {
            return e.intersectsSphere(this)
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(e, t) {
            const n = this.center.distanceToSquared(e);
            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        }
        getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
        }
        applyMatrix4(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
        }
        translate(e) {
            return this.center.add(e), this
        }
        expandByPoint(e) {
            ve.subVectors(e, this.center);
            const t = ve.lengthSq();
            if (t > this.radius * this.radius) {
                const e = Math.sqrt(t),
                    n = .5 * (e - this.radius);
                this.center.add(ve.multiplyScalar(n / e)), this.radius += n
            }
            return this
        }
        union(e) {
            return !0 === this.center.equals(e.center) ? _e.set(0, 0, 1).multiplyScalar(e.radius) : _e.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(ge.copy(e.center).add(_e)), this.expandByPoint(ge.copy(e.center).sub(_e)), this
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    class ye {
        constructor() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }
        set(e, t, n, i, r, a, s, o, l) {
            const c = this.elements;
            return c[0] = e, c[1] = i, c[2] = s, c[3] = t, c[4] = r, c[5] = o, c[6] = n, c[7] = a, c[8] = l, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }
        copy(e) {
            const t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        }
        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements,
                i = t.elements,
                r = this.elements,
                a = n[0],
                s = n[3],
                o = n[6],
                l = n[1],
                c = n[4],
                h = n[7],
                u = n[2],
                d = n[5],
                p = n[8],
                m = i[0],
                f = i[3],
                g = i[6],
                _ = i[1],
                v = i[4],
                x = i[7],
                y = i[2],
                M = i[5],
                S = i[8];
            return r[0] = a * m + s * _ + o * y, r[3] = a * f + s * v + o * M, r[6] = a * g + s * x + o * S, r[1] = l * m + c * _ + h * y, r[4] = l * f + c * v + h * M, r[7] = l * g + c * x + h * S, r[2] = u * m + d * _ + p * y, r[5] = u * f + d * v + p * M, r[8] = u * g + d * x + p * S, this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        }
        determinant() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                r = e[3],
                a = e[4],
                s = e[5],
                o = e[6],
                l = e[7],
                c = e[8];
            return t * a * c - t * s * l - n * r * c + n * s * o + i * r * l - i * a * o
        }
        invert() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                r = e[3],
                a = e[4],
                s = e[5],
                o = e[6],
                l = e[7],
                c = e[8],
                h = c * a - s * l,
                u = s * o - c * r,
                d = l * r - a * o,
                p = t * h + n * u + i * d;
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const m = 1 / p;
            return e[0] = h * m, e[1] = (i * l - c * n) * m, e[2] = (s * n - i * a) * m, e[3] = u * m, e[4] = (c * t - i * o) * m, e[5] = (i * r - s * t) * m, e[6] = d * m, e[7] = (n * o - l * t) * m, e[8] = (a * t - n * r) * m, this
        }
        transpose() {
            let e;
            const t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose()
        }
        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        }
        setUvTransform(e, t, n, i, r, a, s) {
            const o = Math.cos(r),
                l = Math.sin(r);
            return this.set(n * o, n * l, -n * (o * a + l * s) + a + e, -i * l, i * o, -i * (-l * a + o * s) + s + t, 0, 0, 1), this
        }
        scale(e, t) {
            const n = this.elements;
            return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
        }
        rotate(e) {
            const t = Math.cos(e),
                n = Math.sin(e),
                i = this.elements,
                r = i[0],
                a = i[3],
                s = i[6],
                o = i[1],
                l = i[4],
                c = i[7];
            return i[0] = t * r + n * o, i[3] = t * a + n * l, i[6] = t * s + n * c, i[1] = -n * r + t * o, i[4] = -n * a + t * l, i[7] = -n * s + t * c, this
        }
        translate(e, t) {
            const n = this.elements;
            return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
        }
        equals(e) {
            const t = this.elements,
                n = e.elements;
            for (let e = 0; e < 9; e++)
                if (t[e] !== n[e]) return !1;
            return !0
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
        }
        clone() {
            return (new this.constructor).fromArray(this.elements)
        }
    }
    ye.prototype.isMatrix3 = !0;
    const Me = new J,
        Se = new J,
        Te = new ye;
    class be {
        constructor(e = new J(1, 0, 0), t = 0) {
            this.normal = e, this.constant = t
        }
        set(e, t) {
            return this.normal.copy(e), this.constant = t, this
        }
        setComponents(e, t, n, i) {
            return this.normal.set(e, t, n), this.constant = i, this
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        }
        setFromCoplanarPoints(e, t, n) {
            const i = Me.subVectors(n, t).cross(Se.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e), this
        }
        copy(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        }
        normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        }
        negate() {
            return this.constant *= -1, this.normal.negate(), this
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius
        }
        projectPoint(e, t) {
            return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        }
        intersectLine(e, t) {
            const n = e.delta(Me),
                i = this.normal.dot(n);
            if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
            const r = -(e.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start)
        }
        intersectsLine(e) {
            const t = this.distanceToPoint(e.start),
                n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        }
        intersectsBox(e) {
            return e.intersectsPlane(this)
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this)
        }
        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(e, t) {
            const n = t || Te.getNormalMatrix(e),
                i = this.coplanarPoint(Me).applyMatrix4(e),
                r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r), this
        }
        translate(e) {
            return this.constant -= e.dot(this.normal), this
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    be.prototype.isPlane = !0;
    const Ee = new xe,
        we = new J;
    class Ae {
        constructor(e = new be, t = new be, n = new be, i = new be, r = new be, a = new be) {
            this.planes = [e, t, n, i, r, a]
        }
        set(e, t, n, i, r, a) {
            const s = this.planes;
            return s[0].copy(e), s[1].copy(t), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(a), this
        }
        copy(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
            return this
        }
        setFromProjectionMatrix(e) {
            const t = this.planes,
                n = e.elements,
                i = n[0],
                r = n[1],
                a = n[2],
                s = n[3],
                o = n[4],
                l = n[5],
                c = n[6],
                h = n[7],
                u = n[8],
                d = n[9],
                p = n[10],
                m = n[11],
                f = n[12],
                g = n[13],
                _ = n[14],
                v = n[15];
            return t[0].setComponents(s - i, h - o, m - u, v - f).normalize(), t[1].setComponents(s + i, h + o, m + u, v + f).normalize(), t[2].setComponents(s + r, h + l, m + d, v + g).normalize(), t[3].setComponents(s - r, h - l, m - d, v - g).normalize(), t[4].setComponents(s - a, h - c, m - p, v - _).normalize(), t[5].setComponents(s + a, h + c, m + p, v + _).normalize(), this
        }
        intersectsObject(e) {
            const t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(), Ee.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Ee)
        }
        intersectsSprite(e) {
            return Ee.center.set(0, 0, 0), Ee.radius = .7071067811865476, Ee.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ee)
        }
        intersectsSphere(e) {
            const t = this.planes,
                n = e.center,
                i = -e.radius;
            for (let e = 0; e < 6; e++) {
                if (t[e].distanceToPoint(n) < i) return !1
            }
            return !0
        }
        intersectsBox(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) {
                const i = t[n];
                if (we.x = i.normal.x > 0 ? e.max.x : e.min.x, we.y = i.normal.y > 0 ? e.max.y : e.min.y, we.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(we) < 0) return !1
            }
            return !0
        }
        containsPoint(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0) return !1;
            return !0
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    class Re {
        constructor() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }
        set(e, t, n, i, r, a, s, o, l, c, h, u, d, p, m, f) {
            const g = this.elements;
            return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        clone() {
            return (new Re).fromArray(this.elements)
        }
        copy(e) {
            const t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
        }
        copyPosition(e) {
            const t = this.elements,
                n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
        }
        setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        }
        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
        }
        extractRotation(e) {
            const t = this.elements,
                n = e.elements,
                i = 1 / Le.setFromMatrixColumn(e, 0).length(),
                r = 1 / Le.setFromMatrixColumn(e, 1).length(),
                a = 1 / Le.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }
        makeRotationFromEuler(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            const t = this.elements,
                n = e.x,
                i = e.y,
                r = e.z,
                a = Math.cos(n),
                s = Math.sin(n),
                o = Math.cos(i),
                l = Math.sin(i),
                c = Math.cos(r),
                h = Math.sin(r);
            if ("XYZ" === e.order) {
                const e = a * c,
                    n = a * h,
                    i = s * c,
                    r = s * h;
                t[0] = o * c, t[4] = -o * h, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -s * o, t[2] = r - e * l, t[6] = i + n * l, t[10] = a * o
            } else if ("YXZ" === e.order) {
                const e = o * c,
                    n = o * h,
                    i = l * c,
                    r = l * h;
                t[0] = e + r * s, t[4] = i * s - n, t[8] = a * l, t[1] = a * h, t[5] = a * c, t[9] = -s, t[2] = n * s - i, t[6] = r + e * s, t[10] = a * o
            } else if ("ZXY" === e.order) {
                const e = o * c,
                    n = o * h,
                    i = l * c,
                    r = l * h;
                t[0] = e - r * s, t[4] = -a * h, t[8] = i + n * s, t[1] = n + i * s, t[5] = a * c, t[9] = r - e * s, t[2] = -a * l, t[6] = s, t[10] = a * o
            } else if ("ZYX" === e.order) {
                const e = a * c,
                    n = a * h,
                    i = s * c,
                    r = s * h;
                t[0] = o * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = o * h, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = s * o, t[10] = a * o
            } else if ("YZX" === e.order) {
                const e = a * o,
                    n = a * l,
                    i = s * o,
                    r = s * l;
                t[0] = o * c, t[4] = r - e * h, t[8] = i * h + n, t[1] = h, t[5] = a * c, t[9] = -s * c, t[2] = -l * c, t[6] = n * h + i, t[10] = e - r * h
            } else if ("XZY" === e.order) {
                const e = a * o,
                    n = a * l,
                    i = s * o,
                    r = s * l;
                t[0] = o * c, t[4] = -h, t[8] = l * c, t[1] = e * h + r, t[5] = a * c, t[9] = n * h - i, t[2] = i * h - n, t[6] = s * c, t[10] = r * h + e
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }
        makeRotationFromQuaternion(e) {
            return this.compose(Pe, e, De)
        }
        lookAt(e, t, n) {
            const i = this.elements;
            return Ue.subVectors(e, t), 0 === Ue.lengthSq() && (Ue.z = 1), Ue.normalize(), Ne.crossVectors(n, Ue), 0 === Ne.lengthSq() && (1 === Math.abs(n.z) ? Ue.x += 1e-4 : Ue.z += 1e-4, Ue.normalize(), Ne.crossVectors(n, Ue)), Ne.normalize(), Ie.crossVectors(Ue, Ne), i[0] = Ne.x, i[4] = Ie.x, i[8] = Ue.x, i[1] = Ne.y, i[5] = Ie.y, i[9] = Ue.y, i[2] = Ne.z, i[6] = Ie.z, i[10] = Ue.z, this
        }
        multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements,
                i = t.elements,
                r = this.elements,
                a = n[0],
                s = n[4],
                o = n[8],
                l = n[12],
                c = n[1],
                h = n[5],
                u = n[9],
                d = n[13],
                p = n[2],
                m = n[6],
                f = n[10],
                g = n[14],
                _ = n[3],
                v = n[7],
                x = n[11],
                y = n[15],
                M = i[0],
                S = i[4],
                T = i[8],
                b = i[12],
                E = i[1],
                w = i[5],
                A = i[9],
                R = i[13],
                L = i[2],
                C = i[6],
                P = i[10],
                D = i[14],
                N = i[3],
                I = i[7],
                U = i[11],
                F = i[15];
            return r[0] = a * M + s * E + o * L + l * N, r[4] = a * S + s * w + o * C + l * I, r[8] = a * T + s * A + o * P + l * U, r[12] = a * b + s * R + o * D + l * F, r[1] = c * M + h * E + u * L + d * N, r[5] = c * S + h * w + u * C + d * I, r[9] = c * T + h * A + u * P + d * U, r[13] = c * b + h * R + u * D + d * F, r[2] = p * M + m * E + f * L + g * N, r[6] = p * S + m * w + f * C + g * I, r[10] = p * T + m * A + f * P + g * U, r[14] = p * b + m * R + f * D + g * F, r[3] = _ * M + v * E + x * L + y * N, r[7] = _ * S + v * w + x * C + y * I, r[11] = _ * T + v * A + x * P + y * U, r[15] = _ * b + v * R + x * D + y * F, this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        }
        determinant() {
            const e = this.elements,
                t = e[0],
                n = e[4],
                i = e[8],
                r = e[12],
                a = e[1],
                s = e[5],
                o = e[9],
                l = e[13],
                c = e[2],
                h = e[6],
                u = e[10],
                d = e[14];
            return e[3] * (+r * o * h - i * l * h - r * s * u + n * l * u + i * s * d - n * o * d) + e[7] * (+t * o * d - t * l * u + r * a * u - i * a * d + i * l * c - r * o * c) + e[11] * (+t * l * h - t * s * d - r * a * h + n * a * d + r * s * c - n * l * c) + e[15] * (-i * s * c - t * o * h + t * s * u + i * a * h - n * a * u + n * o * c)
        }
        transpose() {
            const e = this.elements;
            let t;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        }
        setPosition(e, t, n) {
            const i = this.elements;
            return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
        }
        invert() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                r = e[3],
                a = e[4],
                s = e[5],
                o = e[6],
                l = e[7],
                c = e[8],
                h = e[9],
                u = e[10],
                d = e[11],
                p = e[12],
                m = e[13],
                f = e[14],
                g = e[15],
                _ = h * f * l - m * u * l + m * o * d - s * f * d - h * o * g + s * u * g,
                v = p * u * l - c * f * l - p * o * d + a * f * d + c * o * g - a * u * g,
                x = c * m * l - p * h * l + p * s * d - a * m * d - c * s * g + a * h * g,
                y = p * h * o - c * m * o - p * s * u + a * m * u + c * s * f - a * h * f,
                M = t * _ + n * v + i * x + r * y;
            if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const S = 1 / M;
            return e[0] = _ * S, e[1] = (m * u * r - h * f * r - m * i * d + n * f * d + h * i * g - n * u * g) * S, e[2] = (s * f * r - m * o * r + m * i * l - n * f * l - s * i * g + n * o * g) * S, e[3] = (h * o * r - s * u * r - h * i * l + n * u * l + s * i * d - n * o * d) * S, e[4] = v * S, e[5] = (c * f * r - p * u * r + p * i * d - t * f * d - c * i * g + t * u * g) * S, e[6] = (p * o * r - a * f * r - p * i * l + t * f * l + a * i * g - t * o * g) * S, e[7] = (a * u * r - c * o * r + c * i * l - t * u * l - a * i * d + t * o * d) * S, e[8] = x * S, e[9] = (p * h * r - c * m * r - p * n * d + t * m * d + c * n * g - t * h * g) * S, e[10] = (a * m * r - p * s * r + p * n * l - t * m * l - a * n * g + t * s * g) * S, e[11] = (c * s * r - a * h * r - c * n * l + t * h * l + a * n * d - t * s * d) * S, e[12] = y * S, e[13] = (c * m * i - p * h * i + p * n * u - t * m * u - c * n * f + t * h * f) * S, e[14] = (p * s * i - a * m * i - p * n * o + t * m * o + a * n * f - t * s * f) * S, e[15] = (a * h * i - c * s * i + c * n * o - t * h * o - a * n * u + t * s * u) * S, this
        }
        scale(e) {
            const t = this.elements,
                n = e.x,
                i = e.y,
                r = e.z;
            return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
        }
        getMaxScaleOnAxis() {
            const e = this.elements,
                t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, i))
        }
        makeTranslation(e, t, n) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
        }
        makeRotationX(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
        }
        makeRotationY(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
        }
        makeRotationZ(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        makeRotationAxis(e, t) {
            const n = Math.cos(t),
                i = Math.sin(t),
                r = 1 - n,
                a = e.x,
                s = e.y,
                o = e.z,
                l = r * a,
                c = r * s;
            return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, c * s + n, c * o - i * a, 0, l * o - i * s, c * o + i * a, r * o * o + n, 0, 0, 0, 0, 1), this
        }
        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        }
        makeShear(e, t, n, i, r, a) {
            return this.set(1, n, r, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this
        }
        compose(e, t, n) {
            const i = this.elements,
                r = t._x,
                a = t._y,
                s = t._z,
                o = t._w,
                l = r + r,
                c = a + a,
                h = s + s,
                u = r * l,
                d = r * c,
                p = r * h,
                m = a * c,
                f = a * h,
                g = s * h,
                _ = o * l,
                v = o * c,
                x = o * h,
                y = n.x,
                M = n.y,
                S = n.z;
            return i[0] = (1 - (m + g)) * y, i[1] = (d + x) * y, i[2] = (p - v) * y, i[3] = 0, i[4] = (d - x) * M, i[5] = (1 - (u + g)) * M, i[6] = (f + _) * M, i[7] = 0, i[8] = (p + v) * S, i[9] = (f - _) * S, i[10] = (1 - (u + m)) * S, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
        }
        decompose(e, t, n) {
            const i = this.elements;
            let r = Le.set(i[0], i[1], i[2]).length();
            const a = Le.set(i[4], i[5], i[6]).length(),
                s = Le.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Ce.copy(this);
            const o = 1 / r,
                l = 1 / a,
                c = 1 / s;
            return Ce.elements[0] *= o, Ce.elements[1] *= o, Ce.elements[2] *= o, Ce.elements[4] *= l, Ce.elements[5] *= l, Ce.elements[6] *= l, Ce.elements[8] *= c, Ce.elements[9] *= c, Ce.elements[10] *= c, t.setFromRotationMatrix(Ce), n.x = r, n.y = a, n.z = s, this
        }
        makePerspective(e, t, n, i, r, a) {
            void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            const s = this.elements,
                o = 2 * r / (t - e),
                l = 2 * r / (n - i),
                c = (t + e) / (t - e),
                h = (n + i) / (n - i),
                u = -(a + r) / (a - r),
                d = -2 * a * r / (a - r);
            return s[0] = o, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = l, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = u, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
        }
        makeOrthographic(e, t, n, i, r, a) {
            const s = this.elements,
                o = 1 / (t - e),
                l = 1 / (n - i),
                c = 1 / (a - r),
                h = (t + e) * o,
                u = (n + i) * l,
                d = (a + r) * c;
            return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -u, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
        }
        equals(e) {
            const t = this.elements,
                n = e.elements;
            for (let e = 0; e < 16; e++)
                if (t[e] !== n[e]) return !1;
            return !0
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
            return this
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
        }
    }
    Re.prototype.isMatrix4 = !0;
    const Le = new J,
        Ce = new Re,
        Pe = new J(0, 0, 0),
        De = new J(1, 1, 1),
        Ne = new J,
        Ie = new J,
        Ue = new J;
    class Fe {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            this.x = e, this.y = t, this.z = n, this.w = i
        }
        get width() {
            return this.z
        }
        set width(e) {
            this.z = e
        }
        get height() {
            return this.w
        }
        set height(e) {
            this.w = e
        }
        set(e, t, n, i) {
            return this.x = e, this.y = t, this.z = n, this.w = i, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setZ(e) {
            return this.z = e, this
        }
        setW(e) {
            return this.w = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        }
        add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        }
        sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        }
        applyMatrix4(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                r = this.w,
                a = e.elements;
            return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        }
        setAxisAngleFromRotationMatrix(e) {
            let t, n, i, r;
            const a = .01,
                s = .1,
                o = e.elements,
                l = o[0],
                c = o[4],
                h = o[8],
                u = o[1],
                d = o[5],
                p = o[9],
                m = o[2],
                f = o[6],
                g = o[10];
            if (Math.abs(c - u) < a && Math.abs(h - m) < a && Math.abs(p - f) < a) {
                if (Math.abs(c + u) < s && Math.abs(h + m) < s && Math.abs(p + f) < s && Math.abs(l + d + g - 3) < s) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                const e = (l + 1) / 2,
                    o = (d + 1) / 2,
                    _ = (g + 1) / 2,
                    v = (c + u) / 4,
                    x = (h + m) / 4,
                    y = (p + f) / 4;
                return e > o && e > _ ? e < a ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = v / n, r = x / n) : o > _ ? o < a ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = v / i, r = y / i) : _ < a ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(_), n = x / r, i = y / r), this.set(n, i, r, t), this
            }
            let _ = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c));
            return Math.abs(_) < .001 && (_ = 1), this.x = (f - p) / _, this.y = (h - m) / _, this.z = (u - c) / _, this.w = Math.acos((l + d + g - 1) / 2), this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        }
        fromBufferAttribute(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w
        }
    }

    function Oe() {
        let e = null,
            t = !1,
            n = null,
            i = null;

        function r(t, a) {
            n(t, a), i = e.requestAnimationFrame(r)
        }
        return {
            start: function() {
                !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0)
            },
            stop: function() {
                e.cancelAnimationFrame(i), t = !1
            },
            setAnimationLoop: function(e) {
                n = e
            },
            setContext: function(t) {
                e = t
            }
        }
    }

    function Be(e, t) {
        const n = t.isWebGL2,
            i = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data), i.get(e)
            },
            remove: function(t) {
                t.isInterleavedBufferAttribute && (t = t.data);
                const n = i.get(t);
                n && (e.deleteBuffer(n.buffer), i.delete(t))
            },
            update: function(t, r) {
                if (t.isGLBufferAttribute) {
                    const e = i.get(t);
                    return void((!e || e.version < t.version) && i.set(t, {
                        buffer: t.buffer,
                        type: t.type,
                        bytesPerElement: t.elementSize,
                        version: t.version
                    }))
                }
                t.isInterleavedBufferAttribute && (t = t.data);
                const a = i.get(t);
                void 0 === a ? i.set(t, function(t, i) {
                    const r = t.array,
                        a = t.usage,
                        s = e.createBuffer();
                    e.bindBuffer(i, s), e.bufferData(i, r, a), t.onUploadCallback();
                    let o = e.FLOAT;
                    return r instanceof Float32Array ? o = e.FLOAT : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? o = e.HALF_FLOAT : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = e.UNSIGNED_SHORT : r instanceof Int16Array ? o = e.SHORT : r instanceof Uint32Array ? o = e.UNSIGNED_INT : r instanceof Int32Array ? o = e.INT : r instanceof Int8Array ? o = e.BYTE : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (o = e.UNSIGNED_BYTE), {
                        buffer: s,
                        type: o,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(t, r)) : a.version < t.version && (! function(t, i, r) {
                    const a = i.array,
                        s = i.updateRange;
                    e.bindBuffer(r, t), -1 === s.count ? e.bufferSubData(r, 0, a) : (n ? e.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : e.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1)
                }(a.buffer, t, r), a.version = t.version)
            }
        }
    }
    Fe.prototype.isVector4 = !0;
    class ze {
        constructor(e = 0, t = 0) {
            this.x = e, this.y = t
        }
        get width() {
            return this.x
        }
        set width(e) {
            this.x = e
        }
        get height() {
            return this.y
        }
        set height(e) {
            this.y = e
        }
        set(e, t) {
            return this.x = e, this.y = t, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this
        }
        add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        }
        addScalar(e) {
            return this.x += e, this.y += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        }
        sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        applyMatrix3(e) {
            const t = this.x,
                n = this.y,
                i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y
        }
        cross(e) {
            return this.x * e.y - this.y * e.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e
        }
        fromBufferAttribute(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        }
        rotateAround(e, t) {
            const n = Math.cos(t),
                i = Math.sin(t),
                r = this.x - e.x,
                a = this.y - e.y;
            return this.x = r * n - a * i + e.x, this.y = r * i + a * n + e.y, this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y
        }
    }
    ze.prototype.isVector2 = !0;
    class Ge {
        addEventListener(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
        }
        hasEventListener(e, t) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        }
        removeEventListener(e, t) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[e];
            if (void 0 !== n) {
                const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
            }
        }
        dispatchEvent(e) {
            if (void 0 === this._listeners) return;
            const t = this._listeners[e.type];
            if (void 0 !== t) {
                e.target = this;
                const n = t.slice(0);
                for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
                e.target = null
            }
        }
    }
    const He = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        Ve = {
            h: 0,
            s: 0,
            l: 0
        },
        ke = {
            h: 0,
            s: 0,
            l: 0
        };

    function We(e, t, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
    }

    function Xe(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }

    function je(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }
    class qe {
        constructor(e, t, n) {
            return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
        }
        set(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        }
        setScalar(e) {
            return this.r = e, this.g = e, this.b = e, this
        }
        setHex(e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        }
        setRGB(e, t, n) {
            return this.r = e, this.g = t, this.b = n, this
        }
        setHSL(e, t, n) {
            var i;
            if (e = (e % (i = 1) + i) % i, t = j(t, 0, 1), n = j(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
            else {
                const i = n <= .5 ? n * (1 + t) : n + t - n * t,
                    r = 2 * n - i;
                this.r = We(r, i, e + 1 / 3), this.g = We(r, i, e), this.b = We(r, i, e - 1 / 3)
            }
            return this
        }
        setStyle(e) {
            function t(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            let n;
            if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                let e;
                const i = n[1],
                    r = n[2];
                switch (i) {
                    case "rgb":
                    case "rgba":
                        if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this;
                        if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                            const n = parseFloat(e[1]) / 360,
                                i = parseInt(e[2], 10) / 100,
                                r = parseInt(e[3], 10) / 100;
                            return t(e[4]), this.setHSL(n, i, r)
                        }
                }
            } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const e = n[1],
                    t = e.length;
                if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this;
                if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this
            }
            return e && e.length > 0 ? this.setColorName(e) : this
        }
        setColorName(e) {
            const t = He[e.toLowerCase()];
            return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b)
        }
        copy(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        }
        copySRGBToLinear(e) {
            return this.r = Xe(e.r), this.g = Xe(e.g), this.b = Xe(e.b), this
        }
        copyLinearToSRGB(e) {
            return this.r = je(e.r), this.g = je(e.g), this.b = je(e.b), this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this
        }
        getHex() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        }
        getHexString() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }
        getHSL(e) {
            const t = this.r,
                n = this.g,
                i = this.b,
                r = Math.max(t, n, i),
                a = Math.min(t, n, i);
            let s, o;
            const l = (a + r) / 2;
            if (a === r) s = 0, o = 0;
            else {
                const e = r - a;
                switch (o = l <= .5 ? e / (r + a) : e / (2 - r - a), r) {
                    case t:
                        s = (n - i) / e + (n < i ? 6 : 0);
                        break;
                    case n:
                        s = (i - t) / e + 2;
                        break;
                    case i:
                        s = (t - n) / e + 4
                }
                s /= 6
            }
            return e.h = s, e.s = o, e.l = l, e
        }
        getStyle() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }
        offsetHSL(e, t, n) {
            return this.getHSL(Ve), Ve.h += e, Ve.s += t, Ve.l += n, this.setHSL(Ve.h, Ve.s, Ve.l), this
        }
        add(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        }
        addColors(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        }
        addScalar(e) {
            return this.r += e, this.g += e, this.b += e, this
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        }
        multiply(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        }
        multiplyScalar(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
        }
        lerpHSL(e, t) {
            this.getHSL(Ve), e.getHSL(ke);
            const n = q(Ve.h, ke.h, t),
                i = q(Ve.s, ke.s, t),
                r = q(Ve.l, ke.l, t);
            return this.setHSL(n, i, r), this
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }
        fromArray(e, t = 0) {
            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
        }
        toJSON() {
            return this.getHex()
        }
    }
    qe.NAMES = He, qe.prototype.isColor = !0, qe.prototype.r = 1, qe.prototype.g = 1, qe.prototype.b = 1;
    const Ye = new J,
        Ke = new ze;
    class Ze {
        constructor(e, t, n) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = G, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            !0 === e && this.version++
        }
        setUsage(e) {
            return this.usage = e, this
        }
        copy(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
        }
        copyAt(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
            return this
        }
        copyArray(e) {
            return this.array.set(e), this
        }
        copyColorsArray(e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
                let r = e[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new qe), t[n++] = r.r, t[n++] = r.g, t[n++] = r.b
            }
            return this
        }
        copyVector2sArray(e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
                let r = e[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new ze), t[n++] = r.x, t[n++] = r.y
            }
            return this
        }
        copyVector3sArray(e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
                let r = e[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new J), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z
            }
            return this
        }
        copyVector4sArray(e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
                let r = e[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Fe), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n++] = r.w
            }
            return this
        }
        applyMatrix3(e) {
            if (2 === this.itemSize)
                for (let t = 0, n = this.count; t < n; t++) Ke.fromBufferAttribute(this, t), Ke.applyMatrix3(e), this.setXY(t, Ke.x, Ke.y);
            else if (3 === this.itemSize)
                for (let t = 0, n = this.count; t < n; t++) Ye.fromBufferAttribute(this, t), Ye.applyMatrix3(e), this.setXYZ(t, Ye.x, Ye.y, Ye.z);
            return this
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.count; t < n; t++) Ye.x = this.getX(t), Ye.y = this.getY(t), Ye.z = this.getZ(t), Ye.applyMatrix4(e), this.setXYZ(t, Ye.x, Ye.y, Ye.z);
            return this
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) Ye.x = this.getX(t), Ye.y = this.getY(t), Ye.z = this.getZ(t), Ye.applyNormalMatrix(e), this.setXYZ(t, Ye.x, Ye.y, Ye.z);
            return this
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) Ye.x = this.getX(t), Ye.y = this.getY(t), Ye.z = this.getZ(t), Ye.transformDirection(e), this.setXYZ(t, Ye.x, Ye.y, Ye.z);
            return this
        }
        set(e, t = 0) {
            return this.array.set(e, t), this
        }
        getX(e) {
            return this.array[e * this.itemSize]
        }
        setX(e, t) {
            return this.array[e * this.itemSize] = t, this
        }
        getY(e) {
            return this.array[e * this.itemSize + 1]
        }
        setY(e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        }
        getZ(e) {
            return this.array[e * this.itemSize + 2]
        }
        setZ(e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        }
        getW(e) {
            return this.array[e * this.itemSize + 3]
        }
        setW(e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        }
        setXY(e, t, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
        }
        setXYZ(e, t, n, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
        }
        setXYZW(e, t, n, i, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
        }
        onUpload(e) {
            return this.onUploadCallback = e, this
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
        toJSON() {
            const e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            };
            return "" !== this.name && (e.name = this.name), this.usage !== G && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
        }
    }
    Ze.prototype.isBufferAttribute = !0;
    class Je extends Ze {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n)
        }
    }
    class Qe extends Ze {
        constructor(e, t, n) {
            super(new Uint32Array(e), t, n)
        }
    }(class extends Ze {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n)
        }
    }).prototype.isFloat16BufferAttribute = !0;
    class $e extends Ze {
        constructor(e, t, n) {
            super(new Float32Array(e), t, n)
        }
    }
    const et = new Re,
        tt = new Z;
    class nt {
        constructor(e = 0, t = 0, n = 0, i = nt.DefaultOrder) {
            this._x = e, this._y = t, this._z = n, this._order = i
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e, this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(e) {
            this._order = e, this._onChangeCallback()
        }
        set(e, t, n, i = this._order) {
            return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        }
        copy(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
            const i = e.elements,
                r = i[0],
                a = i[4],
                s = i[8],
                o = i[1],
                l = i[5],
                c = i[9],
                h = i[2],
                u = i[6],
                d = i[10];
            switch (t) {
                case "XYZ":
                    this._y = Math.asin(j(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-j(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(j(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-j(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
                    break;
                case "YZX":
                    this._z = Math.asin(j(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(s, d));
                    break;
                case "XZY":
                    this._z = Math.asin(-j(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
            }
            return this._order = t, !0 === n && this._onChangeCallback(), this
        }
        setFromQuaternion(e, t, n) {
            return et.makeRotationFromQuaternion(e), this.setFromRotationMatrix(et, t, n)
        }
        setFromVector3(e, t = this._order) {
            return this.set(e.x, e.y, e.z, t)
        }
        reorder(e) {
            return tt.setFromEuler(this), this.setFromQuaternion(tt, e)
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        }
        fromArray(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        }
        toVector3(e) {
            return e ? e.set(this._x, this._y, this._z) : new J(this._x, this._y, this._z)
        }
        _onChange(e) {
            return this._onChangeCallback = e, this
        }
        _onChangeCallback() {}
    }
    nt.prototype.isEuler = !0, nt.DefaultOrder = "XYZ", nt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    class it {
        constructor() {
            this.mask = 1
        }
        set(e) {
            this.mask = (1 << e | 0) >>> 0
        }
        enable(e) {
            this.mask |= 1 << e | 0
        }
        enableAll() {
            this.mask = -1
        }
        toggle(e) {
            this.mask ^= 1 << e | 0
        }
        disable(e) {
            this.mask &= ~(1 << e | 0)
        }
        disableAll() {
            this.mask = 0
        }
        test(e) {
            return 0 != (this.mask & e.mask)
        }
        isEnabled(e) {
            return 0 != (this.mask & (1 << e | 0))
        }
    }
    let rt = 0;
    const at = new J,
        st = new Z,
        ot = new Re,
        lt = new J,
        ct = new J,
        ht = new J,
        ut = new Z,
        dt = new J(1, 0, 0),
        pt = new J(0, 1, 0),
        mt = new J(0, 0, 1),
        ft = {
            type: "added"
        },
        gt = {
            type: "removed"
        };
    class _t extends Ge {
        constructor() {
            super(), Object.defineProperty(this, "id", {
                value: rt++
            }), this.uuid = X(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _t.DefaultUp.clone();
            const e = new J,
                t = new nt,
                n = new Z,
                i = new J(1, 1, 1);
            t._onChange((function() {
                n.setFromEuler(t, !1)
            })), n._onChange((function() {
                t.setFromQuaternion(n, void 0, !1)
            })), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new Re
                },
                normalMatrix: {
                    value: new ye
                }
            }), this.matrix = new Re, this.matrixWorld = new Re, this.matrixAutoUpdate = _t.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new it, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(e) {
            return this.quaternion.premultiply(e), this
        }
        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        }
        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0)
        }
        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e)
        }
        setRotationFromQuaternion(e) {
            this.quaternion.copy(e)
        }
        rotateOnAxis(e, t) {
            return st.setFromAxisAngle(e, t), this.quaternion.multiply(st), this
        }
        rotateOnWorldAxis(e, t) {
            return st.setFromAxisAngle(e, t), this.quaternion.premultiply(st), this
        }
        rotateX(e) {
            return this.rotateOnAxis(dt, e)
        }
        rotateY(e) {
            return this.rotateOnAxis(pt, e)
        }
        rotateZ(e) {
            return this.rotateOnAxis(mt, e)
        }
        translateOnAxis(e, t) {
            return at.copy(e).applyQuaternion(this.quaternion), this.position.add(at.multiplyScalar(t)), this
        }
        translateX(e) {
            return this.translateOnAxis(dt, e)
        }
        translateY(e) {
            return this.translateOnAxis(pt, e)
        }
        translateZ(e) {
            return this.translateOnAxis(mt, e)
        }
        localToWorld(e) {
            return e.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(e) {
            return e.applyMatrix4(ot.copy(this.matrixWorld).invert())
        }
        lookAt(e, t, n) {
            e.isVector3 ? lt.copy(e) : lt.set(e, t, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1), ct.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ot.lookAt(ct, lt, this.up) : ot.lookAt(lt, ct, this.up), this.quaternion.setFromRotationMatrix(ot), i && (ot.extractRotation(i.matrixWorld), st.setFromRotationMatrix(ot), this.quaternion.premultiply(st.invert()))
        }
        add(e) {
            if (arguments.length > 1) {
                for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(ft)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        }
        remove(e) {
            if (arguments.length > 1) {
                for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                return this
            }
            const t = this.children.indexOf(e);
            return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(gt)), this
        }
        removeFromParent() {
            const e = this.parent;
            return null !== e && e.remove(this), this
        }
        clear() {
            for (let e = 0; e < this.children.length; e++) {
                const t = this.children[e];
                t.parent = null, t.dispatchEvent(gt)
            }
            return this.children.length = 0, this
        }
        attach(e) {
            return this.updateWorldMatrix(!0, !1), ot.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), ot.multiply(e.parent.matrixWorld)), e.applyMatrix4(ot), this.add(e), e.updateWorldMatrix(!1, !0), this
        }
        getObjectById(e) {
            return this.getObjectByProperty("id", e)
        }
        getObjectByName(e) {
            return this.getObjectByProperty("name", e)
        }
        getObjectByProperty(e, t) {
            if (this[e] === t) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                const i = this.children[n].getObjectByProperty(e, t);
                if (void 0 !== i) return i
            }
        }
        getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
        }
        getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ct, e, ht), e
        }
        getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ct, ut, e), e
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }
        raycast() {}
        traverse(e) {
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
        }
        traverseVisible(e) {
            if (!1 === this.visible) return;
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
        }
        traverseAncestors(e) {
            const t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        }
        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
        }
        updateWorldMatrix(e, t) {
            const n = this.parent;
            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                const e = this.children;
                for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
            }
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e,
                n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {}
            }, n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const i = {};

            function r(t, n) {
                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
            }
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(e.geometries, this.geometry);
                const t = this.geometry.parameters;
                if (void 0 !== t && void 0 !== t.shapes) {
                    const n = t.shapes;
                    if (Array.isArray(n))
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            r(e.shapes, i)
                        } else r(e.shapes, n)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    const t = [];
                    for (let n = 0, i = this.material.length; n < i; n++) t.push(r(e.materials, this.material[n]));
                    i.material = t
                } else i.material = r(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let t = 0; t < this.children.length; t++) i.children.push(this.children[t].toJSON(e).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let t = 0; t < this.animations.length; t++) {
                    const n = this.animations[t];
                    i.animations.push(r(e.animations, n))
                }
            }
            if (t) {
                const t = a(e.geometries),
                    i = a(e.materials),
                    r = a(e.textures),
                    s = a(e.images),
                    o = a(e.shapes),
                    l = a(e.skeletons),
                    c = a(e.animations);
                t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
            }
            return n.object = i, n;

            function a(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    delete i.metadata, t.push(i)
                }
                return t
            }
        }
        clone(e) {
            return (new this.constructor).copy(this, e)
        }
        copy(e, t = !0) {
            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (let t = 0; t < e.children.length; t++) {
                    const n = e.children[t];
                    this.add(n.clone())
                }
            return this
        }
    }

    function vt(e) {
        if (0 === e.length) return -1 / 0;
        let t = e[0];
        for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
        return t
    }

    function xt(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e)
    }
    _t.DefaultUp = new J(0, 1, 0), _t.DefaultMatrixAutoUpdate = !0, _t.prototype.isObject3D = !0;
    let yt = 0;
    const Mt = new Re,
        St = new _t,
        Tt = new J,
        bt = new ee,
        Et = new ee,
        wt = new J;
    class At extends Ge {
        constructor() {
            super(), Object.defineProperty(this, "id", {
                value: yt++
            }), this.uuid = X(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        getIndex() {
            return this.index
        }
        setIndex(e) {
            return Array.isArray(e) ? this.index = new(vt(e) > 65535 ? Qe : Je)(e, 1) : this.index = e, this
        }
        getAttribute(e) {
            return this.attributes[e]
        }
        setAttribute(e, t) {
            return this.attributes[e] = t, this
        }
        deleteAttribute(e) {
            return delete this.attributes[e], this
        }
        hasAttribute(e) {
            return void 0 !== this.attributes[e]
        }
        addGroup(e, t, n = 0) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            })
        }
        clearGroups() {
            this.groups = []
        }
        setDrawRange(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        }
        applyMatrix4(e) {
            const t = this.attributes.position;
            void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
            const n = this.attributes.normal;
            if (void 0 !== n) {
                const t = (new ye).getNormalMatrix(e);
                n.applyNormalMatrix(t), n.needsUpdate = !0
            }
            const i = this.attributes.tangent;
            return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        }
        applyQuaternion(e) {
            return Mt.makeRotationFromQuaternion(e), this.applyMatrix4(Mt), this
        }
        rotateX(e) {
            return Mt.makeRotationX(e), this.applyMatrix4(Mt), this
        }
        rotateY(e) {
            return Mt.makeRotationY(e), this.applyMatrix4(Mt), this
        }
        rotateZ(e) {
            return Mt.makeRotationZ(e), this.applyMatrix4(Mt), this
        }
        translate(e, t, n) {
            return Mt.makeTranslation(e, t, n), this.applyMatrix4(Mt), this
        }
        scale(e, t, n) {
            return Mt.makeScale(e, t, n), this.applyMatrix4(Mt), this
        }
        lookAt(e) {
            return St.lookAt(e), St.updateMatrix(), this.applyMatrix4(St.matrix), this
        }
        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Tt).negate(), this.translate(Tt.x, Tt.y, Tt.z), this
        }
        setFromPoints(e) {
            const t = [];
            for (let n = 0, i = e.length; n < i; n++) {
                const i = e[n];
                t.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute("position", new $e(t, 3)), this
        }
        computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new ee);
            const e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new J(-1 / 0, -1 / 0, -1 / 0), new J(1 / 0, 1 / 0, 1 / 0));
            if (void 0 !== e) {
                if (this.boundingBox.setFromBufferAttribute(e), t)
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        bt.setFromBufferAttribute(n), this.morphTargetsRelative ? (wt.addVectors(this.boundingBox.min, bt.min), this.boundingBox.expandByPoint(wt), wt.addVectors(this.boundingBox.max, bt.max), this.boundingBox.expandByPoint(wt)) : (this.boundingBox.expandByPoint(bt.min), this.boundingBox.expandByPoint(bt.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }
        computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new xe);
            const e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new J, 1 / 0);
            if (e) {
                const n = this.boundingSphere.center;
                if (bt.setFromBufferAttribute(e), t)
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        Et.setFromBufferAttribute(n), this.morphTargetsRelative ? (wt.addVectors(bt.min, Et.min), bt.expandByPoint(wt), wt.addVectors(bt.max, Et.max), bt.expandByPoint(wt)) : (bt.expandByPoint(Et.min), bt.expandByPoint(Et.max))
                    }
                bt.getCenter(n);
                let i = 0;
                for (let t = 0, r = e.count; t < r; t++) wt.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(wt));
                if (t)
                    for (let r = 0, a = t.length; r < a; r++) {
                        const a = t[r],
                            s = this.morphTargetsRelative;
                        for (let t = 0, r = a.count; t < r; t++) wt.fromBufferAttribute(a, t), s && (Tt.fromBufferAttribute(e, t), wt.add(Tt)), i = Math.max(i, n.distanceToSquared(wt))
                    }
                this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
        computeTangents() {
            const e = this.index,
                t = this.attributes;
            if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            const n = e.array,
                i = t.position.array,
                r = t.normal.array,
                a = t.uv.array,
                s = i.length / 3;
            void 0 === t.tangent && this.setAttribute("tangent", new Ze(new Float32Array(4 * s), 4));
            const o = t.tangent.array,
                l = [],
                c = [];
            for (let e = 0; e < s; e++) l[e] = new J, c[e] = new J;
            const h = new J,
                u = new J,
                d = new J,
                p = new ze,
                m = new ze,
                f = new ze,
                g = new J,
                _ = new J;

            function v(e, t, n) {
                h.fromArray(i, 3 * e), u.fromArray(i, 3 * t), d.fromArray(i, 3 * n), p.fromArray(a, 2 * e), m.fromArray(a, 2 * t), f.fromArray(a, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p);
                const r = 1 / (m.x * f.y - f.x * m.y);
                isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), _.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(_), c[t].add(_), c[n].add(_))
            }
            let x = this.groups;
            0 === x.length && (x = [{
                start: 0,
                count: n.length
            }]);
            for (let e = 0, t = x.length; e < t; ++e) {
                const t = x[e],
                    i = t.start;
                for (let e = i, r = i + t.count; e < r; e += 3) v(n[e + 0], n[e + 1], n[e + 2])
            }
            const y = new J,
                M = new J,
                S = new J,
                T = new J;

            function b(e) {
                S.fromArray(r, 3 * e), T.copy(S);
                const t = l[e];
                y.copy(t), y.sub(S.multiplyScalar(S.dot(t))).normalize(), M.crossVectors(T, t);
                const n = M.dot(c[e]) < 0 ? -1 : 1;
                o[4 * e] = y.x, o[4 * e + 1] = y.y, o[4 * e + 2] = y.z, o[4 * e + 3] = n
            }
            for (let e = 0, t = x.length; e < t; ++e) {
                const t = x[e],
                    i = t.start;
                for (let e = i, r = i + t.count; e < r; e += 3) b(n[e + 0]), b(n[e + 1]), b(n[e + 2])
            }
        }
        computeVertexNormals() {
            const e = this.index,
                t = this.getAttribute("position");
            if (void 0 !== t) {
                let n = this.getAttribute("normal");
                if (void 0 === n) n = new Ze(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                else
                    for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                const i = new J,
                    r = new J,
                    a = new J,
                    s = new J,
                    o = new J,
                    l = new J,
                    c = new J,
                    h = new J;
                if (e)
                    for (let u = 0, d = e.count; u < d; u += 3) {
                        const d = e.getX(u + 0),
                            p = e.getX(u + 1),
                            m = e.getX(u + 2);
                        i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), a.fromBufferAttribute(t, m), c.subVectors(a, r), h.subVectors(i, r), c.cross(h), s.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), s.add(c), o.add(c), l.add(c), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(m, l.x, l.y, l.z)
                    } else
                        for (let e = 0, s = t.count; e < s; e += 3) i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), a.fromBufferAttribute(t, e + 2), c.subVectors(a, r), h.subVectors(i, r), c.cross(h), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                this.normalizeNormals(), n.needsUpdate = !0
            }
        }
        merge(e, t) {
            if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
            void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            const n = this.attributes;
            for (const i in n) {
                if (void 0 === e.attributes[i]) continue;
                const r = n[i].array,
                    a = e.attributes[i],
                    s = a.array,
                    o = a.itemSize * t,
                    l = Math.min(s.length, r.length - o);
                for (let e = 0, t = o; e < l; e++, t++) r[t] = s[e]
            }
            return this
        }
        normalizeNormals() {
            const e = this.attributes.normal;
            for (let t = 0, n = e.count; t < n; t++) wt.fromBufferAttribute(e, t), wt.normalize(), e.setXYZ(t, wt.x, wt.y, wt.z)
        }
        toNonIndexed() {
            function e(e, t) {
                const n = e.array,
                    i = e.itemSize,
                    r = e.normalized,
                    a = new n.constructor(t.length * i);
                let s = 0,
                    o = 0;
                for (let r = 0, l = t.length; r < l; r++) {
                    s = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                    for (let e = 0; e < i; e++) a[o++] = n[s++]
                }
                return new Ze(a, i, r)
            }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
            const t = new At,
                n = this.index.array,
                i = this.attributes;
            for (const r in i) {
                const a = e(i[r], n);
                t.setAttribute(r, a)
            }
            const r = this.morphAttributes;
            for (const i in r) {
                const a = [],
                    s = r[i];
                for (let t = 0, i = s.length; t < i; t++) {
                    const i = e(s[t], n);
                    a.push(i)
                }
                t.morphAttributes[i] = a
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const a = this.groups;
            for (let e = 0, n = a.length; e < n; e++) {
                const n = a[e];
                t.addGroup(n.start, n.count, n.materialIndex)
            }
            return t
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                const t = this.parameters;
                for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            e.data = {
                attributes: {}
            };
            const t = this.index;
            null !== t && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            const n = this.attributes;
            for (const t in n) {
                const i = n[t];
                e.data.attributes[t] = i.toJSON(e.data)
            }
            const i = {};
            let r = !1;
            for (const t in this.morphAttributes) {
                const n = this.morphAttributes[t],
                    a = [];
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    a.push(i.toJSON(e.data))
                }
                a.length > 0 && (i[t] = a, r = !0)
            }
            r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
            const a = this.groups;
            a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
            const s = this.boundingSphere;
            return null !== s && (e.data.boundingSphere = {
                center: s.center.toArray(),
                radius: s.radius
            }), e
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const n = e.index;
            null !== n && this.setIndex(n.clone(t));
            const i = e.attributes;
            for (const e in i) {
                const n = i[e];
                this.setAttribute(e, n.clone(t))
            }
            const r = e.morphAttributes;
            for (const e in r) {
                const n = [],
                    i = r[e];
                for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
                this.morphAttributes[e] = n
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const a = e.groups;
            for (let e = 0, t = a.length; e < t; e++) {
                const t = a[e];
                this.addGroup(t.start, t.count, t.materialIndex)
            }
            const s = e.boundingBox;
            null !== s && (this.boundingBox = s.clone());
            const o = e.boundingSphere;
            return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    At.prototype.isBufferGeometry = !0;
    class Rt extends At {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, a = 1) {
            super(), this.type = "BoxGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: a
            };
            const s = this;
            i = Math.floor(i), r = Math.floor(r), a = Math.floor(a);
            const o = [],
                l = [],
                c = [],
                h = [];
            let u = 0,
                d = 0;

            function p(e, t, n, i, r, a, p, m, f, g, _) {
                const v = a / f,
                    x = p / g,
                    y = a / 2,
                    M = p / 2,
                    S = m / 2,
                    T = f + 1,
                    b = g + 1;
                let E = 0,
                    w = 0;
                const A = new J;
                for (let a = 0; a < b; a++) {
                    const s = a * x - M;
                    for (let o = 0; o < T; o++) {
                        const u = o * v - y;
                        A[e] = u * i, A[t] = s * r, A[n] = S, l.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(o / f), h.push(1 - a / g), E += 1
                    }
                }
                for (let e = 0; e < g; e++)
                    for (let t = 0; t < f; t++) {
                        const n = u + t + T * e,
                            i = u + t + T * (e + 1),
                            r = u + (t + 1) + T * (e + 1),
                            a = u + (t + 1) + T * e;
                        o.push(n, i, a), o.push(i, r, a), w += 6
                    }
                s.addGroup(d, w, _), d += w, u += E
            }
            p("z", "y", "x", -1, -1, n, t, e, a, r, 0), p("z", "y", "x", 1, -1, n, t, -e, a, r, 1), p("x", "z", "y", 1, 1, e, n, t, i, a, 2), p("x", "z", "y", 1, -1, e, n, -t, i, a, 3), p("x", "y", "z", 1, -1, e, t, n, i, r, 4), p("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new $e(l, 3)), this.setAttribute("normal", new $e(c, 3)), this.setAttribute("uv", new $e(h, 2))
        }
        static fromJSON(e) {
            return new Rt(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
        }
    }
    class Lt extends At {
        constructor(e = 1, t = 1, n = 1, i = 1) {
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: i
            };
            const r = e / 2,
                a = t / 2,
                s = Math.floor(n),
                o = Math.floor(i),
                l = s + 1,
                c = o + 1,
                h = e / s,
                u = t / o,
                d = [],
                p = [],
                m = [],
                f = [];
            for (let e = 0; e < c; e++) {
                const t = e * u - a;
                for (let n = 0; n < l; n++) {
                    const i = n * h - r;
                    p.push(i, -t, 0), m.push(0, 0, 1), f.push(n / s), f.push(1 - e / o)
                }
            }
            for (let e = 0; e < o; e++)
                for (let t = 0; t < s; t++) {
                    const n = t + l * e,
                        i = t + l * (e + 1),
                        r = t + 1 + l * (e + 1),
                        a = t + 1 + l * e;
                    d.push(n, i, a), d.push(i, r, a)
                }
            this.setIndex(d), this.setAttribute("position", new $e(p, 3)), this.setAttribute("normal", new $e(m, 3)), this.setAttribute("uv", new $e(f, 2))
        }
        static fromJSON(e) {
            return new Lt(e.width, e.height, e.widthSegments, e.heightSegments)
        }
    }
    let Ct = 0;
    class Pt extends Ge {
        constructor() {
            super(), Object.defineProperty(this, "id", {
                value: Ct++
            }), this.uuid = X(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.format = b, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = t, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = z, this.stencilZFail = z, this.stencilZPass = z, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
        }
        get alphaTest() {
            return this._alphaTest
        }
        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString()
        }
        setValues(e) {
            if (void 0 !== e)
                for (const t in e) {
                    const n = e[t];
                    if (void 0 === n) {
                        console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                        continue
                    }
                    if ("shading" === t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                        continue
                    }
                    const i = this[t];
                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                }
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function i(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    delete i.metadata, t.push(i)
                }
                return t
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.format !== b && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                const t = i(e.textures),
                    r = i(e.images);
                t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r)
            }
            return n
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.format = e.format, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (null !== t) {
                const e = t.length;
                n = new Array(e);
                for (let i = 0; i !== e; ++i) n[i] = t[i].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        set needsUpdate(e) {
            !0 === e && this.version++
        }
    }

    function Dt(e) {
        const t = {};
        for (const n in e) {
            t[n] = {};
            for (const i in e[n]) {
                const r = e[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
            }
        }
        return t
    }

    function Nt(e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const i = Dt(e[n]);
            for (const e in i) t[e] = i[e]
        }
        return t
    }
    Pt.prototype.isMaterial = !0;
    const It = {
        clone: Dt,
        merge: Nt
    };
    class Ut extends Pt {
        constructor(e) {
            super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "\nvoid main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n", this.fragmentShader = "\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
        }
        copy(e) {
            return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Dt(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            t.glslVersion = this.glslVersion, t.uniforms = {};
            for (const n in this.uniforms) {
                const i = this.uniforms[n].value;
                i && i.isTexture ? t.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(e).uuid
                } : i && i.isColor ? t.uniforms[n] = {
                    type: "c",
                    value: i.getHex()
                } : i && i.isVector2 ? t.uniforms[n] = {
                    type: "v2",
                    value: i.toArray()
                } : i && i.isVector3 ? t.uniforms[n] = {
                    type: "v3",
                    value: i.toArray()
                } : i && i.isVector4 ? t.uniforms[n] = {
                    type: "v4",
                    value: i.toArray()
                } : i && i.isMatrix3 ? t.uniforms[n] = {
                    type: "m3",
                    value: i.toArray()
                } : i && i.isMatrix4 ? t.uniforms[n] = {
                    type: "m4",
                    value: i.toArray()
                } : t.uniforms[n] = {
                    value: i
                }
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
            const n = {};
            for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n), t
        }
    }
    Ut.prototype.isShaderMaterial = !0;
    const Ft = new J,
        Ot = new J,
        Bt = new J,
        zt = new J,
        Gt = new J,
        Ht = new J,
        Vt = new J;
    class kt {
        constructor(e = new J, t = new J(0, 0, -1)) {
            this.origin = e, this.direction = t
        }
        set(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        }
        copy(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        }
        at(e, t) {
            return t.copy(this.direction).multiplyScalar(e).add(this.origin)
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        }
        recast(e) {
            return this.origin.copy(this.at(e, Ft)), this
        }
        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            const n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        }
        distanceSqToPoint(e) {
            const t = Ft.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (Ft.copy(this.direction).multiplyScalar(t).add(this.origin), Ft.distanceToSquared(e))
        }
        distanceSqToSegment(e, t, n, i) {
            Ot.copy(e).add(t).multiplyScalar(.5), Bt.copy(t).sub(e).normalize(), zt.copy(this.origin).sub(Ot);
            const r = .5 * e.distanceTo(t),
                a = -this.direction.dot(Bt),
                s = zt.dot(this.direction),
                o = -zt.dot(Bt),
                l = zt.lengthSq(),
                c = Math.abs(1 - a * a);
            let h, u, d, p;
            if (c > 0)
                if (h = a * o - s, u = a * s - o, p = r * c, h >= 0)
                    if (u >= -p)
                        if (u <= p) {
                            const e = 1 / c;
                            h *= e, u *= e, d = h * (h + a * u + 2 * s) + u * (a * h + u + 2 * o) + l
                        } else u = r, h = Math.max(0, -(a * u + s)), d = -h * h + u * (u + 2 * o) + l;
            else u = -r, h = Math.max(0, -(a * u + s)), d = -h * h + u * (u + 2 * o) + l;
            else u <= -p ? (h = Math.max(0, -(-a * r + s)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(a * r + s)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
            else u = a > 0 ? -r : r, h = Math.max(0, -(a * u + s)), d = -h * h + u * (u + 2 * o) + l;
            return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Bt).multiplyScalar(u).add(Ot), d
        }
        intersectSphere(e, t) {
            Ft.subVectors(e.center, this.origin);
            const n = Ft.dot(this.direction),
                i = Ft.dot(Ft) - n * n,
                r = e.radius * e.radius;
            if (i > r) return null;
            const a = Math.sqrt(r - i),
                s = n - a,
                o = n + a;
            return s < 0 && o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
        }
        intersectsSphere(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        }
        distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        }
        intersectPlane(e, t) {
            const n = this.distanceToPlane(e);
            return null === n ? null : this.at(n, t)
        }
        intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            if (0 === t) return !0;
            return e.normal.dot(this.direction) * t < 0
        }
        intersectBox(e, t) {
            let n, i, r, a, s, o;
            const l = 1 / this.direction.x,
                c = 1 / this.direction.y,
                h = 1 / this.direction.z,
                u = this.origin;
            return l >= 0 ? (n = (e.min.x - u.x) * l, i = (e.max.x - u.x) * l) : (n = (e.max.x - u.x) * l, i = (e.min.x - u.x) * l), c >= 0 ? (r = (e.min.y - u.y) * c, a = (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c, a = (e.min.y - u.y) * c), n > a || r > i ? null : ((r > n || n != n) && (n = r), (a < i || i != i) && (i = a), h >= 0 ? (s = (e.min.z - u.z) * h, o = (e.max.z - u.z) * h) : (s = (e.max.z - u.z) * h, o = (e.min.z - u.z) * h), n > o || s > i ? null : ((s > n || n != n) && (n = s), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
        }
        intersectsBox(e) {
            return null !== this.intersectBox(e, Ft)
        }
        intersectTriangle(e, t, n, i, r) {
            Gt.subVectors(t, e), Ht.subVectors(n, e), Vt.crossVectors(Gt, Ht);
            let a, s = this.direction.dot(Vt);
            if (s > 0) {
                if (i) return null;
                a = 1
            } else {
                if (!(s < 0)) return null;
                a = -1, s = -s
            }
            zt.subVectors(this.origin, e);
            const o = a * this.direction.dot(Ht.crossVectors(zt, Ht));
            if (o < 0) return null;
            const l = a * this.direction.dot(Gt.cross(zt));
            if (l < 0) return null;
            if (o + l > s) return null;
            const c = -a * zt.dot(Vt);
            return c < 0 ? null : this.at(c / s, r)
        }
        applyMatrix4(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        }
        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const Wt = new J,
        Xt = new J,
        jt = new J,
        qt = new J,
        Yt = new J,
        Kt = new J,
        Zt = new J,
        Jt = new J,
        Qt = new J,
        $t = new J;
    class en {
        constructor(e = new J, t = new J, n = new J) {
            this.a = e, this.b = t, this.c = n
        }
        static getNormal(e, t, n, i) {
            i.subVectors(n, t), Wt.subVectors(e, t), i.cross(Wt);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        }
        static getBarycoord(e, t, n, i, r) {
            Wt.subVectors(i, t), Xt.subVectors(n, t), jt.subVectors(e, t);
            const a = Wt.dot(Wt),
                s = Wt.dot(Xt),
                o = Wt.dot(jt),
                l = Xt.dot(Xt),
                c = Xt.dot(jt),
                h = a * l - s * s;
            if (0 === h) return r.set(-2, -1, -1);
            const u = 1 / h,
                d = (l * o - s * c) * u,
                p = (a * c - s * o) * u;
            return r.set(1 - d - p, p, d)
        }
        static containsPoint(e, t, n, i) {
            return this.getBarycoord(e, t, n, i, qt), qt.x >= 0 && qt.y >= 0 && qt.x + qt.y <= 1
        }
        static getUV(e, t, n, i, r, a, s, o) {
            return this.getBarycoord(e, t, n, i, qt), o.set(0, 0), o.addScaledVector(r, qt.x), o.addScaledVector(a, qt.y), o.addScaledVector(s, qt.z), o
        }
        static isFrontFacing(e, t, n, i) {
            return Wt.subVectors(n, t), Xt.subVectors(e, t), Wt.cross(Xt).dot(i) < 0
        }
        set(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
        }
        setFromPointsAndIndices(e, t, n, i) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
        }
        setFromAttributeAndIndices(e, t, n, i) {
            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        }
        getArea() {
            return Wt.subVectors(this.c, this.b), Xt.subVectors(this.a, this.b), .5 * Wt.cross(Xt).length()
        }
        getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(e) {
            return en.getNormal(this.a, this.b, this.c, e)
        }
        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(e, t) {
            return en.getBarycoord(e, this.a, this.b, this.c, t)
        }
        getUV(e, t, n, i, r) {
            return en.getUV(e, this.a, this.b, this.c, t, n, i, r)
        }
        containsPoint(e) {
            return en.containsPoint(e, this.a, this.b, this.c)
        }
        isFrontFacing(e) {
            return en.isFrontFacing(this.a, this.b, this.c, e)
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this)
        }
        closestPointToPoint(e, t) {
            const n = this.a,
                i = this.b,
                r = this.c;
            let a, s;
            Yt.subVectors(i, n), Kt.subVectors(r, n), Jt.subVectors(e, n);
            const o = Yt.dot(Jt),
                l = Kt.dot(Jt);
            if (o <= 0 && l <= 0) return t.copy(n);
            Qt.subVectors(e, i);
            const c = Yt.dot(Qt),
                h = Kt.dot(Qt);
            if (c >= 0 && h <= c) return t.copy(i);
            const u = o * h - c * l;
            if (u <= 0 && o >= 0 && c <= 0) return a = o / (o - c), t.copy(n).addScaledVector(Yt, a);
            $t.subVectors(e, r);
            const d = Yt.dot($t),
                p = Kt.dot($t);
            if (p >= 0 && d <= p) return t.copy(r);
            const m = d * l - o * p;
            if (m <= 0 && l >= 0 && p <= 0) return s = l / (l - p), t.copy(n).addScaledVector(Kt, s);
            const f = c * p - d * h;
            if (f <= 0 && h - c >= 0 && d - p >= 0) return Zt.subVectors(r, i), s = (h - c) / (h - c + (d - p)), t.copy(i).addScaledVector(Zt, s);
            const g = 1 / (f + m + u);
            return a = m * g, s = u * g, t.copy(n).addScaledVector(Yt, a).addScaledVector(Kt, s)
        }
        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }
    class tn extends Pt {
        constructor(e) {
            super(), this.type = "MeshBasicMaterial", this.color = new qe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
        }
    }
    tn.prototype.isMeshBasicMaterial = !0;
    const nn = new Re,
        rn = new kt,
        an = new xe,
        sn = new J,
        on = new J,
        ln = new J,
        cn = new J,
        hn = new J,
        un = new J,
        dn = new J,
        pn = new J,
        mn = new J,
        fn = new ze,
        gn = new ze,
        _n = new ze,
        vn = new J,
        xn = new J;
    class yn extends _t {
        constructor(e = new At, t = new tn) {
            super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
        }
        copy(e) {
            return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
        }
        updateMorphTargets() {
            const e = this.geometry;
            if (e.isBufferGeometry) {
                const t = e.morphAttributes,
                    n = Object.keys(t);
                if (n.length > 0) {
                    const e = t[n[0]];
                    if (void 0 !== e) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    }
                }
            } else {
                const t = e.morphTargets;
                void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.material,
                r = this.matrixWorld;
            if (void 0 === i) return;
            if (null === n.boundingSphere && n.computeBoundingSphere(), an.copy(n.boundingSphere), an.applyMatrix4(r), !1 === e.ray.intersectsSphere(an)) return;
            if (nn.copy(r).invert(), rn.copy(e.ray).applyMatrix4(nn), null !== n.boundingBox && !1 === rn.intersectsBox(n.boundingBox)) return;
            let a;
            if (n.isBufferGeometry) {
                const r = n.index,
                    s = n.attributes.position,
                    o = n.morphAttributes.position,
                    l = n.morphTargetsRelative,
                    c = n.attributes.uv,
                    h = n.attributes.uv2,
                    u = n.groups,
                    d = n.drawRange;
                if (null !== r)
                    if (Array.isArray(i))
                        for (let n = 0, p = u.length; n < p; n++) {
                            const p = u[n],
                                m = i[p.materialIndex];
                            for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                                const i = r.getX(n),
                                    u = r.getX(n + 1),
                                    d = r.getX(n + 2);
                                a = Mn(this, m, e, rn, s, o, l, c, h, i, u, d), a && (a.faceIndex = Math.floor(n / 3), a.face.materialIndex = p.materialIndex, t.push(a))
                            }
                        } else {
                            for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                const u = r.getX(n),
                                    d = r.getX(n + 1),
                                    p = r.getX(n + 2);
                                a = Mn(this, i, e, rn, s, o, l, c, h, u, d, p), a && (a.faceIndex = Math.floor(n / 3), t.push(a))
                            }
                        } else if (void 0 !== s)
                            if (Array.isArray(i))
                                for (let n = 0, r = u.length; n < r; n++) {
                                    const r = u[n],
                                        p = i[r.materialIndex];
                                    for (let n = Math.max(r.start, d.start), i = Math.min(s.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) {
                                        a = Mn(this, p, e, rn, s, o, l, c, h, n, n + 1, n + 2), a && (a.faceIndex = Math.floor(n / 3), a.face.materialIndex = r.materialIndex, t.push(a))
                                    }
                                } else {
                                    for (let n = Math.max(0, d.start), r = Math.min(s.count, d.start + d.count); n < r; n += 3) {
                                        a = Mn(this, i, e, rn, s, o, l, c, h, n, n + 1, n + 2), a && (a.faceIndex = Math.floor(n / 3), t.push(a))
                                    }
                                }
            } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }

    function Mn(e, t, n, i, r, a, s, o, l, c, h, u) {
        sn.fromBufferAttribute(r, c), on.fromBufferAttribute(r, h), ln.fromBufferAttribute(r, u);
        const d = e.morphTargetInfluences;
        if (a && d) {
            dn.set(0, 0, 0), pn.set(0, 0, 0), mn.set(0, 0, 0);
            for (let e = 0, t = a.length; e < t; e++) {
                const t = d[e],
                    n = a[e];
                0 !== t && (cn.fromBufferAttribute(n, c), hn.fromBufferAttribute(n, h), un.fromBufferAttribute(n, u), s ? (dn.addScaledVector(cn, t), pn.addScaledVector(hn, t), mn.addScaledVector(un, t)) : (dn.addScaledVector(cn.sub(sn), t), pn.addScaledVector(hn.sub(on), t), mn.addScaledVector(un.sub(ln), t)))
            }
            sn.add(dn), on.add(pn), ln.add(mn)
        }
        e.isSkinnedMesh && (e.boneTransform(c, sn), e.boneTransform(h, on), e.boneTransform(u, ln));
        const p = function(e, t, n, i, r, a, s, o) {
            let l;
            if (l = 1 === t.side ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, 2 !== t.side, o), null === l) return null;
            xn.copy(o), xn.applyMatrix4(e.matrixWorld);
            const c = n.ray.origin.distanceTo(xn);
            return c < n.near || c > n.far ? null : {
                distance: c,
                point: xn.clone(),
                object: e
            }
        }(e, t, n, i, sn, on, ln, vn);
        if (p) {
            o && (fn.fromBufferAttribute(o, c), gn.fromBufferAttribute(o, h), _n.fromBufferAttribute(o, u), p.uv = en.getUV(vn, sn, on, ln, fn, gn, _n, new ze)), l && (fn.fromBufferAttribute(l, c), gn.fromBufferAttribute(l, h), _n.fromBufferAttribute(l, u), p.uv2 = en.getUV(vn, sn, on, ln, fn, gn, _n, new ze));
            const e = {
                a: c,
                b: h,
                c: u,
                normal: new J,
                materialIndex: 0
            };
            en.getNormal(sn, on, ln, e.normal), p.face = e
        }
        return p
    }
    yn.prototype.isMesh = !0;
    const Sn = {
            alphamap_fragment: "\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n",
            alphamap_pars_fragment: "\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
            alphatest_fragment: "\n#ifdef USE_ALPHATEST\n\n\tif ( diffuseColor.a < alphaTest ) discard;\n\n#endif\n",
            alphatest_pars_fragment: "\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n",
            aomap_fragment: "\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\n\t#endif\n\n#endif\n",
            aomap_pars_fragment: "\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n",
            bsdfs: '\n\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\n\t// Original approximation by Christophe Schlick \'94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH \'13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4\'s roughness\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( V * D );\n\n}\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nfloat D_Charlie( float roughness, float dotNH ) {\n\n\tfloat alpha = pow2( roughness );\n\n\t// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\n\t// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n\n}\n\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\n\treturn sheenColor * ( D * V );\n\n}\n\n#endif\n',
            bumpmap_pars_fragment: "\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n",
            clipping_planes_fragment: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n",
            clipping_planes_pars_fragment: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n",
            clipping_planes_pars_vertex: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n#endif\n",
            clipping_planes_vertex: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvClipPosition = - mvPosition.xyz;\n\n#endif\n",
            color_fragment: "\n#if defined( USE_COLOR_ALPHA )\n\n\tdiffuseColor *= vColor;\n\n#elif defined( USE_COLOR )\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n",
            color_pars_fragment: "\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n",
            color_pars_vertex: "\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n",
            color_vertex: "\n#if defined( USE_COLOR_ALPHA )\n\n\tvColor = vec4( 1.0 );\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvColor = vec3( 1.0 );\n\n#endif\n\n#ifdef USE_COLOR\n\n\tvColor *= color;\n\n#endif\n\n#ifdef USE_INSTANCING_COLOR\n\n\tvColor.xyz *= instanceColor.xyz;\n\n#endif\n",
            common: "\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ) * c );\n\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n\treturn m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n\t// dir is assumed to be unit length\n\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\treturn vec2( u, v );\n\n}\n",
            cube_uv_reflection_fragment: "\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection = abs( direction );\n\n\t\tfloat face = - 1.0;\n\n\t\tif ( absDirection.x > absDirection.z ) {\n\n\t\t\tif ( absDirection.x > absDirection.y )\n\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z > absDirection.y )\n\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face == 0.0 ) {\n\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face == 1.0 ) {\n\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face == 2.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face == 3.0 ) {\n\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face == 4.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face = getFace( direction );\n\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize = exp2( mipInt );\n\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\n\t\tif ( face > 2.0 ) {\n\n\t\t\tuv.y += faceSize;\n\n\t\t\tface -= 3.0;\n\n\t\t}\n\n\t\tuv.x += face * faceSize;\n\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\n\t\t}\n\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\n\t\tuv *= texelSize;\n\n\t\treturn texture2D( envMap, uv ).rgb;\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip = 0.0;\n\n\t\tif ( roughness >= r1 ) {\n\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\n\t\t} else if ( roughness >= r4 ) {\n\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\n\t\t} else if ( roughness >= r5 ) {\n\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\n\t\t} else if ( roughness >= r6 ) {\n\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\n\t\t} else {\n\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\n\t\tfloat mipF = fract( mip );\n\n\t\tfloat mipInt = floor( mip );\n\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF == 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n\n#endif\n",
            defaultnormal_vertex: "\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n\t// this is in lieu of a per-instance normal-matrix\n\t// shear transforms in the instance matrix are not supported\n\n\tmat3 m = mat3( instanceMatrix );\n\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n\ttransformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n",
            displacementmap_pars_vertex: "\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n",
            displacementmap_vertex: "\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n",
            emissivemap_fragment: "\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n",
            emissivemap_pars_fragment: "\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n",
            encodings_fragment: "\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\n",
            envmap_fragment: "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvec3 cameraToFrag;\n\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\n\t\t}\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t\tenvColor = envMapTexelToLinear( envColor );\n\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n",
            envmap_common_pars_fragment: "\n#ifdef USE_ENVMAP\n\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n",
            envmap_pars_fragment: "\n#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n",
            envmap_pars_vertex: "\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n",
            envmap_physical_pars_fragment: "\n#if defined( USE_ENVMAP )\n\n\t#ifdef ENVMAP_MODE_REFRACTION\n\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 reflectVec;\n\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\n\t\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n\t\t\t#else\n\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\n\t\t\t#endif\n\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n#endif\n",
            envmap_vertex: "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex;\n\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\t}\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n",
            fog_vertex: "\n#ifdef USE_FOG\n\n\tvFogDepth = - mvPosition.z;\n\n#endif\n",
            fog_pars_vertex: "\n#ifdef USE_FOG\n\n\tvarying float vFogDepth;\n\n#endif\n",
            fog_fragment: "\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n",
            fog_pars_fragment: "\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n",
            gradientmap_pars_fragment: "\n\n#ifdef USE_GRADIENTMAP\n\n\tuniform sampler2D gradientMap;\n\n#endif\n\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t// dotNL will be from -1.0 to 1.0\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t#ifdef USE_GRADIENTMAP\n\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\n\t#else\n\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t#endif\n\n}\n",
            lightmap_fragment: "\n#ifdef USE_LIGHTMAP\n\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tlightMapIrradiance *= PI;\n\n\t#endif\n\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n\n#endif\n",
            lightmap_pars_fragment: "\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n",
            lights_lambert_vertex: "\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n#ifdef DOUBLE_SIDED\n\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n",
            lights_pars_begin: "\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\treturn irradiance;\n\n}\n\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t#else\n\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t\t}\n\n\t\treturn 1.0;\n\n\t#endif\n\n}\n\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\tif ( spotAttenuation > 0.0 ) {\n\n\t\t\tfloat lightDistance = length( lVector );\n\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t\t} else {\n\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n",
            lights_toon_fragment: "\nToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\n",
            lights_toon_pars_fragment: "\nvarying vec3 vViewPosition;\n\nstruct ToonMaterial {\n\n\tvec3 diffuseColor;\n\n};\n\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_phong_fragment: "\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "\nvarying vec3 vViewPosition;\n\nstruct BlinnPhongMaterial {\n\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_physical_fragment: "\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n\n#ifdef IOR\n\n\t#ifdef SPECULAR\n\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\n\t\t#endif\n\n\t\t#ifdef USE_SPECULARCOLORMAP\n\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\n\t\t#endif\n\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\n\t#else\n\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\n\t#endif\n\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n\n#else\n\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\n\t#ifdef USE_CLEARCOATMAP\n\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n\t#endif\n\n\tmaterial.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_SHEEN\n\n\tmaterial.sheenColor = sheenColor;\n\n\t#ifdef USE_SHEENCOLORMAP\n\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\n\t#endif\n\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\n\t#ifdef USE_SHEENROUGHNESSMAP\n\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\n\t#endif\n\n#endif\n",
            lights_physical_pars_fragment: '\nstruct PhysicalMaterial {\n\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\n};\n\n// temporary\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\n\n// This is a curve-fit approxmation to the "Charlie sheen" BRDF integrated over the hemisphere from \n// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tfloat r2 = roughness * roughness;\n\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\n\treturn saturate( DG * RECIPROCAL_PI );\n\n}\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via \'environmentBRDF\' from "Physically Based Shading on Mobile"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\n\treturn fab;\n\n}\n\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\treturn specularColor * fab.x + specularF90 * fab.y;\n\n}\n\n// Fdez-Agera\'s "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\n\t#endif\n\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\n\t#endif\n\n\t// Both indirect specular and indirect diffuse light accumulate here\n\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n',
            lights_fragment_begin: "\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",
            lights_fragment_maps: "\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI;\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\n\t#endif\n\n#endif\n",
            lights_fragment_end: "\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n",
            logdepthbuf_fragment: "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\t// Doing a strict comparison with == 1.0 can cause noise artifacts\n\t// on some platforms. See issue #17623.\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n",
            logdepthbuf_pars_fragment: "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n\n#endif\n",
            logdepthbuf_pars_vertex: "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n",
            logdepthbuf_vertex: "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n\t#else\n\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\t\tgl_Position.z *= gl_Position.w;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
            map_fragment: "\n#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\n#endif\n",
            map_pars_fragment: "\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n",
            map_particle_fragment: "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n#endif\n\n#ifdef USE_MAP\n\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n#endif\n",
            map_particle_pars_fragment: "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tuniform mat3 uvTransform;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
            metalnessmap_fragment: "\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n",
            metalnessmap_pars_fragment: "\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n",
            morphnormal_vertex: "\n#ifdef USE_MORPHNORMALS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tobjectNormal *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\n\t\t}\n\n\t#else\n\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n\t#endif\n\n#endif\n",
            morphtarget_pars_vertex: "\n#ifdef USE_MORPHTARGETS\n\n\tuniform float morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\n\t\t}\n\n\t#else\n\n\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\n\t\t#else\n\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n",
            morphtarget_vertex: "\n#ifdef USE_MORPHTARGETS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\ttransformed *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\n\t\t\t#else\n\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\n\t\t\t#endif\n\n\t\t}\n\n\t#else\n\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n",
            normal_fragment_begin: "\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n\n#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno GPUs not able to do dFdx( vViewPosition )\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * faceDirection;\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\n\t\t#endif\n\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n",
            normal_fragment_maps: "\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t#ifdef FLIP_SIDED\n\n\t\tnormal = - normal;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * faceDirection;\n\n\t#endif\n\n\tnormal = normalize( normalMatrix * normal );\n\n#elif defined( TANGENTSPACE_NORMALMAP )\n\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tnormal = normalize( vTBN * mapN );\n\n\t#else\n\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n\n#endif\n",
            normal_pars_fragment: "\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n",
            normal_pars_vertex: "\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n",
            normal_vertex: "\n#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n",
            normalmap_pars_fragment: "\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tuniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n\t// Normal Mapping Without Precomputed Tangents\n\t// http://www.thetenthplanet.de/archives/1180\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 N = surf_norm; // normalized\n\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n\t}\n\n#endif\n",
            clearcoat_normal_fragment_begin: "\n#ifdef USE_CLEARCOAT\n\n\tvec3 clearcoatNormal = geometryNormal;\n\n#endif\n",
            clearcoat_normal_fragment_maps: "\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n\t#else\n\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\n\t#endif\n\n#endif\n",
            clearcoat_pars_fragment: "\n\n#ifdef USE_CLEARCOATMAP\n\n\tuniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n\n#endif\n",
            output_fragment: "\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n\n// https://github.com/mrdoob/three.js/pull/22425\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\n\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",
            packing: "\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\n\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n",
            project_vertex: "\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n\tmvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition;\n",
            dithering_fragment: "\n#ifdef DITHERING\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n",
            dithering_pars_fragment: "\n#ifdef DITHERING\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n",
            roughnessmap_fragment: "\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n",
            roughnessmap_pars_fragment: "\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n",
            shadowmap_pars_fragment: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n",
            shadowmap_pars_vertex: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n",
            shadowmap_vertex: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\t// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\n\t#endif\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n",
            shadowmask_pars_fragment: "\nfloat getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\tDirectionalLightShadow directionalLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\tSpotLightShadow spotLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\tPointLightShadow pointLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update shadow for Area light\n\n\t#endif\n\t*/\n\n\t#endif\n\n\treturn shadow;\n\n}\n",
            skinbase_vertex: "\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n",
            skinning_pars_vertex: "\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
            skinning_vertex: "\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n",
            skinnormal_vertex: "\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n",
            specularmap_fragment: "\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n",
            specularmap_pars_fragment: "\n#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif\n",
            tonemapping_fragment: "\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n",
            tonemapping_pars_fragment: "\n#ifndef saturate\n// <common> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\nvec3 RRTAndODTFit( vec3 v ) {\n\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n\n}\n\n// this implementation of ACES is modified to accommodate a brighter viewing environment.\n// the scale factor of 1/0.6 is subjective. see discussion in #19621.\n\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\n\tcolor *= toneMappingExposure / 0.6;\n\n\tcolor = ACESInputMat * color;\n\n\t// Apply RRT and ODT\n\tcolor = RRTAndODTFit( color );\n\n\tcolor = ACESOutputMat * color;\n\n\t// Clamp to [0, 1]\n\treturn saturate( color );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return color; }\n",
            transmission_fragment: "\n#ifdef USE_TRANSMISSION\n\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\n\t#endif\n\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif\n",
            transmission_pars_fragment: "\n#ifdef USE_TRANSMISSION\n\n\t// Transmission code is based on glTF-Sampler-Viewer\n\t// https://github.com/KhronosGroup/glTF-Sample-Viewer\n\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tuniform sampler2D transmissionMap;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tuniform sampler2D thicknessMap;\n\n\t#endif\n\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\n\tvarying vec3 vWorldPosition;\n\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\n\t\t// Direction of refracted light.\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\n\t\t// Compute rotation-independant scaling of the model matrix.\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t// The thickness is specified in local space.\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\n\t}\n\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\n\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\n\t}\n\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\n\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#else\n\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#endif\n\n\t}\n\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\n\t\tif ( attenuationDistance == 0.0 ) {\n\n\t\t\t// Attenuation distance is + (which we indicate by zero), i.e. the transmitted color is not attenuated at all.\n\t\t\treturn radiance;\n\n\t\t} else {\n\n\t\t\t// Compute light attenuation using Beer's law.\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n\t\t\treturn transmittance * radiance;\n\n\t\t}\n\n\t}\n\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\n\t\t// Get the specular component.\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\n\t}\n#endif\n",
            uv_pars_fragment: "\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n\tvarying vec2 vUv;\n\n#endif\n",
            uv_pars_vertex: "\n#ifdef USE_UV\n\n\t#ifdef UVS_VERTEX_ONLY\n\n\t\tvec2 vUv;\n\n\t#else\n\n\t\tvarying vec2 vUv;\n\n\t#endif\n\n\tuniform mat3 uvTransform;\n\n#endif\n",
            uv_vertex: "\n#ifdef USE_UV\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n",
            uv2_pars_fragment: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n",
            uv2_pars_vertex: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n\tuniform mat3 uv2Transform;\n\n#endif\n",
            uv2_vertex: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n",
            worldpos_vertex: "\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\n#endif\n",
            background_vert: "\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n",
            background_frag: "\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec4 texColor = texture2D( t2D, vUv );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
            cube_vert: "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n",
            cube_frag: "\n#include <envmap_common_pars_fragment>\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
            depth_vert: "\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvHighPrecisionZW = gl_Position.zw;\n\n}\n",
            depth_frag: "\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n",
            distanceRGBA_vert: "\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n",
            distanceRGBA_frag: "\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n",
            equirect_vert: "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n",
            equirect_frag: "\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldDirection );\n\n\tvec2 sampleUV = equirectUv( direction );\n\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
            linedashed_vert: "\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n",
            linedashed_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
            meshbasic_vert: "\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshbasic_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshlambert_vert: "\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshlambert_frag: "\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshmatcap_vert: "\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n}\n",
            meshmatcap_frag: "\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t#ifdef USE_MATCAP\n\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\n\t#else\n\n\t\tvec4 matcapColor = vec4( 1.0 );\n\n\t#endif\n\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshnormal_vert: "\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n",
            meshnormal_frag: "\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n",
            meshphong_vert: "\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshphong_frag: "\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshphysical_vert: "\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifdef USE_TRANSMISSION\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n#ifdef USE_TRANSMISSION\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif\n}\n",
            meshphysical_frag: "\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\n\tuniform float ior;\n#endif\n\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n\t#include <transmission_fragment>\n\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n\t#ifdef USE_SHEEN\n\n\t\t// Sheen energy compensation approximation calculation can be found at the end of\n\t\t// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\n\t#endif\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshtoon_vert: "\n#define TOON\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshtoon_frag: "\n#define TOON\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            points_vert: "\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n",
            points_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
            shadow_vert: "\n#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            shadow_frag: "\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n",
            sprite_vert: "\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n",
            sprite_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n"
        },
        Tn = {
            common: {
                diffuse: {
                    value: new qe(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new ye
                },
                uv2Transform: {
                    value: new ye
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new ze(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new qe(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new qe(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new ye
                }
            },
            sprite: {
                diffuse: {
                    value: new qe(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new ze(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new ye
                }
            }
        },
        bn = {
            basic: {
                uniforms: Nt([Tn.common, Tn.specularmap, Tn.envmap, Tn.aomap, Tn.lightmap, Tn.fog]),
                vertexShader: Sn.meshbasic_vert,
                fragmentShader: Sn.meshbasic_frag
            },
            lambert: {
                uniforms: Nt([Tn.common, Tn.specularmap, Tn.envmap, Tn.aomap, Tn.lightmap, Tn.emissivemap, Tn.fog, Tn.lights, {
                    emissive: {
                        value: new qe(0)
                    }
                }]),
                vertexShader: Sn.meshlambert_vert,
                fragmentShader: Sn.meshlambert_frag
            },
            phong: {
                uniforms: Nt([Tn.common, Tn.specularmap, Tn.envmap, Tn.aomap, Tn.lightmap, Tn.emissivemap, Tn.bumpmap, Tn.normalmap, Tn.displacementmap, Tn.fog, Tn.lights, {
                    emissive: {
                        value: new qe(0)
                    },
                    specular: {
                        value: new qe(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Sn.meshphong_vert,
                fragmentShader: Sn.meshphong_frag
            },
            standard: {
                uniforms: Nt([Tn.common, Tn.envmap, Tn.aomap, Tn.lightmap, Tn.emissivemap, Tn.bumpmap, Tn.normalmap, Tn.displacementmap, Tn.roughnessmap, Tn.metalnessmap, Tn.fog, Tn.lights, {
                    emissive: {
                        value: new qe(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Sn.meshphysical_vert,
                fragmentShader: Sn.meshphysical_frag
            },
            toon: {
                uniforms: Nt([Tn.common, Tn.aomap, Tn.lightmap, Tn.emissivemap, Tn.bumpmap, Tn.normalmap, Tn.displacementmap, Tn.gradientmap, Tn.fog, Tn.lights, {
                    emissive: {
                        value: new qe(0)
                    }
                }]),
                vertexShader: Sn.meshtoon_vert,
                fragmentShader: Sn.meshtoon_frag
            },
            matcap: {
                uniforms: Nt([Tn.common, Tn.bumpmap, Tn.normalmap, Tn.displacementmap, Tn.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: Sn.meshmatcap_vert,
                fragmentShader: Sn.meshmatcap_frag
            },
            points: {
                uniforms: Nt([Tn.points, Tn.fog]),
                vertexShader: Sn.points_vert,
                fragmentShader: Sn.points_frag
            },
            dashed: {
                uniforms: Nt([Tn.common, Tn.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Sn.linedashed_vert,
                fragmentShader: Sn.linedashed_frag
            },
            depth: {
                uniforms: Nt([Tn.common, Tn.displacementmap]),
                vertexShader: Sn.depth_vert,
                fragmentShader: Sn.depth_frag
            },
            normal: {
                uniforms: Nt([Tn.common, Tn.bumpmap, Tn.normalmap, Tn.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Sn.meshnormal_vert,
                fragmentShader: Sn.meshnormal_frag
            },
            sprite: {
                uniforms: Nt([Tn.sprite, Tn.fog]),
                vertexShader: Sn.sprite_vert,
                fragmentShader: Sn.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new ye
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: Sn.background_vert,
                fragmentShader: Sn.background_frag
            },
            cube: {
                uniforms: Nt([Tn.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Sn.cube_vert,
                fragmentShader: Sn.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: Sn.equirect_vert,
                fragmentShader: Sn.equirect_frag
            },
            distanceRGBA: {
                uniforms: Nt([Tn.common, Tn.displacementmap, {
                    referencePosition: {
                        value: new J
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: Sn.distanceRGBA_vert,
                fragmentShader: Sn.distanceRGBA_frag
            },
            shadow: {
                uniforms: Nt([Tn.lights, Tn.fog, {
                    color: {
                        value: new qe(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Sn.shadow_vert,
                fragmentShader: Sn.shadow_frag
            }
        };

    function En(e, t, n, i, r) {
        const a = new qe(0);
        let o, l, c = 0,
            h = null,
            u = 0,
            d = null;

        function p(e, t) {
            n.buffers.color.setClear(e.r, e.g, e.b, t, r)
        }
        return {
            getClearColor: function() {
                return a
            },
            setClearColor: function(e, t = 1) {
                a.set(e), c = t, p(a, c)
            },
            getClearAlpha: function() {
                return c
            },
            setClearAlpha: function(e) {
                c = e, p(a, c)
            },
            render: function(n, r) {
                let m = !1,
                    f = !0 === r.isScene ? r.background : null;
                f && f.isTexture && (f = t.get(f)), null === f ? p(a, c) : f && f.isColor && (p(f, 1), m = !0), (e.autoClear || m) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), f && (f.isCubeTexture || f.mapping === s) ? (void 0 === l && (l = new yn(new Rt(1, 1, 1), new Ut({
                    name: "BackgroundCubeMaterial",
                    uniforms: Dt(bn.cube.uniforms),
                    vertexShader: bn.cube.vertexShader,
                    fragmentShader: bn.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(e, t, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld)
                }, Object.defineProperty(l.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }), i.update(l)), l.material.uniforms.envMap.value = f, l.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, h === f && u === f.version && d === e.toneMapping || (l.material.needsUpdate = !0, h = f, u = f.version, d = e.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new yn(new Lt(2, 2), new Ut({
                    name: "BackgroundMaterial",
                    uniforms: Dt(bn.background.uniforms),
                    vertexShader: bn.background.vertexShader,
                    fragmentShader: bn.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }), i.update(o)), o.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), o.material.uniforms.uvTransform.value.copy(f.matrix), h === f && u === f.version && d === e.toneMapping || (o.material.needsUpdate = !0, h = f, u = f.version, d = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
            }
        }
    }

    function wn(e, t, n, i) {
        const r = e.getParameter(e.MAX_VERTEX_ATTRIBS),
            a = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
            s = i.isWebGL2 || null !== a,
            o = {},
            l = d(null);
        let c = l;

        function h(t) {
            return i.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
        }

        function u(t) {
            return i.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
        }

        function d(e) {
            const t = [],
                n = [],
                i = [];
            for (let e = 0; e < r; e++) t[e] = 0, n[e] = 0, i[e] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: t,
                enabledAttributes: n,
                attributeDivisors: i,
                object: e,
                attributes: {},
                index: null
            }
        }

        function p() {
            const e = c.newAttributes;
            for (let t = 0, n = e.length; t < n; t++) e[t] = 0
        }

        function m(e) {
            f(e, 0)
        }

        function f(n, r) {
            const a = c.newAttributes,
                s = c.enabledAttributes,
                o = c.attributeDivisors;
            if (a[n] = 1, 0 === s[n] && (e.enableVertexAttribArray(n), s[n] = 1), o[n] !== r) {
                (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r
            }
        }

        function g() {
            const t = c.newAttributes,
                n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++) n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0)
        }

        function _(t, n, r, a, s, o) {
            !0 !== i.isWebGL2 || r !== e.INT && r !== e.UNSIGNED_INT ? e.vertexAttribPointer(t, n, r, a, s, o) : e.vertexAttribIPointer(t, n, r, s, o)
        }

        function v() {
            x(), c !== l && (c = l, h(c.object))
        }

        function x() {
            l.geometry = null, l.program = null, l.wireframe = !1
        }
        return {
            setup: function(r, l, u, v, x) {
                let y = !1;
                if (s) {
                    const t = function(t, n, r) {
                        const s = !0 === r.wireframe;
                        let l = o[t.id];
                        void 0 === l && (l = {}, o[t.id] = l);
                        let c = l[n.id];
                        void 0 === c && (c = {}, l[n.id] = c);
                        let h = c[s];
                        void 0 === h && (h = d(i.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()), c[s] = h);
                        return h
                    }(v, u, l);
                    c !== t && (c = t, h(c.object)), y = function(e, t) {
                        const n = c.attributes,
                            i = e.attributes;
                        let r = 0;
                        for (const e in i) {
                            const t = n[e],
                                a = i[e];
                            if (void 0 === t) return !0;
                            if (t.attribute !== a) return !0;
                            if (t.data !== a.data) return !0;
                            r++
                        }
                        return c.attributesNum !== r || c.index !== t
                    }(v, x), y && function(e, t) {
                        const n = {},
                            i = e.attributes;
                        let r = 0;
                        for (const e in i) {
                            const t = i[e],
                                a = {};
                            a.attribute = t, t.data && (a.data = t.data), n[e] = a, r++
                        }
                        c.attributes = n, c.attributesNum = r, c.index = t
                    }(v, x)
                } else {
                    const e = !0 === l.wireframe;
                    c.geometry === v.id && c.program === u.id && c.wireframe === e || (c.geometry = v.id, c.program = u.id, c.wireframe = e, y = !0)
                }!0 === r.isInstancedMesh && (y = !0), null !== x && n.update(x, e.ELEMENT_ARRAY_BUFFER), y && (! function(r, a, s, o) {
                    if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                    p();
                    const l = o.attributes,
                        c = s.getAttributes(),
                        h = a.defaultAttributeValues;
                    for (const t in c) {
                        const i = c[t];
                        if (i.location >= 0) {
                            let a = l[t];
                            if (void 0 === a && ("instanceMatrix" === t && r.instanceMatrix && (a = r.instanceMatrix), "instanceColor" === t && r.instanceColor && (a = r.instanceColor)), void 0 !== a) {
                                const t = a.normalized,
                                    s = a.itemSize,
                                    l = n.get(a);
                                if (void 0 === l) continue;
                                const c = l.buffer,
                                    h = l.type,
                                    u = l.bytesPerElement;
                                if (a.isInterleavedBufferAttribute) {
                                    const n = a.data,
                                        l = n.stride,
                                        d = a.offset;
                                    if (n && n.isInstancedInterleavedBuffer) {
                                        for (let e = 0; e < i.locationSize; e++) f(i.location + e, n.meshPerAttribute);
                                        !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                    } else
                                        for (let e = 0; e < i.locationSize; e++) m(i.location + e);
                                    e.bindBuffer(e.ARRAY_BUFFER, c);
                                    for (let e = 0; e < i.locationSize; e++) _(i.location + e, s / i.locationSize, h, t, l * u, (d + s / i.locationSize * e) * u)
                                } else {
                                    if (a.isInstancedBufferAttribute) {
                                        for (let e = 0; e < i.locationSize; e++) f(i.location + e, a.meshPerAttribute);
                                        !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = a.meshPerAttribute * a.count)
                                    } else
                                        for (let e = 0; e < i.locationSize; e++) m(i.location + e);
                                    e.bindBuffer(e.ARRAY_BUFFER, c);
                                    for (let e = 0; e < i.locationSize; e++) _(i.location + e, s / i.locationSize, h, t, s * u, s / i.locationSize * e * u)
                                }
                            } else if (void 0 !== h) {
                                const n = h[t];
                                if (void 0 !== n) switch (n.length) {
                                    case 2:
                                        e.vertexAttrib2fv(i.location, n);
                                        break;
                                    case 3:
                                        e.vertexAttrib3fv(i.location, n);
                                        break;
                                    case 4:
                                        e.vertexAttrib4fv(i.location, n);
                                        break;
                                    default:
                                        e.vertexAttrib1fv(i.location, n)
                                }
                            }
                        }
                    }
                    g()
                }(r, l, u, v), null !== x && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(x).buffer))
            },
            reset: v,
            resetDefaultState: x,
            dispose: function() {
                v();
                for (const e in o) {
                    const t = o[e];
                    for (const e in t) {
                        const n = t[e];
                        for (const e in n) u(n[e].object), delete n[e];
                        delete t[e]
                    }
                    delete o[e]
                }
            },
            releaseStatesOfGeometry: function(e) {
                if (void 0 === o[e.id]) return;
                const t = o[e.id];
                for (const e in t) {
                    const n = t[e];
                    for (const e in n) u(n[e].object), delete n[e];
                    delete t[e]
                }
                delete o[e.id]
            },
            releaseStatesOfProgram: function(e) {
                for (const t in o) {
                    const n = o[t];
                    if (void 0 === n[e.id]) continue;
                    const i = n[e.id];
                    for (const e in i) u(i[e].object), delete i[e];
                    delete n[e.id]
                }
            },
            initAttributes: p,
            enableAttribute: m,
            disableUnusedAttributes: g
        }
    }

    function An(e, t, n, i) {
        const r = i.isWebGL2;
        let a;
        this.setMode = function(e) {
            a = e
        }, this.render = function(t, i) {
            e.drawArrays(a, t, i), n.update(i, a, 1)
        }, this.renderInstances = function(i, s, o) {
            if (0 === o) return;
            let l, c;
            if (r) l = e, c = "drawArraysInstanced";
            else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[c](a, i, s, o), n.update(s, a, o)
        }
    }

    function Rn(e, t, n) {
        let i;

        function r(t) {
            if ("highp" === t) {
                if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        const a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
        let s = void 0 !== n.precision ? n.precision : "highp";
        const o = r(s);
        o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o);
        const l = a || t.has("WEBGL_draw_buffers"),
            c = !0 === n.logarithmicDepthBuffer,
            h = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
            u = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            d = e.getParameter(e.MAX_TEXTURE_SIZE),
            p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
            m = e.getParameter(e.MAX_VERTEX_ATTRIBS),
            f = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
            g = e.getParameter(e.MAX_VARYING_VECTORS),
            _ = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
            v = u > 0,
            x = a || t.has("OES_texture_float");
        return {
            isWebGL2: a,
            drawBuffers: l,
            getMaxAnisotropy: function() {
                if (void 0 !== i) return i;
                if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                    const n = t.get("EXT_texture_filter_anisotropic");
                    i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else i = 0;
                return i
            },
            getMaxPrecision: r,
            precision: s,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: u,
            maxTextureSize: d,
            maxCubemapSize: p,
            maxAttributes: m,
            maxVertexUniforms: f,
            maxVaryings: g,
            maxFragmentUniforms: _,
            vertexTextures: v,
            floatFragmentTextures: x,
            floatVertexTextures: v && x,
            maxSamples: a ? e.getParameter(e.MAX_SAMPLES) : 0
        }
    }

    function Ln(e) {
        const t = this;
        let n = null,
            i = 0,
            r = !1,
            a = !1;
        const s = new be,
            o = new ye,
            l = {
                value: null,
                needsUpdate: !1
            };

        function c() {
            l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
        }

        function h(e, n, i, r) {
            const a = null !== e ? e.length : 0;
            let c = null;
            if (0 !== a) {
                if (c = l.value, !0 !== r || null === c) {
                    const t = i + 4 * a,
                        r = n.matrixWorldInverse;
                    o.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t));
                    for (let t = 0, n = i; t !== a; ++t, n += 4) s.copy(e[t]).applyMatrix4(r, o), s.normal.toArray(c, n), c[n + 3] = s.constant
                }
                l.value = c, l.needsUpdate = !0
            }
            return t.numPlanes = a, t.numIntersection = 0, c
        }
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, a) {
            const s = 0 !== e.length || t || 0 !== i || r;
            return r = t, n = h(e, a, 0), i = e.length, s
        }, this.beginShadows = function() {
            a = !0, h(null)
        }, this.endShadows = function() {
            a = !1, c()
        }, this.setState = function(t, s, o) {
            const u = t.clippingPlanes,
                d = t.clipIntersection,
                p = t.clipShadows,
                m = e.get(t);
            if (!r || null === u || 0 === u.length || a && !p) a ? h(null) : c();
            else {
                const e = a ? 0 : i,
                    t = 4 * e;
                let r = m.clippingState || null;
                l.value = r, r = h(u, s, t, o);
                for (let e = 0; e !== t; ++e) r[e] = n[e];
                m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
            }
        }
    }
    let Cn;
    bn.physical = {
        uniforms: Nt([bn.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new ze(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new qe(0)
            },
            sheenColorMap: {
                value: null
            },
            sheenRoughness: {
                value: 0
            },
            sheenRoughnessMap: {
                value: null
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionSamplerSize: {
                value: new ze
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new qe(0)
            },
            specularIntensity: {
                value: 0
            },
            specularIntensityMap: {
                value: null
            },
            specularColor: {
                value: new qe(1, 1, 1)
            },
            specularColorMap: {
                value: null
            }
        }]),
        vertexShader: Sn.meshphysical_vert,
        fragmentShader: Sn.meshphysical_frag
    };
    let Pn = 0;
    class Dn extends Ge {
        constructor(e = Dn.DEFAULT_IMAGE, t = Dn.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, a = 1008, s = 1023, o = 1009, l = 1, c = 3e3) {
            super(), Object.defineProperty(this, "id", {
                value: Pn++
            }), this.uuid = X(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = o, this.offset = new ze(0, 0), this.repeat = new ze(1, 1), this.center = new ze(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ye, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                const i = this.image;
                if (void 0 === i.uuid && (i.uuid = X()), !t && void 0 === e.images[i.uuid]) {
                    let t;
                    if (Array.isArray(i)) {
                        t = [];
                        for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(Nn(i[e].image)) : t.push(Nn(i[e]))
                    } else t = Nn(i);
                    e.images[i.uuid] = {
                        uuid: i.uuid,
                        url: t
                    }
                }
                n.image = i.uuid
            }
            return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(e) {
            if (300 !== this.mapping) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                case l:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case c:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case h:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                case l:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case c:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case h:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
        set needsUpdate(e) {
            !0 === e && this.version++
        }
    }

    function Nn(e) {
        return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? class {
            static getDataURL(e) {
                if (/^data:/i.test(e.src)) return e.src;
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                let t;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    void 0 === Cn && (Cn = xt("canvas")), Cn.width = e.width, Cn.height = e.height;
                    const n = Cn.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Cn
                }
                return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
            }
        }.getDataURL(e) : e.data ? {
            data: Array.prototype.slice.call(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
    }
    Dn.DEFAULT_IMAGE = void 0, Dn.DEFAULT_MAPPING = 300, Dn.prototype.isTexture = !0;
    class In extends Ge {
        constructor(e, t, n = {}) {
            super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new Fe(0, 0, e, t), this.scissorTest = !1, this.viewport = new Fe(0, 0, e, t), this.texture = new Dn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                width: e,
                height: t,
                depth: 1
            }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : m, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
        }
        setTexture(e) {
            e.image = {
                width: this.width,
                height: this.height,
                depth: this.depth
            }, this.texture = e
        }
        setSize(e, t, n = 1) {
            this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = { ...this.texture.image
            }, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    In.prototype.isWebGLRenderTarget = !0;
    class Un extends _t {
        constructor() {
            super(), this.type = "Camera", this.matrixWorldInverse = new Re, this.projectionMatrix = new Re, this.projectionMatrixInverse = new Re
        }
        copy(e, t) {
            return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    Un.prototype.isCamera = !0;
    class Fn extends Un {
        constructor(e = 50, t = 1, n = .1, i = 2e3) {
            super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        }
        setFocalLength(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * W * Math.atan(t), this.updateProjectionMatrix()
        }
        getFocalLength() {
            const e = Math.tan(.5 * k * this.fov);
            return .5 * this.getFilmHeight() / e
        }
        getEffectiveFOV() {
            return 2 * W * Math.atan(Math.tan(.5 * k * this.fov) / this.zoom)
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }
        setViewOffset(e, t, n, i, r, a) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const e = this.near;
            let t = e * Math.tan(.5 * k * this.fov) / this.zoom,
                n = 2 * t,
                i = this.aspect * n,
                r = -.5 * i;
            const a = this.view;
            if (null !== this.view && this.view.enabled) {
                const e = a.fullWidth,
                    s = a.fullHeight;
                r += a.offsetX * i / e, t -= a.offsetY * n / s, i *= a.width / e, n *= a.height / s
            }
            const s = this.filmOffset;
            0 !== s && (r += e * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    }
    Fn.prototype.isPerspectiveCamera = !0;
    const On = 90;
    class Bn extends _t {
        constructor(e, t, n) {
            if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            this.renderTarget = n;
            const i = new Fn(On, 1, e, t);
            i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new J(1, 0, 0)), this.add(i);
            const r = new Fn(On, 1, e, t);
            r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new J(-1, 0, 0)), this.add(r);
            const a = new Fn(On, 1, e, t);
            a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new J(0, 1, 0)), this.add(a);
            const s = new Fn(On, 1, e, t);
            s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new J(0, -1, 0)), this.add(s);
            const o = new Fn(On, 1, e, t);
            o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new J(0, 0, 1)), this.add(o);
            const l = new Fn(On, 1, e, t);
            l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new J(0, 0, -1)), this.add(l)
        }
        update(e, t) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget,
                [i, r, a, s, o, l] = this.children,
                c = e.xr.enabled,
                h = e.getRenderTarget();
            e.xr.enabled = !1;
            const u = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), e.render(t, s), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = u, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(h), e.xr.enabled = c
        }
    }
    class zn extends Dn {
        constructor(e, t, i, r, a, s, o, l, c, h) {
            super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : n, i, r, a, s, o, l, c, h), this.flipY = !1
        }
        get images() {
            return this.image
        }
        set images(e) {
            this.image = e
        }
    }
    zn.prototype.isCubeTexture = !0;
    class Gn extends In {
        constructor(e, t, n) {
            Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), super(e, e, t), t = t || {}, this.texture = new zn(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : m, this.texture._needsFlipEnvMap = !1
        }
        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type, this.texture.format = b, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
            const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                },
                i = new Rt(5, 5, 5),
                r = new Ut({
                    name: "CubemapFromEquirect",
                    uniforms: Dt(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: 1,
                    blending: 0
                });
            r.uniforms.tEquirect.value = t;
            const a = new yn(i, r),
                s = t.minFilter;
            t.minFilter === g && (t.minFilter = m);
            return new Bn(1, 10, this).update(e, a), t.minFilter = s, a.geometry.dispose(), a.material.dispose(), this
        }
        clear(e, t, n, i) {
            const r = e.getRenderTarget();
            for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
            e.setRenderTarget(r)
        }
    }

    function Hn(e) {
        let t = new WeakMap;

        function s(e, t) {
            return t === r ? e.mapping = n : t === a && (e.mapping = i), e
        }

        function o(e) {
            const n = e.target;
            n.removeEventListener("dispose", o);
            const i = t.get(n);
            void 0 !== i && (t.delete(n), i.dispose())
        }
        return {
            get: function(n) {
                if (n && n.isTexture && !1 === n.isRenderTargetTexture) {
                    const i = n.mapping;
                    if (i === r || i === a) {
                        if (t.has(n)) {
                            return s(t.get(n).texture, n.mapping)
                        } {
                            const i = n.image;
                            if (i && i.height > 0) {
                                const r = e.getRenderTarget(),
                                    a = new Gn(i.height / 2);
                                return a.fromEquirectangularTexture(e, n), t.set(n, a), e.setRenderTarget(r), n.addEventListener("dispose", o), s(a.texture, n.mapping)
                            }
                            return null
                        }
                    }
                }
                return n
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    Gn.prototype.isWebGLCubeRenderTarget = !0;
    class Vn extends Un {
        constructor(e = -1, t = 1, n = 1, i = -1, r = .1, a = 2e3) {
            super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = a, this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        }
        setViewOffset(e, t, n, i, r, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                i = (this.top + this.bottom) / 2;
            let r = n - e,
                a = n + e,
                s = i + t,
                o = i - t;
            if (null !== this.view && this.view.enabled) {
                const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += e * this.view.offsetX, a = r + e * this.view.width, s -= t * this.view.offsetY, o = s - t * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
        }
    }
    Vn.prototype.isOrthographicCamera = !0;
    class kn extends Ut {
        constructor(e) {
            super(e), this.type = "RawShaderMaterial"
        }
    }
    kn.prototype.isRawShaderMaterial = !0;
    const Wn = Math.pow(2, 8),
        Xn = [.125, .215, .35, .446, .526, .582],
        jn = 5 + Xn.length,
        qn = 20,
        Yn = {
            [O]: 0,
            [B]: 1
        },
        Kn = new Vn,
        {
            _lodPlanes: Zn,
            _sizeLods: Jn,
            _sigmas: Qn
        } = ai(),
        $n = new qe;
    let ei = null;
    const ti = (1 + Math.sqrt(5)) / 2,
        ni = 1 / ti,
        ii = [new J(1, 1, 1), new J(-1, 1, 1), new J(1, 1, -1), new J(-1, 1, -1), new J(0, ti, ni), new J(0, ti, -ni), new J(ni, 0, ti), new J(-ni, 0, ti), new J(ti, ni, 0), new J(-ti, ni, 0)];
    class ri {
        constructor(e) {
            this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = function(e) {
                const t = new Float32Array(e),
                    n = new J(0, 1, 0);
                return new kn({
                    name: "SphericalGaussianBlur",
                    defines: {
                        n: e
                    },
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        samples: {
                            value: 1
                        },
                        weights: {
                            value: t
                        },
                        latitudinal: {
                            value: !1
                        },
                        dTheta: {
                            value: 0
                        },
                        mipInt: {
                            value: 0
                        },
                        poleAxis: {
                            value: n
                        }
                    },
                    vertexShader: hi(),
                    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${ui()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }(qn), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
        }
        fromScene(e, t = 0, n = .1, i = 100) {
            ei = this._renderer.getRenderTarget();
            const r = this._allocateTargets();
            return this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
        }
        fromEquirectangular(e) {
            return this._fromTexture(e)
        }
        fromCubemap(e) {
            return this._fromTexture(e)
        }
        compileCubemapShader() {
            null === this._cubemapShader && (this._cubemapShader = ci(), this._compileMaterial(this._cubemapShader))
        }
        compileEquirectangularShader() {
            null === this._equirectShader && (this._equirectShader = li(), this._compileMaterial(this._equirectShader))
        }
        dispose() {
            this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
            for (let e = 0; e < Zn.length; e++) Zn[e].dispose()
        }
        _cleanup(e) {
            this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(ei), e.scissorTest = !1, oi(e, 0, 0, e.width, e.height)
        }
        _fromTexture(e) {
            ei = this._renderer.getRenderTarget();
            const t = this._allocateTargets(e);
            return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
        }
        _allocateTargets(e) {
            const t = {
                    magFilter: m,
                    minFilter: m,
                    generateMipmaps: !1,
                    type: M,
                    format: b,
                    encoding: O,
                    depthBuffer: !1
                },
                n = si(t);
            return n.depthBuffer = !e, this._pingPongRenderTarget = si(t), n
        }
        _compileMaterial(e) {
            const t = new yn(Zn[0], e);
            this._renderer.compile(t, Kn)
        }
        _sceneToCubeUV(e, t, n, i) {
            const r = new Fn(90, 1, t, n),
                a = [1, -1, 1, 1, 1, 1],
                s = [1, 1, 1, -1, -1, -1],
                o = this._renderer,
                l = o.autoClear,
                c = o.toneMapping;
            o.getClearColor($n), o.toneMapping = 0, o.autoClear = !1;
            const h = new tn({
                    name: "PMREM.Background",
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                }),
                u = new yn(new Rt, h);
            let d = !1;
            const p = e.background;
            p ? p.isColor && (h.color.copy(p), e.background = null, d = !0) : (h.color.copy($n), d = !0);
            for (let t = 0; t < 6; t++) {
                const n = t % 3;
                0 == n ? (r.up.set(0, a[t], 0), r.lookAt(s[t], 0, 0)) : 1 == n ? (r.up.set(0, 0, a[t]), r.lookAt(0, s[t], 0)) : (r.up.set(0, a[t], 0), r.lookAt(0, 0, s[t])), oi(i, n * Wn, t > 2 ? Wn : 0, Wn, Wn), o.setRenderTarget(i), d && o.render(u, r), o.render(e, r)
            }
            u.geometry.dispose(), u.material.dispose(), o.toneMapping = c, o.autoClear = l, e.background = p
        }
        _setEncoding(e, t) {
            !0 === this._renderer.capabilities.isWebGL2 && t.format === b && t.type === _ && t.encoding === B ? e.value = Yn[3e3] : e.value = Yn[t.encoding]
        }
        _textureToCubeUV(e, t) {
            const r = this._renderer,
                a = e.mapping === n || e.mapping === i;
            a ? null == this._cubemapShader && (this._cubemapShader = ci()) : null == this._equirectShader && (this._equirectShader = li());
            const s = a ? this._cubemapShader : this._equirectShader,
                o = new yn(Zn[0], s),
                l = s.uniforms;
            l.envMap.value = e, a || l.texelSize.value.set(1 / e.image.width, 1 / e.image.height), this._setEncoding(l.inputEncoding, e), oi(t, 0, 0, 3 * Wn, 2 * Wn), r.setRenderTarget(t), r.render(o, Kn)
        }
        _applyPMREM(e) {
            const t = this._renderer,
                n = t.autoClear;
            t.autoClear = !1;
            for (let t = 1; t < jn; t++) {
                const n = Math.sqrt(Qn[t] * Qn[t] - Qn[t - 1] * Qn[t - 1]),
                    i = ii[(t - 1) % ii.length];
                this._blur(e, t - 1, t, n, i)
            }
            t.autoClear = n
        }
        _blur(e, t, n, i, r) {
            const a = this._pingPongRenderTarget;
            this._halfBlur(e, a, t, n, i, "latitudinal", r), this._halfBlur(a, e, n, n, i, "longitudinal", r)
        }
        _halfBlur(e, t, n, i, r, a, s) {
            const o = this._renderer,
                l = this._blurMaterial;
            "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
            const c = new yn(Zn[i], l),
                h = l.uniforms,
                u = Jn[n] - 1,
                d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                p = r / d,
                m = isFinite(r) ? 1 + Math.floor(3 * p) : qn;
            m > qn && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
            const f = [];
            let g = 0;
            for (let e = 0; e < qn; ++e) {
                const t = e / p,
                    n = Math.exp(-t * t / 2);
                f.push(n), 0 == e ? g += n : e < m && (g += 2 * n)
            }
            for (let e = 0; e < f.length; e++) f[e] = f[e] / g;
            h.envMap.value = e.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === a, s && (h.poleAxis.value = s), h.dTheta.value = d, h.mipInt.value = 8 - n;
            const _ = Jn[i];
            oi(t, 3 * Math.max(0, Wn - 2 * _), (0 === i ? 0 : 2 * Wn) + 2 * _ * (i > 4 ? i - 8 + 4 : 0), 3 * _, 2 * _), o.setRenderTarget(t), o.render(c, Kn)
        }
    }

    function ai() {
        const e = [],
            t = [],
            n = [];
        let i = 8;
        for (let r = 0; r < jn; r++) {
            const a = Math.pow(2, i);
            t.push(a);
            let s = 1 / a;
            r > 4 ? s = Xn[r - 8 + 4 - 1] : 0 == r && (s = 0), n.push(s);
            const o = 1 / (a - 1),
                l = -o / 2,
                c = 1 + o / 2,
                h = [l, l, c, l, c, c, l, l, c, c, l, c],
                u = 6,
                d = 6,
                p = 3,
                m = 2,
                f = 1,
                g = new Float32Array(p * d * u),
                _ = new Float32Array(m * d * u),
                v = new Float32Array(f * d * u);
            for (let e = 0; e < u; e++) {
                const t = e % 3 * 2 / 3 - 1,
                    n = e > 2 ? 0 : -1,
                    i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                g.set(i, p * d * e), _.set(h, m * d * e);
                const r = [e, e, e, e, e, e];
                v.set(r, f * d * e)
            }
            const x = new At;
            x.setAttribute("position", new Ze(g, p)), x.setAttribute("uv", new Ze(_, m)), x.setAttribute("faceIndex", new Ze(v, f)), e.push(x), i > 4 && i--
        }
        return {
            _lodPlanes: e,
            _sizeLods: t,
            _sigmas: n
        }
    }

    function si(e) {
        const t = new In(3 * Wn, 3 * Wn, e);
        return t.texture.mapping = s, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
    }

    function oi(e, t, n, i, r) {
        e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
    }

    function li() {
        const e = new ze(1, 1);
        return new kn({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                texelSize: {
                    value: e
                },
                inputEncoding: {
                    value: Yn[3e3]
                }
            },
            vertexShader: hi(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${ui()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function ci() {
        return new kn({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                inputEncoding: {
                    value: Yn[3e3]
                }
            },
            vertexShader: hi(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${ui()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );\n\n\t\t\t}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function hi() {
        return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
    }

    function ui() {
        return "\n\n\t\tuniform int inputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
    }

    function di(e) {
        let t = new WeakMap,
            s = null;

        function o(e) {
            const n = e.target;
            n.removeEventListener("dispose", o);
            const i = t.get(n);
            void 0 !== i && (t.delete(n), i.dispose())
        }
        return {
            get: function(l) {
                if (l && l.isTexture && !1 === l.isRenderTargetTexture) {
                    const c = l.mapping,
                        h = c === r || c === a,
                        u = c === n || c === i;
                    if (h || u) {
                        if (t.has(l)) return t.get(l).texture; {
                            const n = l.image;
                            if (h && n && n.height > 0 || u && n && function(e) {
                                    let t = 0;
                                    const n = 6;
                                    for (let i = 0; i < n; i++) void 0 !== e[i] && t++;
                                    return t === n
                                }(n)) {
                                const n = e.getRenderTarget();
                                null === s && (s = new ri(e));
                                const i = h ? s.fromEquirectangular(l) : s.fromCubemap(l);
                                return t.set(l, i), e.setRenderTarget(n), l.addEventListener("dispose", o), i.texture
                            }
                            return null
                        }
                    }
                }
                return l
            },
            dispose: function() {
                t = new WeakMap, null !== s && (s.dispose(), s = null)
            }
        }
    }

    function pi(e) {
        const t = {};

        function n(n) {
            if (void 0 !== t[n]) return t[n];
            let i;
            switch (n) {
                case "WEBGL_depth_texture":
                    i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = e.getExtension(n)
            }
            return t[n] = i, i
        }
        return {
            has: function(e) {
                return null !== n(e)
            },
            init: function(e) {
                e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
            },
            get: function(e) {
                const t = n(e);
                return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
            }
        }
    }

    function mi(e, t, n, i) {
        const r = {},
            a = new WeakMap;

        function s(e) {
            const o = e.target;
            null !== o.index && t.remove(o.index);
            for (const e in o.attributes) t.remove(o.attributes[e]);
            o.removeEventListener("dispose", s), delete r[o.id];
            const l = a.get(o);
            l && (t.remove(l), a.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
        }

        function o(e) {
            const n = [],
                i = e.index,
                r = e.attributes.position;
            let s = 0;
            if (null !== i) {
                const e = i.array;
                s = i.version;
                for (let t = 0, i = e.length; t < i; t += 3) {
                    const i = e[t + 0],
                        r = e[t + 1],
                        a = e[t + 2];
                    n.push(i, r, r, a, a, i)
                }
            } else {
                const e = r.array;
                s = r.version;
                for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                    const e = t + 0,
                        i = t + 1,
                        r = t + 2;
                    n.push(e, i, i, r, r, e)
                }
            }
            const o = new(vt(n) > 65535 ? Qe : Je)(n, 1);
            o.version = s;
            const l = a.get(e);
            l && t.remove(l), a.set(e, o)
        }
        return {
            get: function(e, t) {
                return !0 === r[t.id] || (t.addEventListener("dispose", s), r[t.id] = !0, n.memory.geometries++), t
            },
            update: function(n) {
                const i = n.attributes;
                for (const n in i) t.update(i[n], e.ARRAY_BUFFER);
                const r = n.morphAttributes;
                for (const n in r) {
                    const i = r[n];
                    for (let n = 0, r = i.length; n < r; n++) t.update(i[n], e.ARRAY_BUFFER)
                }
            },
            getWireframeAttribute: function(e) {
                const t = a.get(e);
                if (t) {
                    const n = e.index;
                    null !== n && t.version < n.version && o(e)
                } else o(e);
                return a.get(e)
            }
        }
    }

    function fi(e, t, n, i) {
        const r = i.isWebGL2;
        let a, s, o;
        this.setMode = function(e) {
            a = e
        }, this.setIndex = function(e) {
            s = e.type, o = e.bytesPerElement
        }, this.render = function(t, i) {
            e.drawElements(a, i, s, t * o), n.update(i, a, 1)
        }, this.renderInstances = function(i, l, c) {
            if (0 === c) return;
            let h, u;
            if (r) h = e, u = "drawElementsInstanced";
            else if (h = t.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h[u](a, l, s, i * o, c), n.update(l, a, c)
        }
    }

    function gi(e) {
        const t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
                t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
            },
            update: function(n, i, r) {
                switch (t.calls++, i) {
                    case e.TRIANGLES:
                        t.triangles += r * (n / 3);
                        break;
                    case e.LINES:
                        t.lines += r * (n / 2);
                        break;
                    case e.LINE_STRIP:
                        t.lines += r * (n - 1);
                        break;
                    case e.LINE_LOOP:
                        t.lines += r * n;
                        break;
                    case e.POINTS:
                        t.points += r * n;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                }
            }
        }
    }
    class _i extends Dn {
        constructor(e = null, t = 1, n = 1, i = 1) {
            super(null), this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = u, this.minFilter = u, this.wrapR = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }

    function vi(e, t) {
        return e[0] - t[0]
    }

    function xi(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }

    function yi(e, t) {
        let n = 1;
        const i = t.isInterleavedBufferAttribute ? t.data.array : t.array;
        i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), e.divideScalar(n)
    }

    function Mi(e, t, n) {
        const i = {},
            r = new Float32Array(8),
            a = new WeakMap,
            s = new J,
            o = [];
        for (let e = 0; e < 8; e++) o[e] = [e, 0];
        return {
            update: function(l, c, h, u) {
                const d = l.morphTargetInfluences;
                if (!0 === t.isWebGL2) {
                    const i = c.morphAttributes.position.length;
                    let r = a.get(c);
                    if (void 0 === r || r.count !== i) {
                        void 0 !== r && r.texture.dispose();
                        const e = void 0 !== c.morphAttributes.normal,
                            n = c.morphAttributes.position,
                            o = c.morphAttributes.normal || [],
                            l = !0 === e ? 2 : 1;
                        let h = c.attributes.position.count * l,
                            u = 1;
                        h > t.maxTextureSize && (u = Math.ceil(h / t.maxTextureSize), h = t.maxTextureSize);
                        const d = new Float32Array(h * u * 4 * i),
                            p = new _i(d, h, u, i);
                        p.format = b, p.type = y, p.needsUpdate = !0;
                        const m = 4 * l;
                        for (let t = 0; t < i; t++) {
                            const i = n[t],
                                r = o[t],
                                a = h * u * 4 * t;
                            for (let t = 0; t < i.count; t++) {
                                s.fromBufferAttribute(i, t), !0 === i.normalized && yi(s, i);
                                const n = t * m;
                                d[a + n + 0] = s.x, d[a + n + 1] = s.y, d[a + n + 2] = s.z, d[a + n + 3] = 0, !0 === e && (s.fromBufferAttribute(r, t), !0 === r.normalized && yi(s, r), d[a + n + 4] = s.x, d[a + n + 5] = s.y, d[a + n + 6] = s.z, d[a + n + 7] = 0)
                            }
                        }
                        r = {
                            count: i,
                            texture: p,
                            size: new ze(h, u)
                        }, a.set(c, r)
                    }
                    let o = 0;
                    for (let e = 0; e < d.length; e++) o += d[e];
                    const l = c.morphTargetsRelative ? 1 : 1 - o;
                    u.getUniforms().setValue(e, "morphTargetBaseInfluence", l), u.getUniforms().setValue(e, "morphTargetInfluences", d), u.getUniforms().setValue(e, "morphTargetsTexture", r.texture, n), u.getUniforms().setValue(e, "morphTargetsTextureSize", r.size)
                } else {
                    const t = void 0 === d ? 0 : d.length;
                    let n = i[c.id];
                    if (void 0 === n || n.length !== t) {
                        n = [];
                        for (let e = 0; e < t; e++) n[e] = [e, 0];
                        i[c.id] = n
                    }
                    for (let e = 0; e < t; e++) {
                        const t = n[e];
                        t[0] = e, t[1] = d[e]
                    }
                    n.sort(xi);
                    for (let e = 0; e < 8; e++) e < t && n[e][1] ? (o[e][0] = n[e][0], o[e][1] = n[e][1]) : (o[e][0] = Number.MAX_SAFE_INTEGER, o[e][1] = 0);
                    o.sort(vi);
                    const a = c.morphAttributes.position,
                        s = c.morphAttributes.normal;
                    let l = 0;
                    for (let e = 0; e < 8; e++) {
                        const t = o[e],
                            n = t[0],
                            i = t[1];
                        n !== Number.MAX_SAFE_INTEGER && i ? (a && c.getAttribute("morphTarget" + e) !== a[n] && c.setAttribute("morphTarget" + e, a[n]), s && c.getAttribute("morphNormal" + e) !== s[n] && c.setAttribute("morphNormal" + e, s[n]), r[e] = i, l += i) : (a && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), s && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), r[e] = 0)
                    }
                    const h = c.morphTargetsRelative ? 1 : 1 - l;
                    u.getUniforms().setValue(e, "morphTargetBaseInfluence", h), u.getUniforms().setValue(e, "morphTargetInfluences", r)
                }
            }
        }
    }
    _i.prototype.isDataTexture2DArray = !0;
    class Si extends In {
        constructor(e, t, n = {}) {
            super(e, t, n), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth, this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
        }
        copy(e) {
            return super.copy.call(this, e), this.samples = e.samples, this.useRenderToTexture = e.useRenderToTexture, this.useRenderbuffer = e.useRenderbuffer, this
        }
    }

    function Ti(e, t, n, i) {
        let r = new WeakMap;

        function a(e) {
            const t = e.target;
            t.removeEventListener("dispose", a), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
        }
        return {
            update: function(s) {
                const o = i.render.frame,
                    l = s.geometry,
                    c = t.get(s, l);
                return r.get(c) !== o && (t.update(c), r.set(c, o)), s.isInstancedMesh && (!1 === s.hasEventListener("dispose", a) && s.addEventListener("dispose", a), n.update(s.instanceMatrix, e.ARRAY_BUFFER), null !== s.instanceColor && n.update(s.instanceColor, e.ARRAY_BUFFER)), c
            },
            dispose: function() {
                r = new WeakMap
            }
        }
    }
    Si.prototype.isWebGLMultisampleRenderTarget = !0;
    class bi extends Dn {
        constructor(e = null, t = 1, n = 1, i = 1) {
            super(null), this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = u, this.minFilter = u, this.wrapR = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }
    bi.prototype.isDataTexture3D = !0;
    const Ei = new Dn,
        wi = new _i,
        Ai = new bi,
        Ri = new zn,
        Li = [],
        Ci = [],
        Pi = new Float32Array(16),
        Di = new Float32Array(9),
        Ni = new Float32Array(4);

    function Ii(e, t, n) {
        const i = e[0];
        if (i <= 0 || i > 0) return e;
        const r = t * n;
        let a = Li[r];
        if (void 0 === a && (a = new Float32Array(r), Li[r] = a), 0 !== t) {
            i.toArray(a, 0);
            for (let i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(a, r)
        }
        return a
    }

    function Ui(e, t) {
        if (e.length !== t.length) return !1;
        for (let n = 0, i = e.length; n < i; n++)
            if (e[n] !== t[n]) return !1;
        return !0
    }

    function Fi(e, t) {
        for (let n = 0, i = t.length; n < i; n++) e[n] = t[n]
    }

    function Oi(e, t) {
        let n = Ci[t];
        void 0 === n && (n = new Int32Array(t), Ci[t] = n);
        for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
        return n
    }

    function Bi(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
    }

    function zi(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
        else {
            if (Ui(n, t)) return;
            e.uniform2fv(this.addr, t), Fi(n, t)
        }
    }

    function Gi(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
        else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
        else {
            if (Ui(n, t)) return;
            e.uniform3fv(this.addr, t), Fi(n, t)
        }
    }

    function Hi(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
        else {
            if (Ui(n, t)) return;
            e.uniform4fv(this.addr, t), Fi(n, t)
        }
    }

    function Vi(e, t) {
        const n = this.cache,
            i = t.elements;
        if (void 0 === i) {
            if (Ui(n, t)) return;
            e.uniformMatrix2fv(this.addr, !1, t), Fi(n, t)
        } else {
            if (Ui(n, i)) return;
            Ni.set(i), e.uniformMatrix2fv(this.addr, !1, Ni), Fi(n, i)
        }
    }

    function ki(e, t) {
        const n = this.cache,
            i = t.elements;
        if (void 0 === i) {
            if (Ui(n, t)) return;
            e.uniformMatrix3fv(this.addr, !1, t), Fi(n, t)
        } else {
            if (Ui(n, i)) return;
            Di.set(i), e.uniformMatrix3fv(this.addr, !1, Di), Fi(n, i)
        }
    }

    function Wi(e, t) {
        const n = this.cache,
            i = t.elements;
        if (void 0 === i) {
            if (Ui(n, t)) return;
            e.uniformMatrix4fv(this.addr, !1, t), Fi(n, t)
        } else {
            if (Ui(n, i)) return;
            Pi.set(i), e.uniformMatrix4fv(this.addr, !1, Pi), Fi(n, i)
        }
    }

    function Xi(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
    }

    function ji(e, t) {
        const n = this.cache;
        Ui(n, t) || (e.uniform2iv(this.addr, t), Fi(n, t))
    }

    function qi(e, t) {
        const n = this.cache;
        Ui(n, t) || (e.uniform3iv(this.addr, t), Fi(n, t))
    }

    function Yi(e, t) {
        const n = this.cache;
        Ui(n, t) || (e.uniform4iv(this.addr, t), Fi(n, t))
    }

    function Ki(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
    }

    function Zi(e, t) {
        const n = this.cache;
        Ui(n, t) || (e.uniform2uiv(this.addr, t), Fi(n, t))
    }

    function Ji(e, t) {
        const n = this.cache;
        Ui(n, t) || (e.uniform3uiv(this.addr, t), Fi(n, t))
    }

    function Qi(e, t) {
        const n = this.cache;
        Ui(n, t) || (e.uniform4uiv(this.addr, t), Fi(n, t))
    }

    function $i(e, t, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(t || Ei, r)
    }

    function er(e, t, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || Ai, r)
    }

    function tr(e, t, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(t || Ri, r)
    }

    function nr(e, t, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || wi, r)
    }

    function ir(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function rr(e, t) {
        const n = Ii(t, this.size, 2);
        e.uniform2fv(this.addr, n)
    }

    function ar(e, t) {
        const n = Ii(t, this.size, 3);
        e.uniform3fv(this.addr, n)
    }

    function sr(e, t) {
        const n = Ii(t, this.size, 4);
        e.uniform4fv(this.addr, n)
    }

    function or(e, t) {
        const n = Ii(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n)
    }

    function lr(e, t) {
        const n = Ii(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n)
    }

    function cr(e, t) {
        const n = Ii(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n)
    }

    function hr(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function ur(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function dr(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function pr(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function mr(e, t) {
        e.uniform1uiv(this.addr, t)
    }

    function fr(e, t) {
        e.uniform2uiv(this.addr, t)
    }

    function gr(e, t) {
        e.uniform3uiv(this.addr, t)
    }

    function _r(e, t) {
        e.uniform4uiv(this.addr, t)
    }

    function vr(e, t, n) {
        const i = t.length,
            r = Oi(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.safeSetTexture2D(t[e] || Ei, r[e])
    }

    function xr(e, t, n) {
        const i = t.length,
            r = Oi(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.setTexture3D(t[e] || Ai, r[e])
    }

    function yr(e, t, n) {
        const i = t.length,
            r = Oi(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.safeSetTextureCube(t[e] || Ri, r[e])
    }

    function Mr(e, t, n) {
        const i = t.length,
            r = Oi(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.setTexture2DArray(t[e] || wi, r[e])
    }

    function Sr(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return Bi;
                case 35664:
                    return zi;
                case 35665:
                    return Gi;
                case 35666:
                    return Hi;
                case 35674:
                    return Vi;
                case 35675:
                    return ki;
                case 35676:
                    return Wi;
                case 5124:
                case 35670:
                    return Xi;
                case 35667:
                case 35671:
                    return ji;
                case 35668:
                case 35672:
                    return qi;
                case 35669:
                case 35673:
                    return Yi;
                case 5125:
                    return Ki;
                case 36294:
                    return Zi;
                case 36295:
                    return Ji;
                case 36296:
                    return Qi;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return $i;
                case 35679:
                case 36299:
                case 36307:
                    return er;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return tr;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return nr
            }
        }(t.type)
    }

    function Tr(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return ir;
                case 35664:
                    return rr;
                case 35665:
                    return ar;
                case 35666:
                    return sr;
                case 35674:
                    return or;
                case 35675:
                    return lr;
                case 35676:
                    return cr;
                case 5124:
                case 35670:
                    return hr;
                case 35667:
                case 35671:
                    return ur;
                case 35668:
                case 35672:
                    return dr;
                case 35669:
                case 35673:
                    return pr;
                case 5125:
                    return mr;
                case 36294:
                    return fr;
                case 36295:
                    return gr;
                case 36296:
                    return _r;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return vr;
                case 35679:
                case 36299:
                case 36307:
                    return xr;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return yr;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return Mr
            }
        }(t.type)
    }

    function br(e) {
        this.id = e, this.seq = [], this.map = {}
    }
    Tr.prototype.updateCache = function(e) {
        const t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Fi(t, e)
    }, br.prototype.setValue = function(e, t, n) {
        const i = this.seq;
        for (let r = 0, a = i.length; r !== a; ++r) {
            const a = i[r];
            a.setValue(e, t[a.id], n)
        }
    };
    const Er = /(\w+)(\])?(\[|\.)?/g;

    function wr(e, t) {
        e.seq.push(t), e.map[t.id] = t
    }

    function Ar(e, t, n) {
        const i = e.name,
            r = i.length;
        for (Er.lastIndex = 0;;) {
            const a = Er.exec(i),
                s = Er.lastIndex;
            let o = a[1];
            const l = "]" === a[2],
                c = a[3];
            if (l && (o |= 0), void 0 === c || "[" === c && s + 2 === r) {
                wr(n, void 0 === c ? new Sr(o, e, t) : new Tr(o, e, t));
                break
            } {
                let e = n.map[o];
                void 0 === e && (e = new br(o), wr(n, e)), n = e
            }
        }
    }

    function Rr(e, t) {
        this.seq = [], this.map = {};
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
            const n = e.getActiveUniform(t, i);
            Ar(n, e.getUniformLocation(t, n.name), this)
        }
    }

    function Lr(e, t, n) {
        const i = e.createShader(t);
        return e.shaderSource(i, n), e.compileShader(i), i
    }
    Rr.prototype.setValue = function(e, t, n, i) {
        const r = this.map[t];
        void 0 !== r && r.setValue(e, n, i)
    }, Rr.prototype.setOptional = function(e, t, n) {
        const i = t[n];
        void 0 !== i && this.setValue(e, n, i)
    }, Rr.upload = function(e, t, n, i) {
        for (let r = 0, a = t.length; r !== a; ++r) {
            const a = t[r],
                s = n[a.id];
            !1 !== s.needsUpdate && a.setValue(e, s.value, i)
        }
    }, Rr.seqWithValue = function(e, t) {
        const n = [];
        for (let i = 0, r = e.length; i !== r; ++i) {
            const r = e[i];
            r.id in t && n.push(r)
        }
        return n
    };
    let Cr = 0;

    function Pr(e) {
        switch (e) {
            case O:
                return ["Linear", "( value )"];
            case B:
                return ["sRGB", "( value )"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
        }
    }

    function Dr(e, t, n) {
        const i = e.getShaderParameter(t, e.COMPILE_STATUS),
            r = e.getShaderInfoLog(t).trim();
        return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function(e) {
            const t = e.split("\n");
            for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
            return t.join("\n")
        }(e.getShaderSource(t))
    }

    function Nr(e, t) {
        const n = Pr(t);
        return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function Ir(e, t) {
        const n = Pr(t);
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }

    function Ur(e, t) {
        let n;
        switch (t) {
            case 1:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "OptimizedCineon";
                break;
            case 4:
                n = "ACESFilmic";
                break;
            case 5:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
        }
        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }

    function Fr(e) {
        return "" !== e
    }

    function Or(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
    }

    function Br(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }
    const zr = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Gr(e) {
        return e.replace(zr, Hr)
    }

    function Hr(e, t) {
        const n = Sn[t];
        if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
        return Gr(n)
    }
    const Vr = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        kr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function Wr(e) {
        return e.replace(kr, jr).replace(Vr, Xr)
    }

    function Xr(e, t, n, i) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), jr(e, t, n, i)
    }

    function jr(e, t, n, i) {
        let r = "";
        for (let e = parseInt(t); e < parseInt(n); e++) r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
        return r
    }

    function qr(e) {
        let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
    }

    function Yr(e, t, r, a) {
        const l = e.getContext(),
            c = r.defines;
        let h = r.vertexShader,
            u = r.fragmentShader;
        const d = function(e) {
                let t = "SHADOWMAP_TYPE_BASIC";
                return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
            }(r),
            p = function(e) {
                let t = "ENVMAP_TYPE_CUBE";
                if (e.envMap) switch (e.envMapMode) {
                    case n:
                    case i:
                        t = "ENVMAP_TYPE_CUBE";
                        break;
                    case s:
                    case o:
                        t = "ENVMAP_TYPE_CUBE_UV"
                }
                return t
            }(r),
            m = function(e) {
                let t = "ENVMAP_MODE_REFLECTION";
                if (e.envMap) switch (e.envMapMode) {
                    case i:
                    case o:
                        t = "ENVMAP_MODE_REFRACTION"
                }
                return t
            }(r),
            f = function(e) {
                let t = "ENVMAP_BLENDING_NONE";
                if (e.envMap) switch (e.combine) {
                    case 0:
                        t = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        t = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        t = "ENVMAP_BLENDING_ADD"
                }
                return t
            }(r),
            g = r.isWebGL2 ? "" : function(e) {
                return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Fr).join("\n")
            }(r),
            _ = function(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    !1 !== i && t.push("#define " + n + " " + i)
                }
                return t.join("\n")
            }(c),
            v = l.createProgram();
        let x, y, M = r.glslVersion ? "#version " + r.glslVersion + "\n" : "";
        r.isRawShaderMaterial ? (x = [_].filter(Fr).join("\n"), x.length > 0 && (x += "\n"), y = [g, _].filter(Fr).join("\n"), y.length > 0 && (y += "\n")) : (x = [qr(r), "#define SHADER_NAME " + r.shaderName, _, r.instancing ? "#define USE_INSTANCING" : "", r.instancingColor ? "#define USE_INSTANCING_COLOR" : "", r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + r.maxBones, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + m : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.useVertexTexture ? "#define BONE_TEXTURE" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && !1 === r.flatShading ? "#define USE_MORPHNORMALS" : "", r.morphTargets && r.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", r.morphTargets && r.isWebGL2 ? "#define MORPHTARGETS_COUNT " + r.morphTargetsCount : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + d : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Fr).join("\n"), y = [g, qr(r), "#define SHADER_NAME " + r.shaderName, _, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.matcap ? "#define USE_MATCAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + p : "", r.envMap ? "#define " + m : "", r.envMap ? "#define " + f : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoat ? "#define USE_CLEARCOAT" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.alphaTest ? "#define USE_ALPHATEST" : "", r.sheen ? "#define USE_SHEEN" : "", r.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors || r.instancingColor ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + d : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (r.extensionShaderTextureLOD || r.envMap) && r.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== r.toneMapping ? "#define TONE_MAPPING" : "", 0 !== r.toneMapping ? Sn.tonemapping_pars_fragment : "", 0 !== r.toneMapping ? Ur("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", r.format === T ? "#define OPAQUE" : "", Sn.encodings_pars_fragment, r.map ? Nr("mapTexelToLinear", r.mapEncoding) : "", r.matcap ? Nr("matcapTexelToLinear", r.matcapEncoding) : "", r.envMap ? Nr("envMapTexelToLinear", r.envMapEncoding) : "", r.emissiveMap ? Nr("emissiveMapTexelToLinear", r.emissiveMapEncoding) : "", r.specularColorMap ? Nr("specularColorMapTexelToLinear", r.specularColorMapEncoding) : "", r.sheenColorMap ? Nr("sheenColorMapTexelToLinear", r.sheenColorMapEncoding) : "", r.lightMap ? Nr("lightMapTexelToLinear", r.lightMapEncoding) : "", Ir("linearToOutputTexel", r.outputEncoding), r.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(Fr).join("\n")), h = Gr(h), h = Or(h, r), h = Br(h, r), u = Gr(u), u = Or(u, r), u = Br(u, r), h = Wr(h), u = Wr(u), r.isWebGL2 && !0 !== r.isRawShaderMaterial && (M = "#version 300 es\n", x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, y = ["#define varying in", r.glslVersion === H ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", r.glslVersion === H ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
        const S = M + x + h,
            b = M + y + u,
            E = Lr(l, l.VERTEX_SHADER, S),
            w = Lr(l, l.FRAGMENT_SHADER, b);
        if (l.attachShader(v, E), l.attachShader(v, w), void 0 !== r.index0AttributeName ? l.bindAttribLocation(v, 0, r.index0AttributeName) : !0 === r.morphTargets && l.bindAttribLocation(v, 0, "position"), l.linkProgram(v), e.debug.checkShaderErrors) {
            const e = l.getProgramInfoLog(v).trim(),
                t = l.getShaderInfoLog(E).trim(),
                n = l.getShaderInfoLog(w).trim();
            let i = !0,
                r = !0;
            if (!1 === l.getProgramParameter(v, l.LINK_STATUS)) {
                i = !1;
                const t = Dr(l, E, "vertex"),
                    n = Dr(l, w, "fragment");
                console.error("THREE.WebGLProgram: Shader Error " + l.getError() + " - VALIDATE_STATUS " + l.getProgramParameter(v, l.VALIDATE_STATUS) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
            } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (r = !1);
            r && (this.diagnostics = {
                runnable: i,
                programLog: e,
                vertexShader: {
                    log: t,
                    prefix: x
                },
                fragmentShader: {
                    log: n,
                    prefix: y
                }
            })
        }
        let A, R;
        return l.deleteShader(E), l.deleteShader(w), this.getUniforms = function() {
            return void 0 === A && (A = new Rr(l, v)), A
        }, this.getAttributes = function() {
            return void 0 === R && (R = function(e, t) {
                const n = {},
                    i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                for (let r = 0; r < i; r++) {
                    const i = e.getActiveAttrib(t, r),
                        a = i.name;
                    let s = 1;
                    i.type === e.FLOAT_MAT2 && (s = 2), i.type === e.FLOAT_MAT3 && (s = 3), i.type === e.FLOAT_MAT4 && (s = 4), n[a] = {
                        type: i.type,
                        location: e.getAttribLocation(t, a),
                        locationSize: s
                    }
                }
                return n
            }(l, v)), R
        }, this.destroy = function() {
            a.releaseStatesOfProgram(this), l.deleteProgram(v), this.program = void 0
        }, this.name = r.shaderName, this.id = Cr++, this.cacheKey = t, this.usedTimes = 1, this.program = v, this.vertexShader = E, this.fragmentShader = w, this
    }
    let Kr = 0;
    class Zr {
        constructor() {
            this.shaderCache = new Map, this.materialCache = new Map
        }
        update(e) {
            const t = e.vertexShader,
                n = e.fragmentShader,
                i = this._getShaderStage(t),
                r = this._getShaderStage(n),
                a = this._getShaderCacheForMaterial(e);
            return !1 === a.has(i) && (a.add(i), i.usedTimes++), !1 === a.has(r) && (a.add(r), r.usedTimes++), this
        }
        remove(e) {
            const t = this.materialCache.get(e);
            for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e);
            return this.materialCache.delete(e), this
        }
        getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id
        }
        getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear()
        }
        _getShaderCacheForMaterial(e) {
            const t = this.materialCache;
            return !1 === t.has(e) && t.set(e, new Set), t.get(e)
        }
        _getShaderStage(e) {
            const t = this.shaderCache;
            if (!1 === t.has(e)) {
                const n = new Jr;
                t.set(e, n)
            }
            return t.get(e)
        }
    }
    class Jr {
        constructor() {
            this.id = Kr++, this.usedTimes = 0
        }
    }

    function Qr(e, t, n, i, r, a, l) {
        const c = new it,
            h = new Zr,
            u = [],
            d = r.isWebGL2,
            p = r.logarithmicDepthBuffer,
            m = r.floatVertexTextures,
            f = r.maxVertexUniforms,
            g = r.vertexTextures;
        let v = r.precision;
        const x = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };

        function y(e) {
            let t;
            return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = O, d && e && e.isTexture && e.format === b && e.type === _ && e.encoding === B && (t = O), t
        }
        return {
            getParameters: function(a, c, u, _, M) {
                const S = _.fog,
                    T = a.isMeshStandardMaterial ? _.environment : null,
                    b = (a.isMeshStandardMaterial ? n : t).get(a.envMap || T),
                    E = x[a.type],
                    w = M.isSkinnedMesh ? function(e) {
                        const t = e.skeleton.bones;
                        if (m) return 1024; {
                            const e = f,
                                n = Math.floor((e - 20) / 4),
                                i = Math.min(n, t.length);
                            return i < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i
                        }
                    }(M) : 0;
                let A, R, L, C;
                if (null !== a.precision && (v = r.getMaxPrecision(a.precision), v !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", v, "instead.")), E) {
                    const e = bn[E];
                    A = e.vertexShader, R = e.fragmentShader
                } else A = a.vertexShader, R = a.fragmentShader, h.update(a), L = h.getVertexShaderID(a), C = h.getFragmentShaderID(a);
                const P = e.getRenderTarget(),
                    D = a.alphaTest > 0,
                    N = a.clearcoat > 0;
                return {
                    isWebGL2: d,
                    shaderID: E,
                    shaderName: a.type,
                    vertexShader: A,
                    fragmentShader: R,
                    defines: a.defines,
                    customVertexShaderID: L,
                    customFragmentShaderID: C,
                    isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                    glslVersion: a.glslVersion,
                    precision: v,
                    instancing: !0 === M.isInstancedMesh,
                    instancingColor: !0 === M.isInstancedMesh && null !== M.instanceColor,
                    supportsVertexTextures: g,
                    outputEncoding: null !== P ? y(P.texture) : e.outputEncoding,
                    map: !!a.map,
                    mapEncoding: y(a.map),
                    matcap: !!a.matcap,
                    matcapEncoding: y(a.matcap),
                    envMap: !!b,
                    envMapMode: b && b.mapping,
                    envMapEncoding: y(b),
                    envMapCubeUV: !!b && (b.mapping === s || b.mapping === o),
                    lightMap: !!a.lightMap,
                    lightMapEncoding: y(a.lightMap),
                    aoMap: !!a.aoMap,
                    emissiveMap: !!a.emissiveMap,
                    emissiveMapEncoding: y(a.emissiveMap),
                    bumpMap: !!a.bumpMap,
                    normalMap: !!a.normalMap,
                    objectSpaceNormalMap: 1 === a.normalMapType,
                    tangentSpaceNormalMap: 0 === a.normalMapType,
                    clearcoat: N,
                    clearcoatMap: N && !!a.clearcoatMap,
                    clearcoatRoughnessMap: N && !!a.clearcoatRoughnessMap,
                    clearcoatNormalMap: N && !!a.clearcoatNormalMap,
                    displacementMap: !!a.displacementMap,
                    roughnessMap: !!a.roughnessMap,
                    metalnessMap: !!a.metalnessMap,
                    specularMap: !!a.specularMap,
                    specularIntensityMap: !!a.specularIntensityMap,
                    specularColorMap: !!a.specularColorMap,
                    specularColorMapEncoding: y(a.specularColorMap),
                    alphaMap: !!a.alphaMap,
                    alphaTest: D,
                    gradientMap: !!a.gradientMap,
                    sheen: a.sheen > 0,
                    sheenColorMap: !!a.sheenColorMap,
                    sheenColorMapEncoding: y(a.sheenColorMap),
                    sheenRoughnessMap: !!a.sheenRoughnessMap,
                    transmission: a.transmission > 0,
                    transmissionMap: !!a.transmissionMap,
                    thicknessMap: !!a.thicknessMap,
                    combine: a.combine,
                    vertexTangents: !!a.normalMap && !!M.geometry && !!M.geometry.attributes.tangent,
                    vertexColors: a.vertexColors,
                    vertexAlphas: !0 === a.vertexColors && !!M.geometry && !!M.geometry.attributes.color && 4 === M.geometry.attributes.color.itemSize,
                    vertexUvs: !!(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatMap || a.clearcoatRoughnessMap || a.clearcoatNormalMap || a.displacementMap || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularColorMap || a.sheenColorMap || a.sheenRoughnessMap),
                    uvsVertexOnly: !(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatNormalMap || a.transmission > 0 || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularColorMap || a.sheen > 0 || a.sheenColorMap || a.sheenRoughnessMap || !a.displacementMap),
                    fog: !!S,
                    useFog: a.fog,
                    fogExp2: S && S.isFogExp2,
                    flatShading: !!a.flatShading,
                    sizeAttenuation: a.sizeAttenuation,
                    logarithmicDepthBuffer: p,
                    skinning: !0 === M.isSkinnedMesh && w > 0,
                    maxBones: w,
                    useVertexTexture: m,
                    morphTargets: !!M.geometry && !!M.geometry.morphAttributes.position,
                    morphNormals: !!M.geometry && !!M.geometry.morphAttributes.normal,
                    morphTargetsCount: M.geometry && M.geometry.morphAttributes.position ? M.geometry.morphAttributes.position.length : 0,
                    numDirLights: c.directional.length,
                    numPointLights: c.point.length,
                    numSpotLights: c.spot.length,
                    numRectAreaLights: c.rectArea.length,
                    numHemiLights: c.hemi.length,
                    numDirLightShadows: c.directionalShadowMap.length,
                    numPointLightShadows: c.pointShadowMap.length,
                    numSpotLightShadows: c.spotShadowMap.length,
                    numClippingPlanes: l.numPlanes,
                    numClipIntersection: l.numIntersection,
                    format: a.format,
                    dithering: a.dithering,
                    shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                    shadowMapType: e.shadowMap.type,
                    toneMapping: a.toneMapped ? e.toneMapping : 0,
                    physicallyCorrectLights: e.physicallyCorrectLights,
                    premultipliedAlpha: a.premultipliedAlpha,
                    doubleSided: 2 === a.side,
                    flipSided: 1 === a.side,
                    depthPacking: void 0 !== a.depthPacking && a.depthPacking,
                    index0AttributeName: a.index0AttributeName,
                    extensionDerivatives: a.extensions && a.extensions.derivatives,
                    extensionFragDepth: a.extensions && a.extensions.fragDepth,
                    extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
                    extensionShaderTextureLOD: a.extensions && a.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: a.customProgramCacheKey()
                }
            },
            getProgramCacheKey: function(t) {
                const n = [];
                if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                    for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                return !1 === t.isRawShaderMaterial && (! function(e, t) {
                    e.push(t.precision), e.push(t.outputEncoding), e.push(t.mapEncoding), e.push(t.matcapEncoding), e.push(t.envMapMode), e.push(t.envMapEncoding), e.push(t.lightMapEncoding), e.push(t.emissiveMapEncoding), e.push(t.combine), e.push(t.vertexUvs), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.maxBones), e.push(t.morphTargetsCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.format), e.push(t.specularColorMapEncoding), e.push(t.sheenColorMapEncoding)
                }(n, t), function(e, t) {
                    c.disableAll(), t.isWebGL2 && c.enable(0);
                    t.supportsVertexTextures && c.enable(1);
                    t.instancing && c.enable(2);
                    t.instancingColor && c.enable(3);
                    t.map && c.enable(4);
                    t.matcap && c.enable(5);
                    t.envMap && c.enable(6);
                    t.envMapCubeUV && c.enable(7);
                    t.lightMap && c.enable(8);
                    t.aoMap && c.enable(9);
                    t.emissiveMap && c.enable(10);
                    t.bumpMap && c.enable(11);
                    t.normalMap && c.enable(12);
                    t.objectSpaceNormalMap && c.enable(13);
                    t.tangentSpaceNormalMap && c.enable(14);
                    t.clearcoat && c.enable(15);
                    t.clearcoatMap && c.enable(16);
                    t.clearcoatRoughnessMap && c.enable(17);
                    t.clearcoatNormalMap && c.enable(18);
                    t.displacementMap && c.enable(19);
                    t.specularMap && c.enable(20);
                    t.roughnessMap && c.enable(21);
                    t.metalnessMap && c.enable(22);
                    t.gradientMap && c.enable(23);
                    t.alphaMap && c.enable(24);
                    t.alphaTest && c.enable(25);
                    t.vertexColors && c.enable(26);
                    t.vertexAlphas && c.enable(27);
                    t.vertexUvs && c.enable(28);
                    t.vertexTangents && c.enable(29);
                    t.uvsVertexOnly && c.enable(30);
                    t.fog && c.enable(31);
                    e.push(c.mask), c.disableAll(), t.useFog && c.enable(0);
                    t.flatShading && c.enable(1);
                    t.logarithmicDepthBuffer && c.enable(2);
                    t.skinning && c.enable(3);
                    t.useVertexTexture && c.enable(4);
                    t.morphTargets && c.enable(5);
                    t.morphNormals && c.enable(6);
                    t.premultipliedAlpha && c.enable(7);
                    t.shadowMapEnabled && c.enable(8);
                    t.physicallyCorrectLights && c.enable(9);
                    t.doubleSided && c.enable(10);
                    t.flipSided && c.enable(11);
                    t.depthPacking && c.enable(12);
                    t.dithering && c.enable(13);
                    t.specularIntensityMap && c.enable(14);
                    t.specularColorMap && c.enable(15);
                    t.transmission && c.enable(16);
                    t.transmissionMap && c.enable(17);
                    t.thicknessMap && c.enable(18);
                    t.sheen && c.enable(19);
                    t.sheenColorMap && c.enable(20);
                    t.sheenRoughnessMap && c.enable(21);
                    e.push(c.mask)
                }(n, t), n.push(e.outputEncoding)), n.push(t.customProgramCacheKey), n.join()
            },
            getUniforms: function(e) {
                const t = x[e.type];
                let n;
                if (t) {
                    const e = bn[t];
                    n = It.clone(e.uniforms)
                } else n = e.uniforms;
                return n
            },
            acquireProgram: function(t, n) {
                let i;
                for (let e = 0, t = u.length; e < t; e++) {
                    const t = u[e];
                    if (t.cacheKey === n) {
                        i = t, ++i.usedTimes;
                        break
                    }
                }
                return void 0 === i && (i = new Yr(e, n, t, a), u.push(i)), i
            },
            releaseProgram: function(e) {
                if (0 == --e.usedTimes) {
                    const t = u.indexOf(e);
                    u[t] = u[u.length - 1], u.pop(), e.destroy()
                }
            },
            releaseShaderCache: function(e) {
                h.remove(e)
            },
            programs: u,
            dispose: function() {
                h.dispose()
            }
        }
    }

    function $r() {
        let e = new WeakMap;
        return {
            get: function(t) {
                let n = e.get(t);
                return void 0 === n && (n = {}, e.set(t, n)), n
            },
            remove: function(t) {
                e.delete(t)
            },
            update: function(t, n, i) {
                e.get(t)[n] = i
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }

    function ea(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function ta(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function na() {
        const e = [];
        let t = 0;
        const n = [],
            i = [],
            r = [];

        function a(n, i, r, a, s, o) {
            let l = e[t];
            return void 0 === l ? (l = {
                id: n.id,
                object: n,
                geometry: i,
                material: r,
                groupOrder: a,
                renderOrder: n.renderOrder,
                z: s,
                group: o
            }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = s, l.group = o), t++, l
        }
        return {
            opaque: n,
            transmissive: i,
            transparent: r,
            init: function() {
                t = 0, n.length = 0, i.length = 0, r.length = 0
            },
            push: function(e, t, s, o, l, c) {
                const h = a(e, t, s, o, l, c);
                s.transmission > 0 ? i.push(h) : !0 === s.transparent ? r.push(h) : n.push(h)
            },
            unshift: function(e, t, s, o, l, c) {
                const h = a(e, t, s, o, l, c);
                s.transmission > 0 ? i.unshift(h) : !0 === s.transparent ? r.unshift(h) : n.unshift(h)
            },
            finish: function() {
                for (let n = t, i = e.length; n < i; n++) {
                    const t = e[n];
                    if (null === t.id) break;
                    t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
                }
            },
            sort: function(e, t) {
                n.length > 1 && n.sort(e || ea), i.length > 1 && i.sort(t || ta), r.length > 1 && r.sort(t || ta)
            }
        }
    }

    function ia() {
        let e = new WeakMap;
        return {
            get: function(t, n) {
                let i;
                return !1 === e.has(t) ? (i = new na, e.set(t, [i])) : n >= e.get(t).length ? (i = new na, e.get(t).push(i)) : i = e.get(t)[n], i
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }

    function ra() {
        const e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id]) return e[t.id];
                let n;
                switch (t.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new J,
                            color: new qe
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new J,
                            direction: new J,
                            color: new qe,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new J,
                            color: new qe,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new J,
                            skyColor: new qe,
                            groundColor: new qe
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new qe,
                            position: new J,
                            halfWidth: new J,
                            halfHeight: new J
                        }
                }
                return e[t.id] = n, n
            }
        }
    }
    let aa = 0;

    function sa(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
    }

    function oa(e, t) {
        const n = new ra,
            i = function() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        let n;
                        switch (t.type) {
                            case "DirectionalLight":
                            case "SpotLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new ze
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new ze,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                        }
                        return e[t.id] = n, n
                    }
                }
            }(),
            r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };
        for (let e = 0; e < 9; e++) r.probe.push(new J);
        const a = new J,
            s = new Re,
            o = new Re;
        return {
            setup: function(a, s) {
                let o = 0,
                    l = 0,
                    c = 0;
                for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
                let h = 0,
                    u = 0,
                    d = 0,
                    p = 0,
                    m = 0,
                    f = 0,
                    g = 0,
                    _ = 0;
                a.sort(sa);
                const v = !0 !== s ? Math.PI : 1;
                for (let e = 0, t = a.length; e < t; e++) {
                    const t = a[e],
                        s = t.color,
                        x = t.intensity,
                        y = t.distance,
                        M = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                    if (t.isAmbientLight) o += s.r * x * v, l += s.g * x * v, c += s.b * x * v;
                    else if (t.isLightProbe)
                        for (let e = 0; e < 9; e++) r.probe[e].addScaledVector(t.sh.coefficients[e], x);
                    else if (t.isDirectionalLight) {
                        const e = n.get(t);
                        if (e.color.copy(t.color).multiplyScalar(t.intensity * v), t.castShadow) {
                            const e = t.shadow,
                                n = i.get(t);
                            n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[h] = n, r.directionalShadowMap[h] = M, r.directionalShadowMatrix[h] = t.shadow.matrix, f++
                        }
                        r.directional[h] = e, h++
                    } else if (t.isSpotLight) {
                        const e = n.get(t);
                        if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(s).multiplyScalar(x * v), e.distance = y, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
                            const e = t.shadow,
                                n = i.get(t);
                            n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.spotShadow[d] = n, r.spotShadowMap[d] = M, r.spotShadowMatrix[d] = t.shadow.matrix, _++
                        }
                        r.spot[d] = e, d++
                    } else if (t.isRectAreaLight) {
                        const e = n.get(t);
                        e.color.copy(s).multiplyScalar(x), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[p] = e, p++
                    } else if (t.isPointLight) {
                        const e = n.get(t);
                        if (e.color.copy(t.color).multiplyScalar(t.intensity * v), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                            const e = t.shadow,
                                n = i.get(t);
                            n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[u] = n, r.pointShadowMap[u] = M, r.pointShadowMatrix[u] = t.shadow.matrix, g++
                        }
                        r.point[u] = e, u++
                    } else if (t.isHemisphereLight) {
                        const e = n.get(t);
                        e.skyColor.copy(t.color).multiplyScalar(x * v), e.groundColor.copy(t.groundColor).multiplyScalar(x * v), r.hemi[m] = e, m++
                    }
                }
                p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Tn.LTC_FLOAT_1, r.rectAreaLTC2 = Tn.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Tn.LTC_HALF_1, r.rectAreaLTC2 = Tn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                const x = r.hash;
                x.directionalLength === h && x.pointLength === u && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === m && x.numDirectionalShadows === f && x.numPointShadows === g && x.numSpotShadows === _ || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = _, r.spotShadowMap.length = _, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = _, x.directionalLength = h, x.pointLength = u, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = m, x.numDirectionalShadows = f, x.numPointShadows = g, x.numSpotShadows = _, r.version = aa++)
            },
            setupView: function(e, t) {
                let n = 0,
                    i = 0,
                    l = 0,
                    c = 0,
                    h = 0;
                const u = t.matrixWorldInverse;
                for (let t = 0, d = e.length; t < d; t++) {
                    const d = e[t];
                    if (d.isDirectionalLight) {
                        const e = r.directional[n];
                        e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(u), n++
                    } else if (d.isSpotLight) {
                        const e = r.spot[l];
                        e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(u), l++
                    } else if (d.isRectAreaLight) {
                        const e = r.rectArea[c];
                        e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), o.identity(), s.copy(d.matrixWorld), s.premultiply(u), o.extractRotation(s), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++
                    } else if (d.isPointLight) {
                        const e = r.point[i];
                        e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), i++
                    } else if (d.isHemisphereLight) {
                        const e = r.hemi[h];
                        e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(u), e.direction.normalize(), h++
                    }
                }
            },
            state: r
        }
    }

    function la(e, t) {
        const n = new oa(e, t),
            i = [],
            r = [];
        return {
            init: function() {
                i.length = 0, r.length = 0
            },
            state: {
                lightsArray: i,
                shadowsArray: r,
                lights: n
            },
            setupLights: function(e) {
                n.setup(i, e)
            },
            setupLightsView: function(e) {
                n.setupView(i, e)
            },
            pushLight: function(e) {
                i.push(e)
            },
            pushShadow: function(e) {
                r.push(e)
            }
        }
    }

    function ca(e, t) {
        let n = new WeakMap;
        return {
            get: function(i, r = 0) {
                let a;
                return !1 === n.has(i) ? (a = new la(e, t), n.set(i, [a])) : r >= n.get(i).length ? (a = new la(e, t), n.get(i).push(a)) : a = n.get(i)[r], a
            },
            dispose: function() {
                n = new WeakMap
            }
        }
    }
    class ha extends Pt {
        constructor(e) {
            super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
        }
    }
    ha.prototype.isMeshDepthMaterial = !0;
    class ua extends Pt {
        constructor(e) {
            super(), this.type = "MeshDistanceMaterial", this.referencePosition = new J, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
        }
    }
    ua.prototype.isMeshDistanceMaterial = !0;

    function da(e, t, n) {
        let i = new Ae;
        const r = new ze,
            a = new ze,
            s = new Fe,
            o = new ha({
                depthPacking: 3201
            }),
            l = new ua,
            c = {},
            h = n.maxTextureSize,
            d = {
                0: 1,
                1: 0,
                2: 2
            },
            p = new Ut({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new ze
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n",
                fragmentShader: "\nuniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n\n#include <packing>\n\nvoid main() {\n\n\tconst float samples = float( VSM_SAMPLES );\n\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\n\t// This seems totally useless but it's a crazy work around for a Adreno compiler bug\n\t// float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\n\t\t#ifdef HORIZONTAL_PASS\n\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\n\t\t#else\n\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\n\t\t#endif\n\n\t}\n\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\n}\n"
            }),
            f = p.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const g = new At;
        g.setAttribute("position", new Ze(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        const _ = new yn(g, p),
            v = this;

        function x(n, i) {
            const r = t.update(_);
            p.defines.VSM_SAMPLES !== n.blurSamples && (p.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), p.uniforms.shadow_pass.value = n.map.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, r, p, _, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, r, f, _, null)
        }

        function y(t, n, i, r, a, s, h) {
            let u = null;
            const p = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
            if (u = void 0 !== p ? p : !0 === r.isPointLight ? l : o, e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
                const e = u.uuid,
                    t = i.uuid;
                let n = c[e];
                void 0 === n && (n = {}, c[e] = n);
                let r = n[t];
                void 0 === r && (r = u.clone(), n[t] = r), u = r
            }
            return u.visible = i.visible, u.wireframe = i.wireframe, u.side = 3 === h ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : d[i.side], u.alphaMap = i.alphaMap, u.alphaTest = i.alphaTest, u.clipShadows = i.clipShadows, u.clippingPlanes = i.clippingPlanes, u.clipIntersection = i.clipIntersection, u.displacementMap = i.displacementMap, u.displacementScale = i.displacementScale, u.displacementBias = i.displacementBias, u.wireframeLinewidth = i.wireframeLinewidth, u.linewidth = i.linewidth, !0 === r.isPointLight && !0 === u.isMeshDistanceMaterial && (u.referencePosition.setFromMatrixPosition(r.matrixWorld), u.nearDistance = a, u.farDistance = s), u
        }

        function M(n, r, a, s, o) {
            if (!1 === n.visible) return;
            if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                const i = t.update(n),
                    r = n.material;
                if (Array.isArray(r)) {
                    const t = i.groups;
                    for (let l = 0, c = t.length; l < c; l++) {
                        const c = t[l],
                            h = r[c.materialIndex];
                        if (h && h.visible) {
                            const t = y(n, 0, h, s, a.near, a.far, o);
                            e.renderBufferDirect(a, null, i, t, n, c)
                        }
                    }
                } else if (r.visible) {
                    const t = y(n, 0, r, s, a.near, a.far, o);
                    e.renderBufferDirect(a, null, i, t, n, null)
                }
            }
            const l = n.children;
            for (let e = 0, t = l.length; e < t; e++) M(l[e], r, a, s, o)
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(t, n, o) {
            if (!1 === v.enabled) return;
            if (!1 === v.autoUpdate && !1 === v.needsUpdate) return;
            if (0 === t.length) return;
            const l = e.getRenderTarget(),
                c = e.getActiveCubeFace(),
                d = e.getActiveMipmapLevel(),
                p = e.state;
            p.setBlending(0), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
            for (let l = 0, c = t.length; l < c; l++) {
                const c = t[l],
                    d = c.shadow;
                if (void 0 === d) {
                    console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                    continue
                }
                if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue;
                r.copy(d.mapSize);
                const f = d.getFrameExtents();
                if (r.multiply(f), a.copy(d.mapSize), (r.x > h || r.y > h) && (r.x > h && (a.x = Math.floor(h / f.x), r.x = a.x * f.x, d.mapSize.x = a.x), r.y > h && (a.y = Math.floor(h / f.y), r.y = a.y * f.y, d.mapSize.y = a.y)), null === d.map && !d.isPointLightShadow && 3 === this.type) {
                    const e = {
                        minFilter: m,
                        magFilter: m,
                        format: b
                    };
                    d.map = new In(r.x, r.y, e), d.map.texture.name = c.name + ".shadowMap", d.mapPass = new In(r.x, r.y, e), d.camera.updateProjectionMatrix()
                }
                if (null === d.map) {
                    const e = {
                        minFilter: u,
                        magFilter: u,
                        format: b
                    };
                    d.map = new In(r.x, r.y, e), d.map.texture.name = c.name + ".shadowMap", d.camera.updateProjectionMatrix()
                }
                e.setRenderTarget(d.map), e.clear();
                const g = d.getViewportCount();
                for (let e = 0; e < g; e++) {
                    const t = d.getViewport(e);
                    s.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w), p.viewport(s), d.updateMatrices(c, e), i = d.getFrustum(), M(n, o, d.camera, c, this.type)
                }
                d.isPointLightShadow || 3 !== this.type || x(d, o), d.needsUpdate = !1
            }
            v.needsUpdate = !1, e.setRenderTarget(l, c, d)
        }
    }

    function pa(e, n, i) {
        const r = i.isWebGL2;
        const a = new function() {
                let t = !1;
                const n = new Fe;
                let i = null;
                const r = new Fe(0, 0, 0, 0);
                return {
                    setMask: function(n) {
                        i === n || t || (e.colorMask(n, n, n, n), i = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t, i, a, s, o) {
                        !0 === o && (t *= s, i *= s, a *= s), n.set(t, i, a, s), !1 === r.equals(n) && (e.clearColor(t, i, a, s), r.copy(n))
                    },
                    reset: function() {
                        t = !1, i = null, r.set(-1, 0, 0, 0)
                    }
                }
            },
            s = new function() {
                let t = !1,
                    n = null,
                    i = null,
                    r = null;
                return {
                    setTest: function(t) {
                        t ? O(e.DEPTH_TEST) : B(e.DEPTH_TEST)
                    },
                    setMask: function(i) {
                        n === i || t || (e.depthMask(i), n = i)
                    },
                    setFunc: function(t) {
                        if (i !== t) {
                            if (t) switch (t) {
                                case 0:
                                    e.depthFunc(e.NEVER);
                                    break;
                                case 1:
                                    e.depthFunc(e.ALWAYS);
                                    break;
                                case 2:
                                    e.depthFunc(e.LESS);
                                    break;
                                case 3:
                                default:
                                    e.depthFunc(e.LEQUAL);
                                    break;
                                case 4:
                                    e.depthFunc(e.EQUAL);
                                    break;
                                case 5:
                                    e.depthFunc(e.GEQUAL);
                                    break;
                                case 6:
                                    e.depthFunc(e.GREATER);
                                    break;
                                case 7:
                                    e.depthFunc(e.NOTEQUAL)
                            } else e.depthFunc(e.LEQUAL);
                            i = t
                        }
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        r !== t && (e.clearDepth(t), r = t)
                    },
                    reset: function() {
                        t = !1, n = null, i = null, r = null
                    }
                }
            },
            o = new function() {
                let t = !1,
                    n = null,
                    i = null,
                    r = null,
                    a = null,
                    s = null,
                    o = null,
                    l = null,
                    c = null;
                return {
                    setTest: function(n) {
                        t || (n ? O(e.STENCIL_TEST) : B(e.STENCIL_TEST))
                    },
                    setMask: function(i) {
                        n === i || t || (e.stencilMask(i), n = i)
                    },
                    setFunc: function(t, n, s) {
                        i === t && r === n && a === s || (e.stencilFunc(t, n, s), i = t, r = n, a = s)
                    },
                    setOp: function(t, n, i) {
                        s === t && o === n && l === i || (e.stencilOp(t, n, i), s = t, o = n, l = i)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        c !== t && (e.clearStencil(t), c = t)
                    },
                    reset: function() {
                        t = !1, n = null, i = null, r = null, a = null, s = null, o = null, l = null, c = null
                    }
                }
            };
        let l = {},
            c = {},
            h = null,
            u = !1,
            d = null,
            p = null,
            m = null,
            f = null,
            g = null,
            _ = null,
            v = null,
            x = !1,
            y = null,
            M = null,
            S = null,
            T = null,
            b = null;
        const E = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let w = !1,
            A = 0;
        const R = e.getParameter(e.VERSION); - 1 !== R.indexOf("WebGL") ? (A = parseFloat(/^WebGL (\d)/.exec(R)[1]), w = A >= 1) : -1 !== R.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL ES (\d)/.exec(R)[1]), w = A >= 2);
        let L = null,
            C = {};
        const P = e.getParameter(e.SCISSOR_BOX),
            D = e.getParameter(e.VIEWPORT),
            N = (new Fe).fromArray(P),
            I = (new Fe).fromArray(D);

        function U(t, n, i) {
            const r = new Uint8Array(4),
                a = e.createTexture();
            e.bindTexture(t, a), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
            for (let t = 0; t < i; t++) e.texImage2D(n + t, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, r);
            return a
        }
        const F = {};

        function O(t) {
            !0 !== l[t] && (e.enable(t), l[t] = !0)
        }

        function B(t) {
            !1 !== l[t] && (e.disable(t), l[t] = !1)
        }
        F[e.TEXTURE_2D] = U(e.TEXTURE_2D, e.TEXTURE_2D, 1), F[e.TEXTURE_CUBE_MAP] = U(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), a.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), O(e.DEPTH_TEST), s.setFunc(3), V(!1), k(1), O(e.CULL_FACE), H(0);
        const z = {
            [t]: e.FUNC_ADD,
            101: e.FUNC_SUBTRACT,
            102: e.FUNC_REVERSE_SUBTRACT
        };
        if (r) z[103] = e.MIN, z[104] = e.MAX;
        else {
            const e = n.get("EXT_blend_minmax");
            null !== e && (z[103] = e.MIN_EXT, z[104] = e.MAX_EXT)
        }
        const G = {
            200: e.ZERO,
            201: e.ONE,
            202: e.SRC_COLOR,
            204: e.SRC_ALPHA,
            210: e.SRC_ALPHA_SATURATE,
            208: e.DST_COLOR,
            206: e.DST_ALPHA,
            203: e.ONE_MINUS_SRC_COLOR,
            205: e.ONE_MINUS_SRC_ALPHA,
            209: e.ONE_MINUS_DST_COLOR,
            207: e.ONE_MINUS_DST_ALPHA
        };

        function H(n, i, r, a, s, o, l, c) {
            if (0 !== n) {
                if (!1 === u && (O(e.BLEND), u = !0), 5 === n) s = s || i, o = o || r, l = l || a, i === p && s === g || (e.blendEquationSeparate(z[i], z[s]), p = i, g = s), r === m && a === f && o === _ && l === v || (e.blendFuncSeparate(G[r], G[a], G[o], G[l]), m = r, f = a, _ = o, v = l), d = n, x = null;
                else if (n !== d || c !== x) {
                    if (p === t && g === t || (e.blendEquation(e.FUNC_ADD), p = t, g = t), c) switch (n) {
                        case 1:
                            e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            e.blendFunc(e.ONE, e.ONE);
                            break;
                        case 3:
                            e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 4:
                            e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", n)
                    } else switch (n) {
                        case 1:
                            e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            e.blendFunc(e.SRC_ALPHA, e.ONE);
                            break;
                        case 3:
                            e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR);
                            break;
                        case 4:
                            e.blendFunc(e.ZERO, e.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", n)
                    }
                    m = null, f = null, _ = null, v = null, d = n, x = c
                }
            } else !0 === u && (B(e.BLEND), u = !1)
        }

        function V(t) {
            y !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), y = t)
        }

        function k(t) {
            0 !== t ? (O(e.CULL_FACE), t !== M && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : B(e.CULL_FACE), M = t
        }

        function W(t, n, i) {
            t ? (O(e.POLYGON_OFFSET_FILL), T === n && b === i || (e.polygonOffset(n, i), T = n, b = i)) : B(e.POLYGON_OFFSET_FILL)
        }

        function X(t) {
            void 0 === t && (t = e.TEXTURE0 + E - 1), L !== t && (e.activeTexture(t), L = t)
        }
        return {
            buffers: {
                color: a,
                depth: s,
                stencil: o
            },
            enable: O,
            disable: B,
            bindFramebuffer: function(t, n) {
                return c[t] !== n && (e.bindFramebuffer(t, n), c[t] = n, r && (t === e.DRAW_FRAMEBUFFER && (c[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (c[e.DRAW_FRAMEBUFFER] = n)), !0)
            },
            useProgram: function(t) {
                return h !== t && (e.useProgram(t), h = t, !0)
            },
            setBlending: H,
            setMaterial: function(t, n) {
                2 === t.side ? B(e.CULL_FACE) : O(e.CULL_FACE);
                let i = 1 === t.side;
                n && (i = !i), V(i), 1 === t.blending && !1 === t.transparent ? H(0) : H(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), a.setMask(t.colorWrite);
                const r = t.stencilWrite;
                o.setTest(r), r && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), W(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? O(e.SAMPLE_ALPHA_TO_COVERAGE) : B(e.SAMPLE_ALPHA_TO_COVERAGE)
            },
            setFlipSided: V,
            setCullFace: k,
            setLineWidth: function(t) {
                t !== S && (w && e.lineWidth(t), S = t)
            },
            setPolygonOffset: W,
            setScissorTest: function(t) {
                t ? O(e.SCISSOR_TEST) : B(e.SCISSOR_TEST)
            },
            activeTexture: X,
            bindTexture: function(t, n) {
                null === L && X();
                let i = C[L];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                }, C[L] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || F[t]), i.type = t, i.texture = n)
            },
            unbindTexture: function() {
                const t = C[L];
                void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage2D: function() {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage3D: function() {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texStorage2D: function() {
                try {
                    e.texStorage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texStorage3D: function() {
                try {
                    e.texStorage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texSubImage2D: function() {
                try {
                    e.texSubImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texSubImage3D: function() {
                try {
                    e.texSubImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            compressedTexSubImage2D: function() {
                try {
                    e.compressedTexSubImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            scissor: function(t) {
                !1 === N.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), N.copy(t))
            },
            viewport: function(t) {
                !1 === I.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), I.copy(t))
            },
            reset: function() {
                e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), !0 === r && (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), l = {}, L = null, C = {}, c = {}, h = null, u = !1, d = null, p = null, m = null, f = null, g = null, _ = null, v = null, x = !1, y = null, M = null, S = null, T = null, b = null, N.set(0, 0, e.canvas.width, e.canvas.height), I.set(0, 0, e.canvas.width, e.canvas.height), a.reset(), s.reset(), o.reset()
            }
        }
    }

    function ma(e, t, n, i, r, a, s) {
        const o = r.isWebGL2,
            _ = r.maxTextures,
            A = r.maxCubemapSize,
            R = r.maxTextureSize,
            L = r.maxSamples,
            C = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : void 0,
            P = new WeakMap;
        let D, N = !1;
        try {
            N = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
        } catch (e) {}

        function I(e, t) {
            return N ? new OffscreenCanvas(e, t) : xt("canvas")
        }

        function U(e, t, n, i) {
            let r = 1;
            if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    const i = t ? K : Math.floor,
                        a = i(r * e.width),
                        s = i(r * e.height);
                    void 0 === D && (D = I(a, s));
                    const o = n ? I(a, s) : D;
                    o.width = a, o.height = s;
                    return o.getContext("2d").drawImage(e, 0, 0, a, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + s + ")."), o
                }
                return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
            }
            return e
        }

        function F(e) {
            return Y(e.width) && Y(e.height)
        }

        function O(e, t) {
            return e.generateMipmaps && t && e.minFilter !== u && e.minFilter !== m
        }

        function z(t) {
            e.generateMipmap(t)
        }

        function G(n, i, r, a) {
            if (!1 === o) return i;
            if (null !== n) {
                if (void 0 !== e[n]) return e[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            let s = i;
            return i === e.RED && (r === e.FLOAT && (s = e.R32F), r === e.HALF_FLOAT && (s = e.R16F), r === e.UNSIGNED_BYTE && (s = e.R8)), i === e.RGB && (r === e.FLOAT && (s = e.RGB32F), r === e.HALF_FLOAT && (s = e.RGB16F), r === e.UNSIGNED_BYTE && (s = e.RGB8)), i === e.RGBA && (r === e.FLOAT && (s = e.RGBA32F), r === e.HALF_FLOAT && (s = e.RGBA16F), r === e.UNSIGNED_BYTE && (s = a === B ? e.SRGB8_ALPHA8 : e.RGBA8)), s !== e.R16F && s !== e.R32F && s !== e.RGBA16F && s !== e.RGBA32F || t.get("EXT_color_buffer_float"), s
        }

        function H(e, t, n) {
            return !0 === O(e, n) || e.isFramebufferTexture && e.minFilter !== u && e.minFilter !== m ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
        }

        function V(t) {
            return t === u || t === d || t === p ? e.NEAREST : e.LINEAR
        }

        function k(t) {
            const n = t.target;
            n.removeEventListener("dispose", k),
                function(t) {
                    const n = i.get(t);
                    if (void 0 === n.__webglInit) return;
                    e.deleteTexture(n.__webglTexture), i.remove(t)
                }(n), n.isVideoTexture && P.delete(n), s.memory.textures--
        }

        function W(t) {
            const n = t.target;
            n.removeEventListener("dispose", W),
                function(t) {
                    const n = t.texture,
                        r = i.get(t),
                        a = i.get(n);
                    if (!t) return;
                    void 0 !== a.__webglTexture && (e.deleteTexture(a.__webglTexture), s.memory.textures--);
                    t.depthTexture && t.depthTexture.dispose();
                    if (t.isWebGLCubeRenderTarget)
                        for (let t = 0; t < 6; t++) e.deleteFramebuffer(r.__webglFramebuffer[t]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]);
                    else e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && e.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                    if (t.isWebGLMultipleRenderTargets)
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = i.get(n[t]);
                            r.__webglTexture && (e.deleteTexture(r.__webglTexture), s.memory.textures--), i.remove(n[t])
                        }
                    i.remove(n), i.remove(t)
                }(n)
        }
        let X = 0;

        function j(t, r) {
            const a = i.get(t);
            if (t.isVideoTexture && function(e) {
                    const t = s.render.frame;
                    P.get(e) !== t && (P.set(e, t), e.update())
                }(t), t.version > 0 && a.__version !== t.version) {
                const e = t.image;
                if (void 0 === e) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== e.complete) return void ee(a, t, r);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_2D, a.__webglTexture)
        }

        function q(t, r) {
            const s = i.get(t);
            t.version > 0 && s.__version !== t.version ? function(t, i, r) {
                if (6 !== i.image.length) return;
                $(t, i), n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, i.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, i.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE);
                const s = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                    l = i.image[0] && i.image[0].isDataTexture,
                    c = [];
                for (let e = 0; e < 6; e++) c[e] = s || l ? l ? i.image[e].image : i.image[e] : U(i.image[e], !1, !0, A);
                const h = c[0],
                    u = F(h) || o,
                    d = a.convert(i.format),
                    p = a.convert(i.type),
                    m = G(i.internalFormat, d, p, i.encoding),
                    f = o && !0 !== i.isVideoTexture,
                    g = void 0 === t.__version;
                let _, v = H(i, h, u);
                if (Q(e.TEXTURE_CUBE_MAP, i, u), s) {
                    f && g && n.texStorage2D(e.TEXTURE_CUBE_MAP, v, m, h.width, h.height);
                    for (let t = 0; t < 6; t++) {
                        _ = c[t].mipmaps;
                        for (let r = 0; r < _.length; r++) {
                            const a = _[r];
                            i.format !== b && i.format !== T ? null !== d ? f ? n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, a.width, a.height, d, a.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, m, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : f ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, a.width, a.height, d, p, a.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, m, a.width, a.height, 0, d, p, a.data)
                        }
                    }
                } else {
                    _ = i.mipmaps, f && g && (_.length > 0 && v++, n.texStorage2D(e.TEXTURE_CUBE_MAP, v, m, c[0].width, c[0].height));
                    for (let t = 0; t < 6; t++)
                        if (l) {
                            f ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, c[t].width, c[t].height, d, p, c[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, m, c[t].width, c[t].height, 0, d, p, c[t].data);
                            for (let i = 0; i < _.length; i++) {
                                const r = _[i].image[t].image;
                                f ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, d, p, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, m, r.width, r.height, 0, d, p, r.data)
                            }
                        } else {
                            f ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, d, p, c[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, m, d, p, c[t]);
                            for (let i = 0; i < _.length; i++) {
                                const r = _[i];
                                f ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, d, p, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, m, d, p, r.image[t])
                            }
                        }
                }
                O(i, u) && z(e.TEXTURE_CUBE_MAP);
                t.__version = i.version, i.onUpdate && i.onUpdate(i)
            }(s, t, r) : (n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_CUBE_MAP, s.__webglTexture))
        }
        const Z = {
                [l]: e.REPEAT,
                [c]: e.CLAMP_TO_EDGE,
                [h]: e.MIRRORED_REPEAT
            },
            J = {
                [u]: e.NEAREST,
                [d]: e.NEAREST_MIPMAP_NEAREST,
                [p]: e.NEAREST_MIPMAP_LINEAR,
                [m]: e.LINEAR,
                [f]: e.LINEAR_MIPMAP_NEAREST,
                [g]: e.LINEAR_MIPMAP_LINEAR
            };

        function Q(n, a, s) {
            if (s ? (e.texParameteri(n, e.TEXTURE_WRAP_S, Z[a.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, Z[a.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, Z[a.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, J[a.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, J[a.minFilter])) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE), a.wrapS === c && a.wrapT === c || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, e.TEXTURE_MAG_FILTER, V(a.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, V(a.minFilter)), a.minFilter !== u && a.minFilter !== m && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
                const s = t.get("EXT_texture_filter_anisotropic");
                if (a.type === y && !1 === t.has("OES_texture_float_linear")) return;
                if (!1 === o && a.type === M && !1 === t.has("OES_texture_half_float_linear")) return;
                (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
            }
        }

        function $(t, n) {
            void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", k), t.__webglTexture = e.createTexture(), s.memory.textures++)
        }

        function ee(t, i, r) {
            let s = e.TEXTURE_2D;
            i.isDataTexture2DArray && (s = e.TEXTURE_2D_ARRAY), i.isDataTexture3D && (s = e.TEXTURE_3D), $(t, i), n.activeTexture(e.TEXTURE0 + r), n.bindTexture(s, t.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, i.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, i.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE);
            const l = function(e) {
                    return !o && (e.wrapS !== c || e.wrapT !== c || e.minFilter !== u && e.minFilter !== m)
                }(i) && !1 === F(i.image),
                h = U(i.image, l, !1, R),
                d = F(h) || o,
                p = a.convert(i.format);
            let f, g = a.convert(i.type),
                _ = G(i.internalFormat, p, g, i.encoding);
            Q(s, i, d);
            const M = i.mipmaps,
                A = o && !0 !== i.isVideoTexture,
                L = void 0 === t.__version,
                C = H(i, h, d);
            if (i.isDepthTexture) _ = e.DEPTH_COMPONENT, o ? _ = i.type === y ? e.DEPTH_COMPONENT32F : i.type === x ? e.DEPTH_COMPONENT24 : i.type === S ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT16 : i.type === y && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === E && _ === e.DEPTH_COMPONENT && i.type !== v && i.type !== x && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = v, g = a.convert(i.type)), i.format === w && _ === e.DEPTH_COMPONENT && (_ = e.DEPTH_STENCIL, i.type !== S && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = S, g = a.convert(i.type))), A && L ? n.texStorage2D(e.TEXTURE_2D, 1, _, h.width, h.height) : n.texImage2D(e.TEXTURE_2D, 0, _, h.width, h.height, 0, p, g, null);
            else if (i.isDataTexture)
                if (M.length > 0 && d) {
                    A && L && n.texStorage2D(e.TEXTURE_2D, C, _, M[0].width, M[0].height);
                    for (let t = 0, i = M.length; t < i; t++) f = M[t], A ? n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f.width, f.height, p, g, f.data) : n.texImage2D(e.TEXTURE_2D, t, _, f.width, f.height, 0, p, g, f.data);
                    i.generateMipmaps = !1
                } else A ? (L && n.texStorage2D(e.TEXTURE_2D, C, _, h.width, h.height), n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, h.width, h.height, p, g, h.data)) : n.texImage2D(e.TEXTURE_2D, 0, _, h.width, h.height, 0, p, g, h.data);
            else if (i.isCompressedTexture) {
                A && L && n.texStorage2D(e.TEXTURE_2D, C, _, M[0].width, M[0].height);
                for (let t = 0, r = M.length; t < r; t++) f = M[t], i.format !== b && i.format !== T ? null !== p ? A ? n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, f.width, f.height, p, f.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, _, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : A ? n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, f.width, f.height, p, g, f.data) : n.texImage2D(e.TEXTURE_2D, t, _, f.width, f.height, 0, p, g, f.data)
            } else if (i.isDataTexture2DArray) A ? (L && n.texStorage3D(e.TEXTURE_2D_ARRAY, C, _, h.width, h.height, h.depth), n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, h.width, h.height, h.depth, p, g, h.data)) : n.texImage3D(e.TEXTURE_2D_ARRAY, 0, _, h.width, h.height, h.depth, 0, p, g, h.data);
            else if (i.isDataTexture3D) A ? (L && n.texStorage3D(e.TEXTURE_3D, C, _, h.width, h.height, h.depth), n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, h.width, h.height, h.depth, p, g, h.data)) : n.texImage3D(e.TEXTURE_3D, 0, _, h.width, h.height, h.depth, 0, p, g, h.data);
            else if (i.isFramebufferTexture) A && L ? n.texStorage2D(e.TEXTURE_2D, C, _, h.width, h.height) : n.texImage2D(e.TEXTURE_2D, 0, _, h.width, h.height, 0, p, g, null);
            else if (M.length > 0 && d) {
                A && L && n.texStorage2D(e.TEXTURE_2D, C, _, M[0].width, M[0].height);
                for (let t = 0, i = M.length; t < i; t++) f = M[t], A ? n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, p, g, f) : n.texImage2D(e.TEXTURE_2D, t, _, p, g, f);
                i.generateMipmaps = !1
            } else A ? (L && n.texStorage2D(e.TEXTURE_2D, C, _, h.width, h.height), n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p, g, h)) : n.texImage2D(e.TEXTURE_2D, 0, _, p, g, h);
            O(i, d) && z(s), t.__version = i.version, i.onUpdate && i.onUpdate(i)
        }

        function te(t, r, s, o, l) {
            const c = a.convert(s.format),
                h = a.convert(s.type),
                u = G(s.internalFormat, c, h, s.encoding);
            i.get(r).__hasExternalTextures || (l === e.TEXTURE_3D || l === e.TEXTURE_2D_ARRAY ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(e.FRAMEBUFFER, t), r.useRenderToTexture ? C.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, o, l, i.get(s).__webglTexture, 0, re(r)) : e.framebufferTexture2D(e.FRAMEBUFFER, o, l, i.get(s).__webglTexture, 0), n.bindFramebuffer(e.FRAMEBUFFER, null)
        }

        function ne(t, n, i) {
            if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer) {
                let r = e.DEPTH_COMPONENT16;
                if (i || n.useRenderToTexture) {
                    const t = n.depthTexture;
                    t && t.isDepthTexture && (t.type === y ? r = e.DEPTH_COMPONENT32F : t.type === x && (r = e.DEPTH_COMPONENT24));
                    const i = re(n);
                    n.useRenderToTexture ? C.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, i, r, n.width, n.height) : e.renderbufferStorageMultisample(e.RENDERBUFFER, i, r, n.width, n.height)
                } else e.renderbufferStorage(e.RENDERBUFFER, r, n.width, n.height);
                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)
            } else if (n.depthBuffer && n.stencilBuffer) {
                const r = re(n);
                i && n.useRenderbuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r, e.DEPTH24_STENCIL8, n.width, n.height) : n.useRenderToTexture ? C.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, r, e.DEPTH24_STENCIL8, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)
            } else {
                const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                    r = a.convert(t.format),
                    s = a.convert(t.type),
                    o = G(t.internalFormat, r, s, t.encoding),
                    l = re(n);
                i && n.useRenderbuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, l, o, n.width, n.height) : n.useRenderToTexture ? C.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, l, o, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, o, n.width, n.height)
            }
            e.bindRenderbuffer(e.RENDERBUFFER, null)
        }

        function ie(t) {
            const r = i.get(t),
                a = !0 === t.isWebGLCubeRenderTarget;
            if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                if (a) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function(t, r) {
                    if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (n.bindFramebuffer(e.FRAMEBUFFER, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), j(r.depthTexture, 0);
                    const a = i.get(r.depthTexture).__webglTexture,
                        s = re(r);
                    if (r.depthTexture.format === E) r.useRenderToTexture ? C.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0, s) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0);
                    else {
                        if (r.depthTexture.format !== w) throw new Error("Unknown depthTexture format");
                        r.useRenderToTexture ? C.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0, s) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0)
                    }
                }(r.__webglFramebuffer, t)
            } else if (a) {
                r.__webglDepthbuffer = [];
                for (let i = 0; i < 6; i++) n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), ne(r.__webglDepthbuffer[i], t, !1)
            } else n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), ne(r.__webglDepthbuffer, t, !1);
            n.bindFramebuffer(e.FRAMEBUFFER, null)
        }

        function re(e) {
            return o && (e.useRenderbuffer || e.useRenderToTexture) ? Math.min(L, e.samples) : 0
        }
        let ae = !1,
            se = !1;
        this.allocateTextureUnit = function() {
            const e = X;
            return e >= _ && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + _), X += 1, e
        }, this.resetTextureUnits = function() {
            X = 0
        }, this.setTexture2D = j, this.setTexture2DArray = function(t, r) {
            const a = i.get(t);
            t.version > 0 && a.__version !== t.version ? ee(a, t, r) : (n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture))
        }, this.setTexture3D = function(t, r) {
            const a = i.get(t);
            t.version > 0 && a.__version !== t.version ? ee(a, t, r) : (n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_3D, a.__webglTexture))
        }, this.setTextureCube = q, this.rebindTextures = function(t, n, r) {
            const a = i.get(t);
            void 0 !== n && te(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D), void 0 !== r && ie(t)
        }, this.setupRenderTarget = function(t) {
            const l = t.texture,
                c = i.get(t),
                h = i.get(l);
            t.addEventListener("dispose", W), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = e.createTexture()), h.__version = l.version, s.memory.textures++);
            const u = !0 === t.isWebGLCubeRenderTarget,
                d = !0 === t.isWebGLMultipleRenderTargets,
                p = l.isDataTexture3D || l.isDataTexture2DArray,
                m = F(t) || o;
            if (!o || l.format !== T || l.type !== y && l.type !== M || (l.format = b, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) {
                c.__webglFramebuffer = [];
                for (let t = 0; t < 6; t++) c.__webglFramebuffer[t] = e.createFramebuffer()
            } else if (c.__webglFramebuffer = e.createFramebuffer(), d)
                if (r.drawBuffers) {
                    const n = t.texture;
                    for (let t = 0, r = n.length; t < r; t++) {
                        const r = i.get(n[t]);
                        void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(), s.memory.textures++)
                    }
                } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            else if (t.useRenderbuffer)
                if (o) {
                    c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, c.__webglColorRenderbuffer);
                    const i = a.convert(l.format),
                        r = a.convert(l.type),
                        s = G(l.internalFormat, i, r, l.encoding),
                        o = re(t);
                    e.renderbufferStorageMultisample(e.RENDERBUFFER, o, s, t.width, t.height), n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, c.__webglColorRenderbuffer), e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), ne(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (u) {
                n.bindTexture(e.TEXTURE_CUBE_MAP, h.__webglTexture), Q(e.TEXTURE_CUBE_MAP, l, m);
                for (let n = 0; n < 6; n++) te(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n);
                O(l, m) && z(e.TEXTURE_CUBE_MAP), n.unbindTexture()
            } else if (d) {
                const r = t.texture;
                for (let a = 0, s = r.length; a < s; a++) {
                    const s = r[a],
                        o = i.get(s);
                    n.bindTexture(e.TEXTURE_2D, o.__webglTexture), Q(e.TEXTURE_2D, s, m), te(c.__webglFramebuffer, t, s, e.COLOR_ATTACHMENT0 + a, e.TEXTURE_2D), O(s, m) && z(e.TEXTURE_2D)
                }
                n.unbindTexture()
            } else {
                let i = e.TEXTURE_2D;
                if (p)
                    if (o) {
                        i = l.isDataTexture3D ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY
                    } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                n.bindTexture(i, h.__webglTexture), Q(i, l, m), te(c.__webglFramebuffer, t, l, e.COLOR_ATTACHMENT0, i), O(l, m) && z(i), n.unbindTexture()
            }
            t.depthBuffer && ie(t)
        }, this.updateRenderTargetMipmap = function(t) {
            const r = F(t) || o,
                a = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
            for (let s = 0, o = a.length; s < o; s++) {
                const o = a[s];
                if (O(o, r)) {
                    const r = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D,
                        a = i.get(o).__webglTexture;
                    n.bindTexture(r, a), z(r), n.unbindTexture()
                }
            }
        }, this.updateMultisampleRenderTarget = function(t) {
            if (t.useRenderbuffer)
                if (o) {
                    const r = t.width,
                        a = t.height;
                    let s = e.COLOR_BUFFER_BIT;
                    const o = [e.COLOR_ATTACHMENT0],
                        l = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                    t.depthBuffer && o.push(l), t.ignoreDepthForMultisampleCopy || (t.depthBuffer && (s |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && (s |= e.STENCIL_BUFFER_BIT));
                    const c = i.get(t);
                    n.bindFramebuffer(e.READ_FRAMEBUFFER, c.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglFramebuffer), t.ignoreDepthForMultisampleCopy && (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [l]), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [l])), e.blitFramebuffer(0, 0, r, a, 0, 0, r, a, s, e.NEAREST), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, o), n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglMultisampledFramebuffer)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.setupDepthRenderbuffer = ie, this.setupFrameBufferTexture = te, this.safeSetTexture2D = function(e, t) {
            e && e.isWebGLRenderTarget && (!1 === ae && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), ae = !0), e = e.texture), j(e, t)
        }, this.safeSetTextureCube = function(e, t) {
            e && e.isWebGLCubeRenderTarget && (!1 === se && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), se = !0), e = e.texture), q(e, t)
        }
    }

    function fa(e, t, n) {
        const i = n.isWebGL2;
        return {
            convert: function(n) {
                let r;
                if (n === _) return e.UNSIGNED_BYTE;
                if (1017 === n) return e.UNSIGNED_SHORT_4_4_4_4;
                if (1018 === n) return e.UNSIGNED_SHORT_5_5_5_1;
                if (1019 === n) return e.UNSIGNED_SHORT_5_6_5;
                if (1010 === n) return e.BYTE;
                if (1011 === n) return e.SHORT;
                if (n === v) return e.UNSIGNED_SHORT;
                if (1013 === n) return e.INT;
                if (n === x) return e.UNSIGNED_INT;
                if (n === y) return e.FLOAT;
                if (n === M) return i ? e.HALF_FLOAT : (r = t.get("OES_texture_half_float"), null !== r ? r.HALF_FLOAT_OES : null);
                if (1021 === n) return e.ALPHA;
                if (n === T) return e.RGB;
                if (n === b) return e.RGBA;
                if (1024 === n) return e.LUMINANCE;
                if (1025 === n) return e.LUMINANCE_ALPHA;
                if (n === E) return e.DEPTH_COMPONENT;
                if (n === w) return e.DEPTH_STENCIL;
                if (1028 === n) return e.RED;
                if (1029 === n) return e.RED_INTEGER;
                if (1030 === n) return e.RG;
                if (1031 === n) return e.RG_INTEGER;
                if (1032 === n) return e.RGB_INTEGER;
                if (1033 === n) return e.RGBA_INTEGER;
                if (n === A || n === R || n === L || n === C) {
                    if (r = t.get("WEBGL_compressed_texture_s3tc"), null === r) return null;
                    if (n === A) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (n === R) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (n === L) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (n === C) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (n === P || n === D || n === N || n === I) {
                    if (r = t.get("WEBGL_compressed_texture_pvrtc"), null === r) return null;
                    if (n === P) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (n === D) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (n === N) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (n === I) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === n) return r = t.get("WEBGL_compressed_texture_etc1"), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((n === U || n === F) && (r = t.get("WEBGL_compressed_texture_etc"), null !== r)) {
                    if (n === U) return r.COMPRESSED_RGB8_ETC2;
                    if (n === F) return r.COMPRESSED_RGBA8_ETC2_EAC
                }
                return 37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n || 37840 === n || 37841 === n || 37842 === n || 37843 === n || 37844 === n || 37845 === n || 37846 === n || 37847 === n || 37848 === n || 37849 === n || 37850 === n || 37851 === n || 37852 === n || 37853 === n ? (r = t.get("WEBGL_compressed_texture_astc"), null !== r ? n : null) : 36492 === n ? (r = t.get("EXT_texture_compression_bptc"), null !== r ? n : null) : n === S ? i ? e.UNSIGNED_INT_24_8 : (r = t.get("WEBGL_depth_texture"), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
        }
    }
    class ga extends Fn {
        constructor(e = []) {
            super(), this.cameras = e
        }
    }
    ga.prototype.isArrayCamera = !0;
    class _a extends _t {
        constructor() {
            super(), this.type = "Group"
        }
    }
    _a.prototype.isGroup = !0;
    const va = {
        type: "move"
    };
    class xa {
        constructor() {
            this._targetRay = null, this._grip = null, this._hand = null
        }
        getHandSpace() {
            return null === this._hand && (this._hand = new _a, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                pinching: !1
            }), this._hand
        }
        getTargetRaySpace() {
            return null === this._targetRay && (this._targetRay = new _a, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new J, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new J), this._targetRay
        }
        getGripSpace() {
            return null === this._grip && (this._grip = new _a, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new J, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new J), this._grip
        }
        dispatchEvent(e) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
        }
        disconnect(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
        }
        update(e, t, n) {
            let i = null,
                r = null,
                a = null;
            const s = this._targetRay,
                o = this._grip,
                l = this._hand;
            if (e && "visible-blurred" !== t.session.visibilityState)
                if (null !== s && (i = t.getPose(e.targetRaySpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(va))), l && e.hand) {
                    a = !0;
                    for (const i of e.hand.values()) {
                        const e = t.getJointPose(i, n);
                        if (void 0 === l.joints[i.jointName]) {
                            const e = new _a;
                            e.matrixAutoUpdate = !1, e.visible = !1, l.joints[i.jointName] = e, l.add(e)
                        }
                        const r = l.joints[i.jointName];
                        null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = e.radius), r.visible = null !== e
                    }
                    const i = l.joints["index-finger-tip"],
                        r = l.joints["thumb-tip"],
                        s = i.position.distanceTo(r.position),
                        o = .02,
                        c = .005;
                    l.inputState.pinching && s > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }))
                } else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
            return null !== s && (s.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== a), this
        }
    }
    class ya extends Dn {
        constructor(e, t, n, i, r, a, s, o, l, c) {
            if ((c = void 0 !== c ? c : E) !== E && c !== w) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && c === E && (n = v), void 0 === n && c === w && (n = S), super(null, i, r, a, s, o, c, n, l), this.image = {
                width: e,
                height: t
            }, this.magFilter = void 0 !== s ? s : u, this.minFilter = void 0 !== o ? o : u, this.flipY = !1, this.generateMipmaps = !1
        }
    }
    ya.prototype.isDepthTexture = !0;
    class Ma extends Ge {
        constructor(e, t) {
            super();
            const n = this;
            let i = null,
                r = 1,
                a = null,
                s = "local-floor";
            const o = e.extensions.has("WEBGL_multisampled_render_to_texture");
            let l = null,
                c = null,
                h = null,
                u = null,
                d = !1,
                p = null;
            const m = t.getContextAttributes();
            let f = null,
                g = null;
            const x = [],
                y = new Map,
                M = new Fn;
            M.layers.enable(1), M.viewport = new Fe;
            const A = new Fn;
            A.layers.enable(2), A.viewport = new Fe;
            const R = [M, A],
                L = new ga;
            L.layers.enable(1), L.layers.enable(2);
            let C = null,
                P = null;

            function D(e) {
                const t = y.get(e.inputSource);
                t && t.dispatchEvent({
                    type: e.type,
                    data: e.inputSource
                })
            }

            function N() {
                y.forEach((function(e, t) {
                    e.disconnect(t)
                })), y.clear(), C = null, P = null, e.setRenderTarget(f), u = null, h = null, c = null, i = null, g = null, z.stop(), n.isPresenting = !1, n.dispatchEvent({
                    type: "sessionend"
                })
            }

            function I(e) {
                const t = i.inputSources;
                for (let e = 0; e < x.length; e++) y.set(t[e], x[e]);
                for (let t = 0; t < e.removed.length; t++) {
                    const n = e.removed[t],
                        i = y.get(n);
                    i && (i.dispatchEvent({
                        type: "disconnected",
                        data: n
                    }), y.delete(n))
                }
                for (let t = 0; t < e.added.length; t++) {
                    const n = e.added[t],
                        i = y.get(n);
                    i && i.dispatchEvent({
                        type: "connected",
                        data: n
                    })
                }
            }
            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                let t = x[e];
                return void 0 === t && (t = new xa, x[e] = t), t.getTargetRaySpace()
            }, this.getControllerGrip = function(e) {
                let t = x[e];
                return void 0 === t && (t = new xa, x[e] = t), t.getGripSpace()
            }, this.getHand = function(e) {
                let t = x[e];
                return void 0 === t && (t = new xa, x[e] = t), t.getHandSpace()
            }, this.setFramebufferScaleFactor = function(e) {
                r = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }, this.setReferenceSpaceType = function(e) {
                s = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }, this.getReferenceSpace = function() {
                return a
            }, this.getBaseLayer = function() {
                return null !== h ? h : u
            }, this.getBinding = function() {
                return c
            }, this.getFrame = function() {
                return p
            }, this.getSession = function() {
                return i
            }, this.setSession = async function(l) {
                if (i = l, null !== i) {
                    if (f = e.getRenderTarget(), i.addEventListener("select", D), i.addEventListener("selectstart", D), i.addEventListener("selectend", D), i.addEventListener("squeeze", D), i.addEventListener("squeezestart", D), i.addEventListener("squeezeend", D), i.addEventListener("end", N), i.addEventListener("inputsourceschange", I), !0 !== m.xrCompatible && await t.makeXRCompatible(), void 0 === i.renderState.layers || !1 === e.capabilities.isWebGL2) {
                        const n = {
                            antialias: void 0 !== i.renderState.layers || m.antialias,
                            alpha: m.alpha,
                            depth: m.depth,
                            stencil: m.stencil,
                            framebufferScaleFactor: r
                        };
                        u = new XRWebGLLayer(i, t, n), i.updateRenderState({
                            baseLayer: u
                        }), g = new In(u.framebufferWidth, u.framebufferHeight, {
                            format: b,
                            type: _,
                            encoding: e.outputEncoding
                        })
                    } else {
                        d = m.antialias;
                        let n = null,
                            a = null,
                            s = null;
                        m.depth && (s = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = m.stencil ? w : E, a = m.stencil ? S : v);
                        const l = {
                            colorFormat: m.alpha || d ? t.RGBA8 : t.RGB8,
                            depthFormat: s,
                            scaleFactor: r
                        };
                        c = new XRWebGLBinding(i, t), h = c.createProjectionLayer(l), i.updateRenderState({
                            layers: [h]
                        }), g = d ? new Si(h.textureWidth, h.textureHeight, {
                            format: b,
                            type: _,
                            depthTexture: new ya(h.textureWidth, h.textureHeight, a, void 0, void 0, void 0, void 0, void 0, void 0, n),
                            stencilBuffer: m.stencil,
                            ignoreDepth: h.ignoreDepthValues,
                            useRenderToTexture: o,
                            encoding: e.outputEncoding
                        }) : new In(h.textureWidth, h.textureHeight, {
                            format: m.alpha ? b : T,
                            type: _,
                            depthTexture: new ya(h.textureWidth, h.textureHeight, a, void 0, void 0, void 0, void 0, void 0, void 0, n),
                            stencilBuffer: m.stencil,
                            ignoreDepth: h.ignoreDepthValues,
                            encoding: e.outputEncoding
                        })
                    }
                    this.setFoveation(1), a = await i.requestReferenceSpace(s), z.setContext(i), z.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    })
                }
            };
            const U = new J,
                F = new J;

            function O(e, t) {
                null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
            }
            this.updateCamera = function(e) {
                if (null === i) return;
                L.near = A.near = M.near = e.near, L.far = A.far = M.far = e.far, C === L.near && P === L.far || (i.updateRenderState({
                    depthNear: L.near,
                    depthFar: L.far
                }), C = L.near, P = L.far);
                const t = e.parent,
                    n = L.cameras;
                O(L, t);
                for (let e = 0; e < n.length; e++) O(n[e], t);
                L.matrixWorld.decompose(L.position, L.quaternion, L.scale), e.position.copy(L.position), e.quaternion.copy(L.quaternion), e.scale.copy(L.scale), e.matrix.copy(L.matrix), e.matrixWorld.copy(L.matrixWorld);
                const r = e.children;
                for (let e = 0, t = r.length; e < t; e++) r[e].updateMatrixWorld(!0);
                2 === n.length ? function(e, t, n) {
                    U.setFromMatrixPosition(t.matrixWorld), F.setFromMatrixPosition(n.matrixWorld);
                    const i = U.distanceTo(F),
                        r = t.projectionMatrix.elements,
                        a = n.projectionMatrix.elements,
                        s = r[14] / (r[10] - 1),
                        o = r[14] / (r[10] + 1),
                        l = (r[9] + 1) / r[5],
                        c = (r[9] - 1) / r[5],
                        h = (r[8] - 1) / r[0],
                        u = (a[8] + 1) / a[0],
                        d = s * h,
                        p = s * u,
                        m = i / (-h + u),
                        f = m * -h;
                    t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(f), e.translateZ(m), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                    const g = s + m,
                        _ = o + m,
                        v = d - f,
                        x = p + (i - f),
                        y = l * o / _ * g,
                        M = c * o / _ * g;
                    e.projectionMatrix.makePerspective(v, x, y, M, g, _)
                }(L, M, A) : L.projectionMatrix.copy(M.projectionMatrix)
            }, this.getCamera = function() {
                return L
            }, this.getFoveation = function() {
                return null !== h ? h.fixedFoveation : null !== u ? u.fixedFoveation : void 0
            }, this.setFoveation = function(e) {
                null !== h && (h.fixedFoveation = e), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e)
            };
            let B = null;
            const z = new Oe;
            z.setAnimationLoop((function(t, n) {
                if (l = n.getViewerPose(a), p = n, null !== l) {
                    const t = l.views;
                    null !== u && (e.setRenderTargetFramebuffer(g, u.framebuffer), e.setRenderTarget(g));
                    let n = !1;
                    t.length !== L.cameras.length && (L.cameras.length = 0, n = !0);
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        let a = null;
                        if (null !== u) a = u.getViewport(r);
                        else {
                            const t = c.getViewSubImage(h, r);
                            a = t.viewport, 0 === i && (e.setRenderTargetTextures(g, t.colorTexture, h.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(g))
                        }
                        const s = R[i];
                        s.matrix.fromArray(r.transform.matrix), s.projectionMatrix.fromArray(r.projectionMatrix), s.viewport.set(a.x, a.y, a.width, a.height), 0 === i && L.matrix.copy(s.matrix), !0 === n && L.cameras.push(s)
                    }
                }
                const r = i.inputSources;
                for (let e = 0; e < x.length; e++) {
                    const t = x[e],
                        i = r[e];
                    t.update(i, n, a)
                }
                B && B(t, n), p = null
            })), this.setAnimationLoop = function(e) {
                B = e
            }, this.dispose = function() {}
        }
    }

    function Sa(e) {
        function t(t, n) {
            t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
            const i = e.get(n).envMap;
            let r, a;
            i && (t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.ior.value = n.ior, t.refractionRatio.value = n.refractionRatio), n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), t.uv2Transform.value.copy(a.matrix))
        }

        function n(t, n) {
            t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, 1 === n.side && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), 1 === n.side && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias);
            e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
        }
        return {
            refreshFogUniforms: function(e, t) {
                e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            },
            refreshMaterialUniforms: function(e, i, r, a, s) {
                i.isMeshBasicMaterial ? t(e, i) : i.isMeshLambertMaterial ? (t(e, i), function(e, t) {
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                }(e, i)) : i.isMeshToonMaterial ? (t(e, i), function(e, t) {
                    t.gradientMap && (e.gradientMap.value = t.gradientMap);
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshPhongMaterial ? (t(e, i), function(e, t) {
                    e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshStandardMaterial ? (t(e, i), i.isMeshPhysicalMaterial ? function(e, t, i) {
                    n(e, t), e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap));
                    t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, 1 === t.side && e.clearcoatNormalScale.value.negate()));
                    t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor));
                    e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap);
                    t.specularColorMap && (e.specularColorMap.value = t.specularColorMap)
                }(e, i, s) : n(e, i)) : i.isMeshMatcapMaterial ? (t(e, i), function(e, t) {
                    t.matcap && (e.matcap.value = t.matcap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshDepthMaterial ? (t(e, i), function(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshDistanceMaterial ? (t(e, i), function(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                    e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                }(e, i)) : i.isMeshNormalMaterial ? (t(e, i), function(e, t) {
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isLineBasicMaterial ? (function(e, t) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
                }(e, i), i.isLineDashedMaterial && function(e, t) {
                    e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                }(e, i)) : i.isPointsMaterial ? function(e, t, n, i) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * i, t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                    let r;
                    t.map ? r = t.map : t.alphaMap && (r = t.alphaMap);
                    void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix))
                }(e, i, r, a) : i.isSpriteMaterial ? function(e, t) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                    let n;
                    t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
            }
        }
    }

    function Ta(e = {}) {
        const t = void 0 !== e.canvas ? e.canvas : function() {
                const e = xt("canvas");
                return e.style.display = "block", e
            }(),
            n = void 0 !== e.context ? e.context : null,
            i = void 0 !== e.alpha && e.alpha,
            r = void 0 === e.depth || e.depth,
            a = void 0 === e.stencil || e.stencil,
            s = void 0 !== e.antialias && e.antialias,
            o = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            h = void 0 !== e.powerPreference ? e.powerPreference : "default",
            d = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
        let p = null,
            m = null;
        const f = [],
            v = [];
        this.domElement = t, this.debug = {
            checkShaderErrors: !0
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = O, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
        const x = this;
        let S = !1,
            T = 0,
            E = 0,
            w = null,
            A = -1,
            R = null;
        const L = new Fe,
            C = new Fe;
        let P = null,
            D = t.width,
            N = t.height,
            I = 1,
            U = null,
            F = null;
        const B = new Fe(0, 0, D, N),
            z = new Fe(0, 0, D, N);
        let G = !1;
        const H = [],
            V = new Ae;
        let k = !1,
            W = !1,
            X = null;
        const j = new Re,
            q = new J,
            Y = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };

        function K() {
            return null === w ? I : 1
        }
        let Z, Q, $, ee, te, ne, ie, re, ae, se, oe, le, ce, he, ue, de, pe, me, fe, ge, _e, ve, xe, ye = n;

        function Me(e, n) {
            for (let i = 0; i < e.length; i++) {
                const r = e[i],
                    a = t.getContext(r, n);
                if (null !== a) return a
            }
            return null
        }
        try {
            const e = {
                alpha: i,
                depth: r,
                stencil: a,
                antialias: s,
                premultipliedAlpha: o,
                preserveDrawingBuffer: l,
                powerPreference: h,
                failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute" in t && t.setAttribute("data-engine", "three.js r136"), t.addEventListener("webglcontextlost", be, !1), t.addEventListener("webglcontextrestored", Ee, !1), null === ye) {
                const t = ["webgl2", "webgl", "experimental-webgl"];
                if (!0 === x.isWebGL1Renderer && t.shift(), ye = Me(t, e), null === ye) throw Me(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            void 0 === ye.getShaderPrecisionFormat && (ye.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message), e
        }

        function Se() {
            Z = new pi(ye), Q = new Rn(ye, Z, e), Z.init(Q), ve = new fa(ye, Z, Q), $ = new pa(ye, Z, Q), H[0] = ye.BACK, ee = new gi(ye), te = new $r, ne = new ma(ye, Z, $, te, Q, ve, ee), ie = new Hn(x), re = new di(x), ae = new Be(ye, Q), xe = new wn(ye, Z, ae, Q), se = new mi(ye, ae, ee, xe), oe = new Ti(ye, se, ae, ee), fe = new Mi(ye, Q, ne), de = new Ln(te), le = new Qr(x, ie, re, Z, Q, xe, de), ce = new Sa(te), he = new ia, ue = new ca(Z, Q), me = new En(x, ie, $, oe, o), pe = new da(x, oe, Q), ge = new An(ye, Z, ee, Q), _e = new fi(ye, Z, ee, Q), ee.programs = le.programs, x.capabilities = Q, x.extensions = Z, x.properties = te, x.renderLists = he, x.shadowMap = pe, x.state = $, x.info = ee
        }
        Se();
        const Te = new Ma(x, ye);

        function be(e) {
            e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), S = !0
        }

        function Ee() {
            console.log("THREE.WebGLRenderer: Context Restored."), S = !1;
            const e = ee.autoReset,
                t = pe.enabled,
                n = pe.autoUpdate,
                i = pe.needsUpdate,
                r = pe.type;
            Se(), ee.autoReset = e, pe.enabled = t, pe.autoUpdate = n, pe.needsUpdate = i, pe.type = r
        }

        function we(e) {
            const t = e.target;
            t.removeEventListener("dispose", we),
                function(e) {
                    (function(e) {
                        const t = te.get(e).programs;
                        void 0 !== t && (t.forEach((function(e) {
                            le.releaseProgram(e)
                        })), e.isShaderMaterial && le.releaseShaderCache(e))
                    })(e), te.remove(e)
                }(t)
        }
        this.xr = Te, this.getContext = function() {
            return ye
        }, this.getContextAttributes = function() {
            return ye.getContextAttributes()
        }, this.forceContextLoss = function() {
            const e = Z.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.forceContextRestore = function() {
            const e = Z.get("WEBGL_lose_context");
            e && e.restoreContext()
        }, this.getPixelRatio = function() {
            return I
        }, this.setPixelRatio = function(e) {
            void 0 !== e && (I = e, this.setSize(D, N, !1))
        }, this.getSize = function(e) {
            return e.set(D, N)
        }, this.setSize = function(e, n, i) {
            Te.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (D = e, N = n, t.width = Math.floor(e * I), t.height = Math.floor(n * I), !1 !== i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
        }, this.getDrawingBufferSize = function(e) {
            return e.set(D * I, N * I).floor()
        }, this.setDrawingBufferSize = function(e, n, i) {
            D = e, N = n, I = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n)
        }, this.getCurrentViewport = function(e) {
            return e.copy(L)
        }, this.getViewport = function(e) {
            return e.copy(B)
        }, this.setViewport = function(e, t, n, i) {
            e.isVector4 ? B.set(e.x, e.y, e.z, e.w) : B.set(e, t, n, i), $.viewport(L.copy(B).multiplyScalar(I).floor())
        }, this.getScissor = function(e) {
            return e.copy(z)
        }, this.setScissor = function(e, t, n, i) {
            e.isVector4 ? z.set(e.x, e.y, e.z, e.w) : z.set(e, t, n, i), $.scissor(C.copy(z).multiplyScalar(I).floor())
        }, this.getScissorTest = function() {
            return G
        }, this.setScissorTest = function(e) {
            $.setScissorTest(G = e)
        }, this.setOpaqueSort = function(e) {
            U = e
        }, this.setTransparentSort = function(e) {
            F = e
        }, this.getClearColor = function(e) {
            return e.copy(me.getClearColor())
        }, this.setClearColor = function() {
            me.setClearColor.apply(me, arguments)
        }, this.getClearAlpha = function() {
            return me.getClearAlpha()
        }, this.setClearAlpha = function() {
            me.setClearAlpha.apply(me, arguments)
        }, this.clear = function(e, t, n) {
            let i = 0;
            (void 0 === e || e) && (i |= ye.COLOR_BUFFER_BIT), (void 0 === t || t) && (i |= ye.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= ye.STENCIL_BUFFER_BIT), ye.clear(i)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            t.removeEventListener("webglcontextlost", be, !1), t.removeEventListener("webglcontextrestored", Ee, !1), he.dispose(), ue.dispose(), te.dispose(), ie.dispose(), re.dispose(), oe.dispose(), xe.dispose(), le.dispose(), Te.dispose(), Te.removeEventListener("sessionstart", Ce), Te.removeEventListener("sessionend", Pe), X && (X.dispose(), X = null), De.stop()
        }, this.renderBufferDirect = function(e, t, n, i, r, a) {
            null === t && (t = Y);
            const s = r.isMesh && r.matrixWorld.determinant() < 0,
                o = function(e, t, n, i, r) {
                    !0 !== t.isScene && (t = Y);
                    ne.resetTextureUnits();
                    const a = t.fog,
                        s = i.isMeshStandardMaterial ? t.environment : null,
                        o = null === w ? x.outputEncoding : w.texture.encoding,
                        l = (i.isMeshStandardMaterial ? re : ie).get(i.envMap || s),
                        c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                        h = !!i.normalMap && !!n.attributes.tangent,
                        u = !!n.morphAttributes.position,
                        d = !!n.morphAttributes.normal,
                        p = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
                        f = i.toneMapped ? x.toneMapping : 0,
                        g = te.get(i),
                        _ = m.state.lights;
                    if (!0 === k && (!0 === W || e !== R)) {
                        const t = e === R && i.id === A;
                        de.setState(i, e, t)
                    }
                    let v = !1;
                    i.version === g.__version ? g.needsLights && g.lightsStateVersion !== _.state.version || g.outputEncoding !== o || r.isInstancedMesh && !1 === g.instancing ? v = !0 : r.isInstancedMesh || !0 !== g.instancing ? r.isSkinnedMesh && !1 === g.skinning ? v = !0 : r.isSkinnedMesh || !0 !== g.skinning ? g.envMap !== l || i.fog && g.fog !== a ? v = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === de.numPlanes && g.numIntersection === de.numIntersection ? (g.vertexAlphas !== c || g.vertexTangents !== h || g.morphTargets !== u || g.morphNormals !== d || g.toneMapping !== f || !0 === Q.isWebGL2 && g.morphTargetsCount !== p) && (v = !0) : v = !0 : v = !0 : v = !0 : (v = !0, g.__version = i.version);
                    let y = g.currentProgram;
                    !0 === v && (y = Ge(i, t, r));
                    let M = !1,
                        S = !1,
                        T = !1;
                    const b = y.getUniforms(),
                        E = g.uniforms;
                    $.useProgram(y.program) && (M = !0, S = !0, T = !0);
                    i.id !== A && (A = i.id, S = !0);
                    if (M || R !== e) {
                        if (b.setValue(ye, "projectionMatrix", e.projectionMatrix), Q.logarithmicDepthBuffer && b.setValue(ye, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), R !== e && (R = e, S = !0, T = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                            const t = b.map.cameraPosition;
                            void 0 !== t && t.setValue(ye, q.setFromMatrixPosition(e.matrixWorld))
                        }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && b.setValue(ye, "isOrthographic", !0 === e.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && b.setValue(ye, "viewMatrix", e.matrixWorldInverse)
                    }
                    if (r.isSkinnedMesh) {
                        b.setOptional(ye, r, "bindMatrix"), b.setOptional(ye, r, "bindMatrixInverse");
                        const e = r.skeleton;
                        e && (Q.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), b.setValue(ye, "boneTexture", e.boneTexture, ne), b.setValue(ye, "boneTextureSize", e.boneTextureSize)) : b.setOptional(ye, e, "boneMatrices"))
                    }!n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || fe.update(r, n, i, y);
                    (S || g.receiveShadow !== r.receiveShadow) && (g.receiveShadow = r.receiveShadow, b.setValue(ye, "receiveShadow", r.receiveShadow));
                    S && (b.setValue(ye, "toneMappingExposure", x.toneMappingExposure), g.needsLights && (C = T, (L = E).ambientLightColor.needsUpdate = C, L.lightProbe.needsUpdate = C, L.directionalLights.needsUpdate = C, L.directionalLightShadows.needsUpdate = C, L.pointLights.needsUpdate = C, L.pointLightShadows.needsUpdate = C, L.spotLights.needsUpdate = C, L.spotLightShadows.needsUpdate = C, L.rectAreaLights.needsUpdate = C, L.hemisphereLights.needsUpdate = C), a && i.fog && ce.refreshFogUniforms(E, a), ce.refreshMaterialUniforms(E, i, I, N, X), Rr.upload(ye, g.uniformsList, E, ne));
                    var L, C;
                    i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Rr.upload(ye, g.uniformsList, E, ne), i.uniformsNeedUpdate = !1);
                    i.isSpriteMaterial && b.setValue(ye, "center", r.center);
                    return b.setValue(ye, "modelViewMatrix", r.modelViewMatrix), b.setValue(ye, "normalMatrix", r.normalMatrix), b.setValue(ye, "modelMatrix", r.matrixWorld), y
                }(e, t, n, i, r);
            $.setMaterial(i, s);
            let l = n.index;
            const c = n.attributes.position;
            if (null === l) {
                if (void 0 === c || 0 === c.count) return
            } else if (0 === l.count) return;
            let h, u = 1;
            !0 === i.wireframe && (l = se.getWireframeAttribute(n), u = 2), xe.setup(r, i, o, n, l);
            let d = ge;
            null !== l && (h = ae.get(l), d = _e, d.setIndex(h));
            const p = null !== l ? l.count : c.count,
                f = n.drawRange.start * u,
                g = n.drawRange.count * u,
                _ = null !== a ? a.start * u : 0,
                v = null !== a ? a.count * u : 1 / 0,
                y = Math.max(f, _),
                M = Math.min(p, f + g, _ + v) - 1,
                S = Math.max(0, M - y + 1);
            if (0 !== S) {
                if (r.isMesh) !0 === i.wireframe ? ($.setLineWidth(i.wireframeLinewidth * K()), d.setMode(ye.LINES)) : d.setMode(ye.TRIANGLES);
                else if (r.isLine) {
                    let e = i.linewidth;
                    void 0 === e && (e = 1), $.setLineWidth(e * K()), r.isLineSegments ? d.setMode(ye.LINES) : r.isLineLoop ? d.setMode(ye.LINE_LOOP) : d.setMode(ye.LINE_STRIP)
                } else r.isPoints ? d.setMode(ye.POINTS) : r.isSprite && d.setMode(ye.TRIANGLES);
                if (r.isInstancedMesh) d.renderInstances(y, S, r.count);
                else if (n.isInstancedBufferGeometry) {
                    const e = Math.min(n.instanceCount, n._maxInstanceCount);
                    d.renderInstances(y, S, e)
                } else d.render(y, S)
            }
        }, this.compile = function(e, t) {
            m = ue.get(e), m.init(), v.push(m), e.traverseVisible((function(e) {
                e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e))
            })), m.setupLights(x.physicallyCorrectLights), e.traverse((function(t) {
                const n = t.material;
                if (n)
                    if (Array.isArray(n))
                        for (let i = 0; i < n.length; i++) {
                            Ge(n[i], e, t)
                        } else Ge(n, e, t)
            })), v.pop(), m = null
        };
        let Le = null;

        function Ce() {
            De.stop()
        }

        function Pe() {
            De.start()
        }
        const De = new Oe;

        function Ne(e, t, n, i) {
            if (!1 === e.visible) return;
            if (e.layers.test(t.layers))
                if (e.isGroup) n = e.renderOrder;
                else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
            else if (e.isLight) m.pushLight(e), e.castShadow && m.pushShadow(e);
            else if (e.isSprite) {
                if (!e.frustumCulled || V.intersectsSprite(e)) {
                    i && q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(j);
                    const t = oe.update(e),
                        r = e.material;
                    r.visible && p.push(e, t, r, n, q.z, null)
                }
            } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== ee.render.frame && (e.skeleton.update(), e.skeleton.frame = ee.render.frame), !e.frustumCulled || V.intersectsObject(e))) {
                i && q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(j);
                const t = oe.update(e),
                    r = e.material;
                if (Array.isArray(r)) {
                    const i = t.groups;
                    for (let a = 0, s = i.length; a < s; a++) {
                        const s = i[a],
                            o = r[s.materialIndex];
                        o && o.visible && p.push(e, t, o, n, q.z, s)
                    }
                } else r.visible && p.push(e, t, r, n, q.z, null)
            }
            const r = e.children;
            for (let e = 0, a = r.length; e < a; e++) Ne(r[e], t, n, i)
        }

        function Ie(e, t, n, i) {
            const r = e.opaque,
                a = e.transmissive,
                o = e.transparent;
            m.setupLightsView(n), a.length > 0 && function(e, t, n) {
                if (null === X) {
                    const e = !0 === s && !0 === Q.isWebGL2;
                    X = new(e ? Si : In)(1024, 1024, {
                        generateMipmaps: !0,
                        type: null !== ve.convert(M) ? M : _,
                        minFilter: g,
                        magFilter: u,
                        wrapS: c,
                        wrapT: c,
                        useRenderToTexture: Z.has("WEBGL_multisampled_render_to_texture")
                    })
                }
                const i = x.getRenderTarget();
                x.setRenderTarget(X), x.clear();
                const r = x.toneMapping;
                x.toneMapping = 0, Ue(e, t, n), x.toneMapping = r, ne.updateMultisampleRenderTarget(X), ne.updateRenderTargetMipmap(X), x.setRenderTarget(i)
            }(r, t, n), i && $.viewport(L.copy(i)), r.length > 0 && Ue(r, t, n), a.length > 0 && Ue(a, t, n), o.length > 0 && Ue(o, t, n)
        }

        function Ue(e, t, n) {
            const i = !0 === t.isScene ? t.overrideMaterial : null;
            for (let r = 0, a = e.length; r < a; r++) {
                const a = e[r],
                    s = a.object,
                    o = a.geometry,
                    l = null === i ? a.material : i,
                    c = a.group;
                s.layers.test(n.layers) && ze(s, t, n, o, l, c)
            }
        }

        function ze(e, t, n, i, r, a) {
            e.onBeforeRender(x, t, n, i, r, a), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(x, t, n, i, e, a), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, x.renderBufferDirect(n, t, i, r, e, a), r.side = 0, r.needsUpdate = !0, x.renderBufferDirect(n, t, i, r, e, a), r.side = 2) : x.renderBufferDirect(n, t, i, r, e, a), e.onAfterRender(x, t, n, i, r, a)
        }

        function Ge(e, t, n) {
            !0 !== t.isScene && (t = Y);
            const i = te.get(e),
                r = m.state.lights,
                a = m.state.shadowsArray,
                s = r.state.version,
                o = le.getParameters(e, r.state, a, t, n),
                l = le.getProgramCacheKey(o);
            let c = i.programs;
            i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? re : ie).get(e.envMap || i.environment), void 0 === c && (e.addEventListener("dispose", we), c = new Map, i.programs = c);
            let h = c.get(l);
            if (void 0 !== h) {
                if (i.currentProgram === h && i.lightsStateVersion === s) return He(e, o), h
            } else o.uniforms = le.getUniforms(e), e.onBuild(n, o, x), e.onBeforeCompile(o, x), h = le.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
            const u = i.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = de.uniform), He(e, o), i.needsLights = function(e) {
                return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
            }(e), i.lightsStateVersion = s, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
            const d = h.getUniforms(),
                p = Rr.seqWithValue(d.seq, u);
            return i.currentProgram = h, i.uniformsList = p, h
        }

        function He(e, t) {
            const n = te.get(e);
            n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
        }
        De.setAnimationLoop((function(e) {
            Le && Le(e)
        })), "undefined" != typeof window && De.setContext(window), this.setAnimationLoop = function(e) {
            Le = e, Te.setAnimationLoop(e), null === e ? De.stop() : De.start()
        }, Te.addEventListener("sessionstart", Ce), Te.addEventListener("sessionend", Pe), this.render = function(e, t) {
            if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!0 === S) return;
            !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === Te.enabled && !0 === Te.isPresenting && (!0 === Te.cameraAutoUpdate && Te.updateCamera(t), t = Te.getCamera()), !0 === e.isScene && e.onBeforeRender(x, e, t, w), m = ue.get(e, v.length), m.init(), v.push(m), j.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), V.setFromProjectionMatrix(j), W = this.localClippingEnabled, k = de.init(this.clippingPlanes, W, t), p = he.get(e, f.length), p.init(), f.push(p), Ne(e, t, 0, x.sortObjects), p.finish(), !0 === x.sortObjects && p.sort(U, F), !0 === k && de.beginShadows();
            const n = m.state.shadowsArray;
            if (pe.render(n, e, t), !0 === k && de.endShadows(), !0 === this.info.autoReset && this.info.reset(), me.render(p, e), m.setupLights(x.physicallyCorrectLights), t.isArrayCamera) {
                const n = t.cameras;
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    Ie(p, e, i, i.viewport)
                }
            } else Ie(p, e, t);
            null !== w && (ne.updateMultisampleRenderTarget(w), ne.updateRenderTargetMipmap(w)), !0 === e.isScene && e.onAfterRender(x, e, t), $.buffers.depth.setTest(!0), $.buffers.depth.setMask(!0), $.buffers.color.setMask(!0), $.setPolygonOffset(!1), xe.resetDefaultState(), A = -1, R = null, v.pop(), m = v.length > 0 ? v[v.length - 1] : null, f.pop(), p = f.length > 0 ? f[f.length - 1] : null
        }, this.getActiveCubeFace = function() {
            return T
        }, this.getActiveMipmapLevel = function() {
            return E
        }, this.getRenderTarget = function() {
            return w
        }, this.setRenderTargetTextures = function(e, t, n) {
            te.get(e.texture).__webglTexture = t, te.get(e.depthTexture).__webglTexture = n;
            const i = te.get(e);
            i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || e.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), e.useRenderToTexture = !1, e.useRenderbuffer = !0))
        }, this.setRenderTargetFramebuffer = function(e, t) {
            const n = te.get(e);
            n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
        }, this.setRenderTarget = function(e, t = 0, n = 0) {
            w = e, T = t, E = n;
            let i = !0;
            if (e) {
                const t = te.get(e);
                void 0 !== t.__useDefaultFramebuffer ? ($.bindFramebuffer(ye.FRAMEBUFFER, null), i = !1) : void 0 === t.__webglFramebuffer ? ne.setupRenderTarget(e) : t.__hasExternalTextures && ne.rebindTextures(e, te.get(e.texture).__webglTexture, te.get(e.depthTexture).__webglTexture)
            }
            let r = null,
                a = !1,
                s = !1;
            if (e) {
                const n = e.texture;
                (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                const i = te.get(e).__webglFramebuffer;
                e.isWebGLCubeRenderTarget ? (r = i[t], a = !0) : r = e.useRenderbuffer ? te.get(e).__webglMultisampledFramebuffer : i, L.copy(e.viewport), C.copy(e.scissor), P = e.scissorTest
            } else L.copy(B).multiplyScalar(I).floor(), C.copy(z).multiplyScalar(I).floor(), P = G;
            if ($.bindFramebuffer(ye.FRAMEBUFFER, r) && Q.drawBuffers && i) {
                let t = !1;
                if (e)
                    if (e.isWebGLMultipleRenderTargets) {
                        const n = e.texture;
                        if (H.length !== n.length || H[0] !== ye.COLOR_ATTACHMENT0) {
                            for (let e = 0, t = n.length; e < t; e++) H[e] = ye.COLOR_ATTACHMENT0 + e;
                            H.length = n.length, t = !0
                        }
                    } else 1 === H.length && H[0] === ye.COLOR_ATTACHMENT0 || (H[0] = ye.COLOR_ATTACHMENT0, H.length = 1, t = !0);
                else 1 === H.length && H[0] === ye.BACK || (H[0] = ye.BACK, H.length = 1, t = !0);
                t && (Q.isWebGL2 ? ye.drawBuffers(H) : Z.get("WEBGL_draw_buffers").drawBuffersWEBGL(H))
            }
            if ($.viewport(L), $.scissor(C), $.setScissorTest(P), a) {
                const i = te.get(e.texture);
                ye.framebufferTexture2D(ye.FRAMEBUFFER, ye.COLOR_ATTACHMENT0, ye.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n)
            } else if (s) {
                const i = te.get(e.texture),
                    r = t || 0;
                ye.framebufferTextureLayer(ye.FRAMEBUFFER, ye.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
            }
            A = -1
        }, this.readRenderTargetPixels = function(e, t, n, i, r, a, s) {
            if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let o = te.get(e).__webglFramebuffer;
            if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) {
                $.bindFramebuffer(ye.FRAMEBUFFER, o);
                try {
                    const s = e.texture,
                        o = s.format,
                        l = s.type;
                    if (o !== b && ve.convert(o) !== ye.getParameter(ye.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    const c = l === M && (Z.has("EXT_color_buffer_half_float") || Q.isWebGL2 && Z.has("EXT_color_buffer_float"));
                    if (!(l === _ || ve.convert(l) === ye.getParameter(ye.IMPLEMENTATION_COLOR_READ_TYPE) || l === y && (Q.isWebGL2 || Z.has("OES_texture_float") || Z.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    ye.checkFramebufferStatus(ye.FRAMEBUFFER) === ye.FRAMEBUFFER_COMPLETE ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && ye.readPixels(t, n, i, r, ve.convert(o), ve.convert(l), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                } finally {
                    const e = null !== w ? te.get(w).__webglFramebuffer : null;
                    $.bindFramebuffer(ye.FRAMEBUFFER, e)
                }
            }
        }, this.copyFramebufferToTexture = function(e, t, n = 0) {
            if (!0 !== t.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
            const i = Math.pow(2, -n),
                r = Math.floor(t.image.width * i),
                a = Math.floor(t.image.height * i);
            ne.setTexture2D(t, 0), ye.copyTexSubImage2D(ye.TEXTURE_2D, n, 0, 0, e.x, e.y, r, a), $.unbindTexture()
        }, this.copyTextureToTexture = function(e, t, n, i = 0) {
            const r = t.image.width,
                a = t.image.height,
                s = ve.convert(n.format),
                o = ve.convert(n.type);
            ne.setTexture2D(n, 0), ye.pixelStorei(ye.UNPACK_FLIP_Y_WEBGL, n.flipY), ye.pixelStorei(ye.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), ye.pixelStorei(ye.UNPACK_ALIGNMENT, n.unpackAlignment), t.isDataTexture ? ye.texSubImage2D(ye.TEXTURE_2D, i, e.x, e.y, r, a, s, o, t.image.data) : t.isCompressedTexture ? ye.compressedTexSubImage2D(ye.TEXTURE_2D, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, s, t.mipmaps[0].data) : ye.texSubImage2D(ye.TEXTURE_2D, i, e.x, e.y, s, o, t.image), 0 === i && n.generateMipmaps && ye.generateMipmap(ye.TEXTURE_2D), $.unbindTexture()
        }, this.copyTextureToTexture3D = function(e, t, n, i, r = 0) {
            if (x.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            const a = e.max.x - e.min.x + 1,
                s = e.max.y - e.min.y + 1,
                o = e.max.z - e.min.z + 1,
                l = ve.convert(i.format),
                c = ve.convert(i.type);
            let h;
            if (i.isDataTexture3D) ne.setTexture3D(i, 0), h = ye.TEXTURE_3D;
            else {
                if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                ne.setTexture2DArray(i, 0), h = ye.TEXTURE_2D_ARRAY
            }
            ye.pixelStorei(ye.UNPACK_FLIP_Y_WEBGL, i.flipY), ye.pixelStorei(ye.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), ye.pixelStorei(ye.UNPACK_ALIGNMENT, i.unpackAlignment);
            const u = ye.getParameter(ye.UNPACK_ROW_LENGTH),
                d = ye.getParameter(ye.UNPACK_IMAGE_HEIGHT),
                p = ye.getParameter(ye.UNPACK_SKIP_PIXELS),
                m = ye.getParameter(ye.UNPACK_SKIP_ROWS),
                f = ye.getParameter(ye.UNPACK_SKIP_IMAGES),
                g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
            ye.pixelStorei(ye.UNPACK_ROW_LENGTH, g.width), ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, g.height), ye.pixelStorei(ye.UNPACK_SKIP_PIXELS, e.min.x), ye.pixelStorei(ye.UNPACK_SKIP_ROWS, e.min.y), ye.pixelStorei(ye.UNPACK_SKIP_IMAGES, e.min.z), n.isDataTexture || n.isDataTexture3D ? ye.texSubImage3D(h, r, t.x, t.y, t.z, a, s, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ye.compressedTexSubImage3D(h, r, t.x, t.y, t.z, a, s, o, l, g.data)) : ye.texSubImage3D(h, r, t.x, t.y, t.z, a, s, o, l, c, g), ye.pixelStorei(ye.UNPACK_ROW_LENGTH, u), ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, d), ye.pixelStorei(ye.UNPACK_SKIP_PIXELS, p), ye.pixelStorei(ye.UNPACK_SKIP_ROWS, m), ye.pixelStorei(ye.UNPACK_SKIP_IMAGES, f), 0 === r && i.generateMipmaps && ye.generateMipmap(h), $.unbindTexture()
        }, this.initTexture = function(e) {
            ne.setTexture2D(e, 0), $.unbindTexture()
        }, this.resetState = function() {
            T = 0, E = 0, w = null, $.reset(), xe.reset()
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    Ta.prototype.isWebGLRenderer = !0;
    class ba extends _t {
        constructor() {
            super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        copy(e, t) {
            return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        }
    }
    ba.prototype.isScene = !0;
    class Ea extends At {
        constructor(e = 1, t = 1, n = 1, i = 8, r = 1, a = !1, s = 0, o = 2 * Math.PI) {
            super(), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: a,
                thetaStart: s,
                thetaLength: o
            };
            const l = this;
            i = Math.floor(i), r = Math.floor(r);
            const c = [],
                h = [],
                u = [],
                d = [];
            let p = 0;
            const m = [],
                f = n / 2;
            let g = 0;

            function _(n) {
                const r = p,
                    a = new ze,
                    m = new J;
                let _ = 0;
                const v = !0 === n ? e : t,
                    x = !0 === n ? 1 : -1;
                for (let e = 1; e <= i; e++) h.push(0, f * x, 0), u.push(0, x, 0), d.push(.5, .5), p++;
                const y = p;
                for (let e = 0; e <= i; e++) {
                    const t = e / i * o + s,
                        n = Math.cos(t),
                        r = Math.sin(t);
                    m.x = v * r, m.y = f * x, m.z = v * n, h.push(m.x, m.y, m.z), u.push(0, x, 0), a.x = .5 * n + .5, a.y = .5 * r * x + .5, d.push(a.x, a.y), p++
                }
                for (let e = 0; e < i; e++) {
                    const t = r + e,
                        i = y + e;
                    !0 === n ? c.push(i, i + 1, t) : c.push(i + 1, i, t), _ += 3
                }
                l.addGroup(g, _, !0 === n ? 1 : 2), g += _
            }! function() {
                const a = new J,
                    _ = new J;
                let v = 0;
                const x = (t - e) / n;
                for (let l = 0; l <= r; l++) {
                    const c = [],
                        g = l / r,
                        v = g * (t - e) + e;
                    for (let e = 0; e <= i; e++) {
                        const t = e / i,
                            r = t * o + s,
                            l = Math.sin(r),
                            m = Math.cos(r);
                        _.x = v * l, _.y = -g * n + f, _.z = v * m, h.push(_.x, _.y, _.z), a.set(l, x, m).normalize(), u.push(a.x, a.y, a.z), d.push(t, 1 - g), c.push(p++)
                    }
                    m.push(c)
                }
                for (let e = 0; e < i; e++)
                    for (let t = 0; t < r; t++) {
                        const n = m[t][e],
                            i = m[t + 1][e],
                            r = m[t + 1][e + 1],
                            a = m[t][e + 1];
                        c.push(n, i, a), c.push(i, r, a), v += 6
                    }
                l.addGroup(g, v, 0), g += v
            }(), !1 === a && (e > 0 && _(!0), t > 0 && _(!1)), this.setIndex(c), this.setAttribute("position", new $e(h, 3)), this.setAttribute("normal", new $e(u, 3)), this.setAttribute("uv", new $e(d, 2))
        }
        static fromJSON(e) {
            return new Ea(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
        }
    }
    class wa extends Ea {
        constructor(e = 1, t = 1, n = 8, i = 1, r = !1, a = 0, s = 2 * Math.PI) {
            super(0, e, t, n, i, r, a, s), this.type = "ConeGeometry", this.parameters = {
                radius: e,
                height: t,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: a,
                thetaLength: s
            }
        }
        static fromJSON(e) {
            return new wa(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
        }
    }
    class Aa extends At {
        constructor(e = [], t = [], n = 1, i = 0) {
            super(), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: e,
                indices: t,
                radius: n,
                detail: i
            };
            const r = [],
                a = [];

            function s(e, t, n, i) {
                const r = i + 1,
                    a = [];
                for (let i = 0; i <= r; i++) {
                    a[i] = [];
                    const s = e.clone().lerp(n, i / r),
                        o = t.clone().lerp(n, i / r),
                        l = r - i;
                    for (let e = 0; e <= l; e++) a[i][e] = 0 === e && i === r ? s : s.clone().lerp(o, e / l)
                }
                for (let e = 0; e < r; e++)
                    for (let t = 0; t < 2 * (r - e) - 1; t++) {
                        const n = Math.floor(t / 2);
                        t % 2 == 0 ? (o(a[e][n + 1]), o(a[e + 1][n]), o(a[e][n])) : (o(a[e][n + 1]), o(a[e + 1][n + 1]), o(a[e + 1][n]))
                    }
            }

            function o(e) {
                r.push(e.x, e.y, e.z)
            }

            function l(t, n) {
                const i = 3 * t;
                n.x = e[i + 0], n.y = e[i + 1], n.z = e[i + 2]
            }

            function c(e, t, n, i) {
                i < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === n.x && 0 === n.z && (a[t] = i / 2 / Math.PI + .5)
            }

            function h(e) {
                return Math.atan2(e.z, -e.x)
            }! function(e) {
                const n = new J,
                    i = new J,
                    r = new J;
                for (let a = 0; a < t.length; a += 3) l(t[a + 0], n), l(t[a + 1], i), l(t[a + 2], r), s(n, i, r, e)
            }(i),
            function(e) {
                const t = new J;
                for (let n = 0; n < r.length; n += 3) t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2], t.normalize().multiplyScalar(e), r[n + 0] = t.x, r[n + 1] = t.y, r[n + 2] = t.z
            }(n),
            function() {
                const e = new J;
                for (let n = 0; n < r.length; n += 3) {
                    e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2];
                    const i = h(e) / 2 / Math.PI + .5,
                        s = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
                    a.push(i, 1 - s)
                }
                var t;
                (function() {
                    const e = new J,
                        t = new J,
                        n = new J,
                        i = new J,
                        s = new ze,
                        o = new ze,
                        l = new ze;
                    for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                        e.set(r[u + 0], r[u + 1], r[u + 2]), t.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), s.set(a[d + 0], a[d + 1]), o.set(a[d + 2], a[d + 3]), l.set(a[d + 4], a[d + 5]), i.copy(e).add(t).add(n).divideScalar(3);
                        const p = h(i);
                        c(s, d + 0, e, p), c(o, d + 2, t, p), c(l, d + 4, n, p)
                    }
                })(),
                function() {
                    for (let e = 0; e < a.length; e += 6) {
                        const t = a[e + 0],
                            n = a[e + 2],
                            i = a[e + 4],
                            r = Math.max(t, n, i),
                            s = Math.min(t, n, i);
                        r > .9 && s < .1 && (t < .2 && (a[e + 0] += 1), n < .2 && (a[e + 2] += 1), i < .2 && (a[e + 4] += 1))
                    }
                }()
            }(), this.setAttribute("position", new $e(r, 3)), this.setAttribute("normal", new $e(r.slice(), 3)), this.setAttribute("uv", new $e(a, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
        }
        static fromJSON(e) {
            return new Aa(e.vertices, e.indices, e.radius, e.details)
        }
    }
    class Ra extends Aa {
        constructor(e = 1, t = 0) {
            const n = (1 + Math.sqrt(5)) / 2,
                i = 1 / n;
            super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }
        static fromJSON(e) {
            return new Ra(e.radius, e.detail)
        }
    }
    class La extends Aa {
        constructor(e = 1, t = 0) {
            const n = (1 + Math.sqrt(5)) / 2;
            super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }
        static fromJSON(e) {
            return new La(e.radius, e.detail)
        }
    }
    class Ca extends Aa {
        constructor(e = 1, t = 0) {
            super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }
        static fromJSON(e) {
            return new Ca(e.radius, e.detail)
        }
    }
    class Pa extends Aa {
        constructor(e = 1, t = 0) {
            super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }
        static fromJSON(e) {
            return new Pa(e.radius, e.detail)
        }
    }
    const Da = {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled) return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    };
    const Na = new class {
        constructor(e, t, n) {
            const i = this;
            let r, a = !1,
                s = 0,
                o = 0;
            const l = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                o++, !1 === a && void 0 !== i.onStart && i.onStart(e, s, o), a = !0
            }, this.itemEnd = function(e) {
                s++, void 0 !== i.onProgress && i.onProgress(e, s, o), s === o && (a = !1, void 0 !== i.onLoad && i.onLoad())
            }, this.itemError = function(e) {
                void 0 !== i.onError && i.onError(e)
            }, this.resolveURL = function(e) {
                return r ? r(e) : e
            }, this.setURLModifier = function(e) {
                return r = e, this
            }, this.addHandler = function(e, t) {
                return l.push(e, t), this
            }, this.removeHandler = function(e) {
                const t = l.indexOf(e);
                return -1 !== t && l.splice(t, 2), this
            }, this.getHandler = function(e) {
                for (let t = 0, n = l.length; t < n; t += 2) {
                    const n = l[t],
                        i = l[t + 1];
                    if (n.global && (n.lastIndex = 0), n.test(e)) return i
                }
                return null
            }
        }
    };
    class Ia {
        constructor(e) {
            this.manager = void 0 !== e ? e : Na, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
        }
        load() {}
        loadAsync(e, t) {
            const n = this;
            return new Promise((function(i, r) {
                n.load(e, i, t, r)
            }))
        }
        parse() {}
        setCrossOrigin(e) {
            return this.crossOrigin = e, this
        }
        setWithCredentials(e) {
            return this.withCredentials = e, this
        }
        setPath(e) {
            return this.path = e, this
        }
        setResourcePath(e) {
            return this.resourcePath = e, this
        }
        setRequestHeader(e) {
            return this.requestHeader = e, this
        }
    }
    class Ua extends Ia {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this,
                a = Da.get(e);
            if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function() {
                t && t(a), r.manager.itemEnd(e)
            }), 0), a;
            const s = xt("img");

            function o() {
                c(), Da.add(e, this), t && t(this), r.manager.itemEnd(e)
            }

            function l(t) {
                c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
            }

            function c() {
                s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1)
            }
            return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s
        }
    }
    class Fa extends Ia {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            const r = new Dn,
                a = new Ua(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, (function(e) {
                r.image = e, r.needsUpdate = !0, void 0 !== t && t(r)
            }), n, i), r
        }
    }
    class Oa extends _t {
        constructor(e, t = 1) {
            super(), this.type = "Light", this.color = new qe(e), this.intensity = t
        }
        dispose() {}
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
        }
    }
    Oa.prototype.isLight = !0;
    const Ba = new Re,
        za = new J,
        Ga = new J;
    class Ha extends class {
        constructor(e) {
            this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ze(512, 512), this.map = null, this.mapPass = null, this.matrix = new Re, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ae, this._frameExtents = new ze(1, 1), this._viewportCount = 1, this._viewports = [new Fe(0, 0, 1, 1)]
        }
        getViewportCount() {
            return this._viewportCount
        }
        getFrustum() {
            return this._frustum
        }
        updateMatrices(e) {
            const t = this.camera,
                n = this.matrix;
            za.setFromMatrixPosition(e.matrixWorld), t.position.copy(za), Ga.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Ga), t.updateMatrixWorld(), Ba.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ba), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
        }
        getViewport(e) {
            return this._viewports[e]
        }
        getFrameExtents() {
            return this._frameExtents
        }
        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
        }
        copy(e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        toJSON() {
            const e = {};
            return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    } {
        constructor() {
            super(new Vn(-5, 5, 5, -5, .5, 500))
        }
    }
    Ha.prototype.isDirectionalLightShadow = !0;
    class Va extends Oa {
        constructor(e, t) {
            super(e, t), this.type = "DirectionalLight", this.position.copy(_t.DefaultUp), this.updateMatrix(), this.target = new _t, this.shadow = new Ha
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e) {
            return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }
    Va.prototype.isDirectionalLight = !0;
    class ka extends Oa {
        constructor(e, t) {
            super(e, t), this.type = "AmbientLight"
        }
    }
    ka.prototype.isAmbientLight = !0;

    function Wa(e, t) {
        return e.distance - t.distance
    }

    function Xa(e, t, n, i) {
        if (e.layers.test(t.layers) && e.raycast(t, n), !0 === i) {
            const i = e.children;
            for (let e = 0, r = i.length; e < r; e++) Xa(i[e], t, n, !0)
        }
    }
    const ja = {};
    class qa extends Ia {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = Da.get(e);
            if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => {
                t && t(r), this.manager.itemEnd(e)
            }), 0), r;
            if (void 0 !== ja[e]) return void ja[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            ja[e] = [], ja[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            const a = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            });
            fetch(a).then((t => {
                if (200 === t.status || 0 === t.status) {
                    if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body.getReader) return t;
                    const n = ja[e],
                        i = t.body.getReader(),
                        r = t.headers.get("Content-Length"),
                        a = r ? parseInt(r) : 0,
                        s = 0 !== a;
                    let o = 0;
                    const l = new ReadableStream({
                        start(e) {
                            ! function t() {
                                i.read().then((({
                                    done: i,
                                    value: r
                                }) => {
                                    if (i) e.close();
                                    else {
                                        o += r.byteLength;
                                        const i = new ProgressEvent("progress", {
                                            lengthComputable: s,
                                            loaded: o,
                                            total: a
                                        });
                                        for (let e = 0, t = n.length; e < t; e++) {
                                            const t = n[e];
                                            t.onProgress && t.onProgress(i)
                                        }
                                        e.enqueue(r), t()
                                    }
                                }))
                            }()
                        }
                    });
                    return new Response(l)
                }
                throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)
            })).then((e => {
                switch (this.responseType) {
                    case "arraybuffer":
                        return e.arrayBuffer();
                    case "blob":
                        return e.blob();
                    case "document":
                        return e.text().then((e => (new DOMParser).parseFromString(e, this.mimeType)));
                    case "json":
                        return e.json();
                    default:
                        return e.text()
                }
            })).then((t => {
                Da.add(e, t);
                const n = ja[e];
                delete ja[e];
                for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    i.onLoad && i.onLoad(t)
                }
            })).catch((t => {
                const n = ja[e];
                if (void 0 === n) throw this.manager.itemError(e), t;
                delete ja[e];
                for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    i.onError && i.onError(t)
                }
                this.manager.itemError(e)
            })).finally((() => {
                this.manager.itemEnd(e)
            })), this.manager.itemStart(e)
        }
        setResponseType(e) {
            return this.responseType = e, this
        }
        setMimeType(e) {
            return this.mimeType = e, this
        }
    }
    class Ya extends Ia {
        constructor(e) {
            super(e), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                premultiplyAlpha: "none"
            }
        }
        setOptions(e) {
            return this.options = e, this
        }
        load(e, t, n, i) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this,
                a = Da.get(e);
            if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function() {
                t && t(a), r.manager.itemEnd(e)
            }), 0), a;
            const s = {};
            s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(e, s).then((function(e) {
                return e.blob()
            })).then((function(e) {
                return createImageBitmap(e, Object.assign(r.options, {
                    colorSpaceConversion: "none"
                }))
            })).then((function(n) {
                Da.add(e, n), t && t(n), r.manager.itemEnd(e)
            })).catch((function(t) {
                i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
            })), r.manager.itemStart(e)
        }
    }
    Ya.prototype.isImageBitmapLoader = !0;
    class Ka {
        constructor(e, t) {
            this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = G, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0, this.uuid = X()
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            !0 === e && this.version++
        }
        setUsage(e) {
            return this.usage = e, this
        }
        copy(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
        }
        copyAt(e, t, n) {
            e *= this.stride, n *= t.stride;
            for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
            return this
        }
        set(e, t = 0) {
            return this.array.set(e, t), this
        }
        clone(e) {
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = X()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                n = new this.constructor(t, this.stride);
            return n.setUsage(this.usage), n
        }
        onUpload(e) {
            return this.onUploadCallback = e, this
        }
        toJSON(e) {
            return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = X()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    }
    Ka.prototype.isInterleavedBuffer = !0;
    const Za = new J;
    class Ja {
        constructor(e, t, n, i = !1) {
            this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i
        }
        get count() {
            return this.data.count
        }
        get array() {
            return this.data.array
        }
        set needsUpdate(e) {
            this.data.needsUpdate = e
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.data.count; t < n; t++) Za.x = this.getX(t), Za.y = this.getY(t), Za.z = this.getZ(t), Za.applyMatrix4(e), this.setXYZ(t, Za.x, Za.y, Za.z);
            return this
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) Za.x = this.getX(t), Za.y = this.getY(t), Za.z = this.getZ(t), Za.applyNormalMatrix(e), this.setXYZ(t, Za.x, Za.y, Za.z);
            return this
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) Za.x = this.getX(t), Za.y = this.getY(t), Za.z = this.getZ(t), Za.transformDirection(e), this.setXYZ(t, Za.x, Za.y, Za.z);
            return this
        }
        setX(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        }
        setY(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        }
        setZ(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        }
        setW(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        }
        getX(e) {
            return this.data.array[e * this.data.stride + this.offset]
        }
        getY(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        }
        getZ(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        }
        getW(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        }
        setXY(e, t, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
        }
        setXYZ(e, t, n, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
        }
        setXYZW(e, t, n, i, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
        }
        clone(e) {
            if (void 0 === e) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                const e = [];
                for (let t = 0; t < this.count; t++) {
                    const n = t * this.data.stride + this.offset;
                    for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                }
                return new Ze(new this.array.constructor(e), this.itemSize, this.normalized)
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Ja(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
        }
        toJSON(e) {
            if (void 0 === e) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                const e = [];
                for (let t = 0; t < this.count; t++) {
                    const n = t * this.data.stride + this.offset;
                    for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: e,
                    normalized: this.normalized
                }
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }
    Ja.prototype.isInterleavedBufferAttribute = !0;
    class Qa {
        static decodeText(e) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
            let t = "";
            for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        }
        static extractUrlBase(e) {
            const t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
        static resolveURL(e, t) {
            return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
        }
    }
    class $a extends Pt {
        constructor(e) {
            super(), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new qe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ze(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: ""
            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
        }
    }
    $a.prototype.isMeshStandardMaterial = !0;
    class es extends $a {
        constructor(e) {
            super(), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ze(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                get: function() {
                    return j(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                },
                set: function(e) {
                    this.ior = (1 + .4 * e) / (1 - .4 * e)
                }
            }), this.sheenColor = new qe(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new qe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new qe(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e)
        }
        get sheen() {
            return this._sheen
        }
        set sheen(e) {
            this._sheen > 0 != e > 0 && this.version++, this._sheen = e
        }
        get clearcoat() {
            return this._clearcoat
        }
        set clearcoat(e) {
            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
        }
        get transmission() {
            return this._transmission
        }
        set transmission(e) {
            this._transmission > 0 != e > 0 && this.version++, this._transmission = e
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
        }
    }
    es.prototype.isMeshPhysicalMaterial = !0;
    const ts = "\\[\\]\\.:\\/",
        ns = new RegExp("[\\[\\]\\.:\\/]", "g"),
        is = "[^\\[\\]\\.:\\/]",
        rs = "[^" + ts.replace("\\.", "") + "]",
        as = /((?:WC+[\/:])*)/.source.replace("WC", is),
        ss = /(WCOD+)?/.source.replace("WCOD", rs),
        os = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", is),
        ls = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", is),
        cs = new RegExp("^" + as + ss + os + ls + "$"),
        hs = ["material", "materials", "bones"];
    class us {
        constructor(e, t, n) {
            this.path = t, this.parsedPath = n || us.parseTrackName(t), this.node = us.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
        static create(e, t, n) {
            return e && e.isAnimationObjectGroup ? new us.Composite(e, t, n) : new us(e, t, n)
        }
        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(ns, "")
        }
        static parseTrackName(e) {
            const t = cs.exec(e);
            if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                },
                i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                const e = n.nodeName.substring(i + 1); - 1 !== hs.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)
            }
            if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        }
        static findNode(e, t) {
            if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                const n = e.skeleton.getBoneByName(t);
                if (void 0 !== n) return n
            }
            if (e.children) {
                const n = function(e) {
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            if (r.name === t || r.uuid === t) return r;
                            const a = n(r.children);
                            if (a) return a
                        }
                        return null
                    },
                    i = n(e.children);
                if (i) return i
            }
            return null
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName]
        }
        _getValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
        }
        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
        }
        _setValue_array_setNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _getValue_unbound(e, t) {
            this.bind(), this.getValue(e, t)
        }
        _setValue_unbound(e, t) {
            this.bind(), this.setValue(e, t)
        }
        bind() {
            let e = this.node;
            const t = this.parsedPath,
                n = t.objectName,
                i = t.propertyName;
            let r = t.propertyIndex;
            if (e || (e = us.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (n) {
                let i = t.objectIndex;
                switch (n) {
                    case "materials":
                        if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        e = e.skeleton.bones;
                        for (let t = 0; t < e.length; t++)
                            if (e[t].name === i) {
                                i = t;
                                break
                            }
                        break;
                    default:
                        if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[n]
                }
                if (void 0 !== i) {
                    if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    e = e[i]
                }
            }
            const a = e[i];
            if (void 0 === a) {
                const n = t.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
            }
            let s = this.Versioning.None;
            this.targetObject = e, void 0 !== e.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
            let o = this.BindingType.Direct;
            if (void 0 !== r) {
                if ("morphTargetInfluences" === i) {
                    if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                }
                o = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
            } else void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][s]
        }
        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }
    us.Composite = class {
        constructor(e, t, n) {
            const i = n || us.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, i)
        }
        getValue(e, t) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
                i = this._bindings[n];
            void 0 !== i && i.getValue(e, t)
        }
        setValue(e, t) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
        }
        bind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
        }
        unbind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
        }
    }, us.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    }, us.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    }, us.prototype.GetterByBindingType = [us.prototype._getValue_direct, us.prototype._getValue_array, us.prototype._getValue_arrayElement, us.prototype._getValue_toArray], us.prototype.SetterByBindingTypeAndVersioning = [
        [us.prototype._setValue_direct, us.prototype._setValue_direct_setNeedsUpdate, us.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
        [us.prototype._setValue_array, us.prototype._setValue_array_setNeedsUpdate, us.prototype._setValue_array_setMatrixWorldNeedsUpdate],
        [us.prototype._setValue_arrayElement, us.prototype._setValue_arrayElement_setNeedsUpdate, us.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
        [us.prototype._setValue_fromArray, us.prototype._setValue_fromArray_setNeedsUpdate, us.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
    ];

    function ds() {
        let e = {};
        return {
            get: function(t) {
                return e[t]
            },
            add: function(t, n) {
                e[t] = n
            },
            remove: function(t) {
                delete e[t]
            },
            removeAll: function() {
                e = {}
            }
        }
    }
    const ps = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
    };
    class ms {
        constructor(e) {
            this.parser = e, this.name = ps.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            }
        }
        _markDefs() {
            const e = this.parser,
                t = this.parser.json.nodes || [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
            }
        }
        createNodeAttachment(e) {
            const t = this.parser.json.nodes[e];
            (t.extensions && t.extensions[this.name] || {}).light;
            return null
        }
    }
    class fs {
        constructor() {
            this.name = ps.KHR_MATERIALS_UNLIT
        }
        getMaterialType() {
            return tn
        }
        extendParams(e, t, n) {
            const i = [];
            e.color = new qe(1, 1, 1), e.opacity = 1;
            const r = t.pbrMetallicRoughness;
            if (r) {
                if (Array.isArray(r.baseColorFactor)) {
                    const t = r.baseColorFactor;
                    e.color.fromArray(t), e.opacity = t[3]
                }
                void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture))
            }
            return Promise.all(i)
        }
    }
    class gs {
        constructor(e) {
            this.parser = e, this.name = ps.KHR_MATERIALS_CLEARCOAT
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? es : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) {
                const e = a.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new ze(e, e)
            }
            return Promise.all(r)
        }
    }
    class _s {
        constructor(e) {
            this.parser = e, this.name = ps.KHR_MATERIALS_SHEEN
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? es : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [];
            t.sheenColor = new qe(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
            const a = i.extensions[this.name];
            return void 0 !== a.sheenColorFactor && t.sheenColor.fromArray(a.sheenColorFactor), void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor), void 0 !== a.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture)), void 0 !== a.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r)
        }
    }
    class vs {
        constructor(e) {
            this.parser = e, this.name = ps.KHR_MATERIALS_TRANSMISSION
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? es : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r)
        }
    }
    class xs {
        constructor(e) {
            this.parser = e, this.name = ps.KHR_MATERIALS_VOLUME
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? es : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 0;
            const s = a.attenuationColor || [1, 1, 1];
            return t.attenuationColor = new qe(s[0], s[1], s[2]), Promise.all(r)
        }
    }
    class ys {
        constructor(e) {
            this.parser = e, this.name = ps.KHR_MATERIALS_IOR
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? es : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const i = n.extensions[this.name];
            return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
        }
    }
    class Ms {
        constructor(e) {
            this.parser = e, this.name = ps.KHR_MATERIALS_SPECULAR
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? es : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [],
                a = i.extensions[this.name];
            t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
            const s = a.specularColorFactor || [1, 1, 1];
            return t.specularColor = new qe(s[0], s[1], s[2]), void 0 !== a.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture).then((function(e) {
                e.encoding = B
            }))), Promise.all(r)
        }
    }
    class Ss {
        constructor(e) {
            this.parser = e, this.name = ps.KHR_TEXTURE_BASISU
        }
        loadTexture(e) {
            const t = this.parser,
                n = t.json,
                i = n.textures[e];
            if (!i.extensions || !i.extensions[this.name]) return null;
            const r = i.extensions[this.name],
                a = n.images[r.source],
                s = t.options.ktx2Loader;
            if (!s) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null
            }
            return t.loadTextureImage(e, a, s)
        }
    }
    class Ts {
        constructor(e) {
            this.parser = e, this.name = ps.EXT_TEXTURE_WEBP, this.isSupported = null
        }
        loadTexture(e) {
            const t = this.name,
                n = this.parser,
                i = n.json,
                r = i.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const a = r.extensions[t],
                s = i.images[a.source];
            let o = n.textureLoader;
            if (s.uri) {
                const e = n.options.manager.getHandler(s.uri);
                null !== e && (o = e)
            }
            return this.detectSupport().then((function(r) {
                if (r) return n.loadTextureImage(e, s, o);
                if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return n.loadTexture(e)
            }))
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise((function(e) {
                const t = new Image;
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                    e(1 === t.height)
                }
            }))), this.isSupported
        }
    }
    class bs {
        constructor(e) {
            this.name = ps.EXT_MESHOPT_COMPRESSION, this.parser = e
        }
        loadBufferView(e) {
            const t = this.parser.json,
                n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
                const e = n.extensions[this.name],
                    i = this.parser.getDependency("buffer", e.buffer),
                    r = this.parser.options.meshoptDecoder;
                if (!r || !r.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null
                }
                return Promise.all([i, r.ready]).then((function(t) {
                    const n = e.byteOffset || 0,
                        i = e.byteLength || 0,
                        a = e.count,
                        s = e.byteStride,
                        o = new ArrayBuffer(a * s),
                        l = new Uint8Array(t[0], n, i);
                    return r.decodeGltfBuffer(new Uint8Array(o), a, s, l, e.mode, e.filter), o
                }))
            }
            return null
        }
    }
    const Es = "glTF",
        ws = 1313821514,
        As = 5130562;
    class Rs {
        constructor(e) {
            this.name = ps.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const t = new DataView(e, 0, 12);
            if (this.header = {
                    magic: Qa.decodeText(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                }, this.header.magic !== Es) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const n = this.header.length - 12,
                i = new DataView(e, 12);
            let r = 0;
            for (; r < n;) {
                const t = i.getUint32(r, !0);
                r += 4;
                const n = i.getUint32(r, !0);
                if (r += 4, n === ws) {
                    const n = new Uint8Array(e, 12 + r, t);
                    this.content = Qa.decodeText(n)
                } else if (n === As) {
                    const n = 12 + r;
                    this.body = e.slice(n, n + t)
                }
                r += t
            }
            if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
        }
    }
    class Ls {
        constructor(e, t) {
            if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = ps.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
        }
        decodePrimitive(e, t) {
            const n = this.json,
                i = this.dracoLoader,
                r = e.extensions[this.name].bufferView,
                a = e.extensions[this.name].attributes,
                s = {},
                o = {},
                l = {};
            for (const e in a) {
                const t = Hs[e] || e.toLowerCase();
                s[t] = a[e]
            }
            for (const t in e.attributes) {
                const i = Hs[t] || t.toLowerCase();
                if (void 0 !== a[t]) {
                    const r = n.accessors[e.attributes[t]],
                        a = Os[r.componentType];
                    l[i] = a, o[i] = !0 === r.normalized
                }
            }
            return t.getDependency("bufferView", r).then((function(e) {
                return new Promise((function(t) {
                    i.decodeDracoFile(e, (function(e) {
                        for (const t in e.attributes) {
                            const n = e.attributes[t],
                                i = o[t];
                            void 0 !== i && (n.normalized = i)
                        }
                        t(e)
                    }), s, l)
                }))
            }))
        }
    }
    class Cs {
        constructor() {
            this.name = ps.KHR_TEXTURE_TRANSFORM
        }
        extendTexture(e, t) {
            return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
        }
    }
    class Ps extends $a {
        constructor(e) {
            super(), this.isGLTFSpecularGlossinessMaterial = !0;
            const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                s = {
                    specular: {
                        value: (new qe).setHex(16777215)
                    },
                    glossiness: {
                        value: 1
                    },
                    specularMap: {
                        value: null
                    },
                    glossinessMap: {
                        value: null
                    }
                };
            this._extraUniforms = s, this.onBeforeCompile = function(e) {
                for (const t in s) e.uniforms[t] = s[t];
                e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", a)
            }, Object.defineProperties(this, {
                specular: {
                    get: function() {
                        return s.specular.value
                    },
                    set: function(e) {
                        s.specular.value = e
                    }
                },
                specularMap: {
                    get: function() {
                        return s.specularMap.value
                    },
                    set: function(e) {
                        s.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                    }
                },
                glossiness: {
                    get: function() {
                        return s.glossiness.value
                    },
                    set: function(e) {
                        s.glossiness.value = e
                    }
                },
                glossinessMap: {
                    get: function() {
                        return s.glossinessMap.value
                    },
                    set: function(e) {
                        s.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                    }
                }
            }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
        }
    }
    class Ds {
        constructor() {
            this.name = ps.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
        }
        getMaterialType() {
            return Ps
        }
        extendParams(e, t, n) {
            const i = t.extensions[this.name];
            e.color = new qe(1, 1, 1), e.opacity = 1;
            const r = [];
            if (Array.isArray(i.diffuseFactor)) {
                const t = i.diffuseFactor;
                e.color.fromArray(t), e.opacity = t[3]
            }
            if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(e, "map", i.diffuseTexture)), e.emissive = new qe(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new qe(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                const t = i.specularGlossinessTexture;
                r.push(n.assignTexture(e, "glossinessMap", t)), r.push(n.assignTexture(e, "specularMap", t))
            }
            return Promise.all(r)
        }
        createMaterial(e) {
            const t = new Ps(e);
            return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = 0, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
        }
    }
    class Ns {
        constructor() {
            this.name = ps.KHR_MESH_QUANTIZATION
        }
    }
    const Is = 4,
        Us = 5,
        Fs = 6,
        Os = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        Bs = {
            9728: u,
            9729: m,
            9984: d,
            9985: f,
            9986: p,
            9987: g
        },
        zs = {
            33071: c,
            33648: h,
            10497: l
        },
        Gs = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        },
        Hs = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        },
        Vs = "OPAQUE",
        ks = "MASK",
        Ws = "BLEND";

    function Xs(e, t, n) {
        for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i])
    }

    function js(e, t) {
        void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
    }

    function qs(e, t) {
        if (e.updateMorphTargets(), void 0 !== t.weights)
            for (let n = 0, i = t.weights.length; n < i; n++) e.morphTargetInfluences[n] = t.weights[n];
        if (t.extras && Array.isArray(t.extras.targetNames)) {
            const n = t.extras.targetNames;
            if (e.morphTargetInfluences.length === n.length) {
                e.morphTargetDictionary = {};
                for (let t = 0, i = n.length; t < i; t++) e.morphTargetDictionary[n[t]] = t
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
        }
    }

    function Ys(e) {
        const t = e.extensions && e.extensions[ps.KHR_DRACO_MESH_COMPRESSION];
        let n;
        return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + Ks(t.attributes) : e.indices + ":" + Ks(e.attributes) + ":" + e.mode, n
    }

    function Ks(e) {
        let t = "";
        const n = Object.keys(e).sort();
        for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
        return t
    }

    function Zs(e) {
        switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
        }
    }
    class Js {
        constructor(e = {}, t = {}) {
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new ds, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox|Safari/.test(navigator.userAgent) ? this.textureLoader = new Ya(this.options.manager) : this.textureLoader = new Fa(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new qa(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(e) {
            this.extensions = e
        }
        setPlugins(e) {
            this.plugins = e
        }
        parse(e, t) {
            const n = this,
                i = this.json,
                r = this.extensions;
            this.cache.removeAll(), this._invokeAll((function(e) {
                return e._markDefs && e._markDefs()
            })), Promise.all(this._invokeAll((function(e) {
                return e.beforeRoot && e.beforeRoot()
            }))).then((function() {
                return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
            })).then((function(t) {
                const a = {
                    scene: t[0][i.scene || 0],
                    scenes: t[0],
                    animations: t[1],
                    cameras: t[2],
                    asset: i.asset,
                    parser: n,
                    userData: {}
                };
                Xs(r, a, i), js(a, i), Promise.all(n._invokeAll((function(e) {
                    return e.afterRoot && e.afterRoot(a)
                }))).then((function() {
                    e(a)
                }))
            })).catch(t)
        }
        _markDefs() {
            const e = this.json.nodes || [];
            for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                void 0 !== n.mesh && this._addNodeRef(this.meshCache, n.mesh), void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera)
            }
        }
        _addNodeRef(e, t) {
            void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
        }
        _getNodeRef(e, t, n) {
            if (e.refs[t] <= 1) return n;
            const i = n.clone(),
                r = (e, t) => {
                    const n = this.associations.get(e);
                    null != n && this.associations.set(t, n);
                    for (const [n, i] of e.children.entries()) r(i, t.children[n])
                };
            return r(n, i), i.name += "_instance_" + e.uses[t]++, i
        }
        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for (let n = 0; n < t.length; n++) {
                const i = e(t[n]);
                if (i) return i
            }
            return null
        }
        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const n = [];
            for (let i = 0; i < t.length; i++) {
                const r = e(t[i]);
                r && n.push(r)
            }
            return n
        }
        getDependency(e, t) {
            const n = e + ":" + t;
            let i = this.cache.get(n);
            if (!i) {
                switch (e) {
                    case "scene":
                        i = this.loadScene(t);
                        break;
                    case "node":
                        i = this.loadNode(t);
                        break;
                    case "mesh":
                        i = this._invokeOne((function(e) {
                            return e.loadMesh && e.loadMesh(t)
                        }));
                        break;
                    case "accessor":
                        i = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        i = this._invokeOne((function(e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        }));
                        break;
                    case "buffer":
                        i = this.loadBuffer(t);
                        break;
                    case "material":
                        i = this._invokeOne((function(e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        }));
                        break;
                    case "texture":
                        i = this._invokeOne((function(e) {
                            return e.loadTexture && e.loadTexture(t)
                        }));
                        break;
                    default:
                        throw new Error("Unknown type: " + e)
                }
                this.cache.add(n, i)
            }
            return i
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const n = this,
                    i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                t = Promise.all(i.map((function(t, i) {
                    return n.getDependency(e, i)
                }))), this.cache.add(e, t)
            }
            return t
        }
        loadBuffer(e) {
            const t = this.json.buffers[e],
                n = this.fileLoader;
            if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[ps.KHR_BINARY_GLTF].body);
            const i = this.options;
            return new Promise((function(e, r) {
                n.load(Qa.resolveURL(t.uri, i.path), e, void 0, (function() {
                    r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                }))
            }))
        }
        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then((function(e) {
                const n = t.byteLength || 0,
                    i = t.byteOffset || 0;
                return e.slice(i, i + n)
            }))
        }
        loadAccessor(e) {
            const t = this,
                n = this.json,
                i = this.json.accessors[e];
            if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
            const r = [];
            return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function(e) {
                const r = e[0],
                    a = Gs[i.type],
                    s = Os[i.componentType],
                    o = s.BYTES_PER_ELEMENT,
                    l = o * a,
                    c = i.byteOffset || 0,
                    h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                    u = !0 === i.normalized;
                let d, p;
                if (h && h !== l) {
                    const e = Math.floor(c / h),
                        n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                    let l = t.cache.get(n);
                    l || (d = new s(r, e * h, i.count * h / o), l = new Ka(d, h / o), t.cache.add(n, l)), p = new Ja(l, a, c % h / o, u)
                } else d = null === r ? new s(i.count * a) : new s(r, c, i.count * a), p = new Ze(d, a, u);
                if (void 0 !== i.sparse) {
                    const t = Gs.SCALAR,
                        n = Os[i.sparse.indices.componentType],
                        o = i.sparse.indices.byteOffset || 0,
                        l = i.sparse.values.byteOffset || 0,
                        c = new n(e[1], o, i.sparse.count * t),
                        h = new s(e[2], l, i.sparse.count * a);
                    null !== r && (p = new Ze(p.array.slice(), p.itemSize, p.normalized));
                    for (let e = 0, t = c.length; e < t; e++) {
                        const t = c[e];
                        if (p.setX(t, h[e * a]), a >= 2 && p.setY(t, h[e * a + 1]), a >= 3 && p.setZ(t, h[e * a + 2]), a >= 4 && p.setW(t, h[e * a + 3]), a >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                }
                return p
            }))
        }
        loadTexture(e) {
            const t = this.json,
                n = this.options,
                i = t.textures[e],
                r = t.images[i.source];
            let a = this.textureLoader;
            if (r.uri) {
                const e = n.manager.getHandler(r.uri);
                null !== e && (a = e)
            }
            return this.loadTextureImage(e, r, a)
        }
        loadTextureImage(e, t, n) {
            const i = this,
                r = this.json,
                a = this.options,
                s = r.textures[e],
                o = (t.uri || t.bufferView) + ":" + s.sampler;
            if (this.textureCache[o]) return this.textureCache[o];
            const c = self.URL || self.webkitURL;
            let h = t.uri || "",
                u = !1;
            if (void 0 !== t.bufferView) h = i.getDependency("bufferView", t.bufferView).then((function(e) {
                u = !0;
                const n = new Blob([e], {
                    type: t.mimeType
                });
                return h = c.createObjectURL(n), h
            }));
            else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const d = Promise.resolve(h).then((function(e) {
                return new Promise((function(t, i) {
                    let r = t;
                    !0 === n.isImageBitmapLoader && (r = function(e) {
                        const n = new Dn(e);
                        n.needsUpdate = !0, t(n)
                    }), n.load(Qa.resolveURL(e, a.path), r, void 0, i)
                }))
            })).then((function(t) {
                !0 === u && c.revokeObjectURL(h), t.flipY = !1, s.name && (t.name = s.name);
                const n = (r.samplers || {})[s.sampler] || {};
                return t.magFilter = Bs[n.magFilter] || m, t.minFilter = Bs[n.minFilter] || g, t.wrapS = zs[n.wrapS] || l, t.wrapT = zs[n.wrapT] || l, i.associations.set(t, {
                    textures: e
                }), t
            })).catch((function() {
                return console.error("THREE.GLTFLoader: Couldn't load texture", h), null
            }));
            return this.textureCache[o] = d, d
        }
        assignTexture(e, t, n) {
            const i = this;
            return this.getDependency("texture", n.index).then((function(r) {
                if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), i.extensions[ps.KHR_TEXTURE_TRANSFORM]) {
                    const e = void 0 !== n.extensions ? n.extensions[ps.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (e) {
                        const t = i.associations.get(r);
                        r = i.extensions[ps.KHR_TEXTURE_TRANSFORM].extendTexture(r, e), i.associations.set(r, t)
                    }
                }
                return e[t] = r, r
            }))
        }
        assignFinalMaterial(e) {
            const t = e.geometry;
            let n = e.material;
            const i = void 0 === t.attributes.tangent,
                r = void 0 !== t.attributes.color,
                a = void 0 === t.attributes.normal;
            if (i || r || a) {
                let e = "ClonedMaterial:" + n.uuid + ":";
                n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), i && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), a && (e += "flat-shading:");
                let t = this.cache.get(e);
                t || (t = n.clone(), r && (t.vertexColors = !0), a && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
            }
            n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n
        }
        getMaterialType() {
            return $a
        }
        loadMaterial(e) {
            const t = this,
                n = this.json,
                i = this.extensions,
                r = n.materials[e];
            let a;
            const s = {},
                o = r.extensions || {},
                l = [];
            if (o[ps.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                const e = i[ps.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                a = e.getMaterialType(), l.push(e.extendParams(s, r, t))
            } else if (o[ps.KHR_MATERIALS_UNLIT]) {
                const e = i[ps.KHR_MATERIALS_UNLIT];
                a = e.getMaterialType(), l.push(e.extendParams(s, r, t))
            } else {
                const n = r.pbrMetallicRoughness || {};
                if (s.color = new qe(1, 1, 1), s.opacity = 1, Array.isArray(n.baseColorFactor)) {
                    const e = n.baseColorFactor;
                    s.color.fromArray(e), s.opacity = e[3]
                }
                void 0 !== n.baseColorTexture && l.push(t.assignTexture(s, "map", n.baseColorTexture)), s.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, s.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (l.push(t.assignTexture(s, "metalnessMap", n.metallicRoughnessTexture)), l.push(t.assignTexture(s, "roughnessMap", n.metallicRoughnessTexture))), a = this._invokeOne((function(t) {
                    return t.getMaterialType && t.getMaterialType(e)
                })), l.push(Promise.all(this._invokeAll((function(t) {
                    return t.extendMaterialParams && t.extendMaterialParams(e, s)
                }))))
            }!0 === r.doubleSided && (s.side = 2);
            const c = r.alphaMode || Vs;
            if (c === Ws ? (s.transparent = !0, s.depthWrite = !1) : (s.format = T, s.transparent = !1, c === ks && (s.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && a !== tn && (l.push(t.assignTexture(s, "normalMap", r.normalTexture)), s.normalScale = new ze(1, 1), void 0 !== r.normalTexture.scale)) {
                const e = r.normalTexture.scale;
                s.normalScale.set(e, e)
            }
            return void 0 !== r.occlusionTexture && a !== tn && (l.push(t.assignTexture(s, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (s.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && a !== tn && (s.emissive = (new qe).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && a !== tn && l.push(t.assignTexture(s, "emissiveMap", r.emissiveTexture)), Promise.all(l).then((function() {
                let n;
                return n = a === Ps ? i[ps.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new a(s), r.name && (n.name = r.name), n.map && (n.map.encoding = B), n.emissiveMap && (n.emissiveMap.encoding = B), js(n, r), t.associations.set(n, {
                    materials: e
                }), r.extensions && Xs(i, n, r), n
            }))
        }
        createUniqueName(e) {
            const t = us.sanitizeNodeName(e || "");
            let n = t;
            for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;
            return this.nodeNamesUsed[n] = !0, n
        }
        loadGeometries(e) {
            const t = this,
                n = this.extensions,
                i = this.primitiveCache;

            function r(e) {
                return n[ps.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                    return $s(n, e, t)
                }))
            }
            const a = [];
            for (let n = 0, s = e.length; n < s; n++) {
                const s = e[n],
                    o = Ys(s),
                    l = i[o];
                if (l) a.push(l.promise);
                else {
                    let e;
                    e = s.extensions && s.extensions[ps.KHR_DRACO_MESH_COMPRESSION] ? r(s) : $s(new At, s, t), i[o] = {
                        primitive: s,
                        promise: e
                    }, a.push(e)
                }
            }
            return Promise.all(a)
        }
        loadMesh(e) {
            const t = this,
                n = this.json,
                i = this.extensions,
                r = n.meshes[e],
                a = r.primitives,
                s = [];
            for (let e = 0, t = a.length; e < t; e++) {
                const t = void 0 === a[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new $a({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: 0
                })), o.DefaultMaterial) : this.getDependency("material", a[e].material);
                s.push(t)
            }
            var o;
            return s.push(t.loadGeometries(a)), Promise.all(s).then((function(n) {
                const s = n.slice(0, n.length - 1),
                    o = n[n.length - 1],
                    l = [];
                for (let n = 0, c = o.length; n < c; n++) {
                    const c = o[n],
                        h = a[n];
                    let u;
                    const d = s[n];
                    if (h.mode !== Is && h.mode !== Us && h.mode !== Fs && void 0 !== h.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                    u = new yn(c, d), h.mode === Us ? u.geometry = eo(u.geometry, 1) : h.mode === Fs && (u.geometry = eo(u.geometry, 2)), Object.keys(u.geometry.morphAttributes).length > 0 && qs(u, r), u.name = t.createUniqueName(r.name || "mesh_" + e), js(u, r), h.extensions && Xs(i, u, h), t.assignFinalMaterial(u), l.push(u)
                }
                for (let n = 0, i = l.length; n < i; n++) t.associations.set(l[n], {
                    meshes: e,
                    primitives: n
                });
                if (1 === l.length) return l[0];
                const c = new _a;
                t.associations.set(c, {
                    meshes: e
                });
                for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                return c
            }))
        }
        createNodeMesh(e) {
            const t = this.json,
                n = this,
                i = t.nodes[e];
            return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                const t = n._getNodeRef(n.meshCache, i.mesh, e);
                return void 0 !== i.weights && t.traverse((function(e) {
                    if (e.isMesh)
                        for (let t = 0, n = i.weights.length; t < n; t++) e.morphTargetInfluences[t] = i.weights[t]
                })), t
            }))
        }
        loadNode(e) {
            const t = this.json,
                n = this.extensions,
                i = this,
                r = t.nodes[e],
                a = r.name ? i.createUniqueName(r.name) : "";
            return function() {
                const t = [],
                    n = i._invokeOne((function(t) {
                        return t.createNodeMesh && t.createNodeMesh(e)
                    }));
                return n && t.push(n), void 0 !== r.camera && t.push(i.getDependency("camera", r.camera).then((function(e) {
                    return i._getNodeRef(i.cameraCache, r.camera, e)
                }))), i._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                })).forEach((function(e) {
                    t.push(e)
                })), Promise.all(t)
            }().then((function(t) {
                let s;
                if (s = t.length > 1 ? new _a : 1 === t.length ? t[0] : new _t, s !== t[0])
                    for (let e = 0, n = t.length; e < n; e++) s.add(t[e]);
                if (r.name && (s.userData.name = r.name, s.name = a), js(s, r), r.extensions && Xs(n, s, r), void 0 !== r.matrix) {
                    const e = new Re;
                    e.fromArray(r.matrix), s.applyMatrix4(e)
                } else void 0 !== r.translation && s.position.fromArray(r.translation), void 0 !== r.rotation && s.quaternion.fromArray(r.rotation), void 0 !== r.scale && s.scale.fromArray(r.scale);
                return i.associations.has(s) || i.associations.set(s, {}), i.associations.get(s).nodes = e, s
            }))
        }
        loadScene(e) {
            const t = this.json,
                n = this.extensions,
                i = this.json.scenes[e],
                r = this,
                a = new _a;
            i.name && (a.name = r.createUniqueName(i.name)), js(a, i), i.extensions && Xs(n, a, i);
            const s = i.nodes || [],
                o = [];
            for (let e = 0, n = s.length; e < n; e++) o.push(Qs(s[e], a, t, r));
            return Promise.all(o).then((function() {
                return r.associations = (e => {
                    const t = new Map;
                    for (const [e, n] of r.associations)(e instanceof Pt || e instanceof Dn) && t.set(e, n);
                    return e.traverse((e => {
                        const n = r.associations.get(e);
                        null != n && t.set(e, n)
                    })), t
                })(a), a
            }))
        }
    }

    function Qs(e, t, n, i) {
        const r = n.nodes[e];
        return i.getDependency("node", e).then((function(e) {
            return r.skin, e
        })).then((function(e) {
            t.add(e);
            const a = [];
            if (r.children) {
                const t = r.children;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r];
                    a.push(Qs(s, e, n, i))
                }
            }
            return Promise.all(a)
        }))
    }

    function $s(e, t, n) {
        const i = t.attributes,
            r = [];

        function a(t, i) {
            return n.getDependency("accessor", t).then((function(t) {
                e.setAttribute(i, t)
            }))
        }
        for (const t in i) {
            const n = Hs[t] || t.toLowerCase();
            n in e.attributes || r.push(a(i[t], n))
        }
        if (void 0 !== t.indices && !e.index) {
            const i = n.getDependency("accessor", t.indices).then((function(t) {
                e.setIndex(t)
            }));
            r.push(i)
        }
        return js(e, t),
            function(e, t, n) {
                const i = t.attributes,
                    r = new ee;
                if (void 0 === i.POSITION) return; {
                    const e = n.json.accessors[i.POSITION],
                        t = e.min,
                        a = e.max;
                    if (void 0 === t || void 0 === a) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (r.set(new J(t[0], t[1], t[2]), new J(a[0], a[1], a[2])), e.normalized) {
                        const t = Zs(Os[e.componentType]);
                        r.min.multiplyScalar(t), r.max.multiplyScalar(t)
                    }
                }
                const a = t.targets;
                if (void 0 !== a) {
                    const e = new J,
                        t = new J;
                    for (let i = 0, r = a.length; i < r; i++) {
                        const r = a[i];
                        if (void 0 !== r.POSITION) {
                            const i = n.json.accessors[r.POSITION],
                                a = i.min,
                                s = i.max;
                            if (void 0 !== a && void 0 !== s) {
                                if (t.setX(Math.max(Math.abs(a[0]), Math.abs(s[0]))), t.setY(Math.max(Math.abs(a[1]), Math.abs(s[1]))), t.setZ(Math.max(Math.abs(a[2]), Math.abs(s[2]))), i.normalized) {
                                    const e = Zs(Os[i.componentType]);
                                    t.multiplyScalar(e)
                                }
                                e.max(t)
                            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    r.expandByVector(e)
                }
                e.boundingBox = r;
                const s = new xe;
                r.getCenter(s.center), s.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = s
            }(e, t, n), Promise.all(r).then((function() {
                return void 0 !== t.targets ? function(e, t, n) {
                    let i = !1,
                        r = !1;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), i && r) break
                    }
                    if (!i && !r) return Promise.resolve(e);
                    const a = [],
                        s = [];
                    for (let o = 0, l = t.length; o < l; o++) {
                        const l = t[o];
                        if (i) {
                            const t = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : e.attributes.position;
                            a.push(t)
                        }
                        if (r) {
                            const t = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : e.attributes.normal;
                            s.push(t)
                        }
                    }
                    return Promise.all([Promise.all(a), Promise.all(s)]).then((function(t) {
                        const n = t[0],
                            a = t[1];
                        return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = a), e.morphTargetsRelative = !0, e
                    }))
                }(e, t.targets, n) : e
            }))
    }

    function eo(e, t) {
        let n = e.getIndex();
        if (null === n) {
            const t = [],
                i = e.getAttribute("position");
            if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
            for (let e = 0; e < i.count; e++) t.push(e);
            e.setIndex(t), n = e.getIndex()
        }
        const i = n.count - 2,
            r = [];
        if (2 === t)
            for (let e = 1; e <= i; e++) r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1));
        else
            for (let e = 0; e < i; e++) e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e)));
        r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const a = e.clone();
        return a.setIndex(r), a
    }
    const to = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI
    };
    return e.ACESFilmicToneMapping = 4, e.AddEquation = t, e.AddOperation = 2, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, e.AmbientLight = ka, e.BackSide = 1, e.BasicDepthPacking = 3200, e.Box3 = ee, e.BoxGeometry = Rt, e.ByteType = 1010, e.CineonToneMapping = 3, e.ClampToEdgeWrapping = c, e.Color = qe, e.ConeGeometry = wa, e.CubeReflectionMapping = n, e.CubeRefractionMapping = i, e.CubeUVReflectionMapping = s, e.CubeUVRefractionMapping = o, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceNone = 0, e.CustomBlending = 5, e.CustomToneMapping = 5, e.CylinderGeometry = Ea, e.DepthFormat = E, e.DepthStencilFormat = w, e.DirectionalLight = Va, e.DodecahedronGeometry = Ra, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.EqualDepth = 4, e.EquirectangularReflectionMapping = r, e.EquirectangularRefractionMapping = a, e.FlatShading = 1, e.FloatType = y, e.FrontSide = 0, e.GLSL1 = "100", e.GLSL3 = H, e.GLTFLoader = class extends Ia {
        constructor(e) {
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
                return new gs(e)
            })), this.register((function(e) {
                return new Ss(e)
            })), this.register((function(e) {
                return new Ts(e)
            })), this.register((function(e) {
                return new _s(e)
            })), this.register((function(e) {
                return new vs(e)
            })), this.register((function(e) {
                return new xs(e)
            })), this.register((function(e) {
                return new ys(e)
            })), this.register((function(e) {
                return new Ms(e)
            })), this.register((function(e) {
                return new ms(e)
            })), this.register((function(e) {
                return new bs(e)
            }))
        }
        load(e, t, n, i) {
            const r = this;
            let a;
            a = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Qa.extractUrlBase(e), this.manager.itemStart(e);
            const s = function(t) {
                    i ? i(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e)
                },
                o = new qa(this.manager);
            o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(n) {
                try {
                    r.parse(n, a, (function(n) {
                        t(n), r.manager.itemEnd(e)
                    }), s)
                } catch (e) {
                    s(e)
                }
            }), n, s)
        }
        setDRACOLoader(e) {
            return this.dracoLoader = e, this
        }
        setDDSLoader() {
            throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
        }
        setKTX2Loader(e) {
            return this.ktx2Loader = e, this
        }
        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this
        }
        register(e) {
            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
        }
        unregister(e) {
            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
        }
        parse(e, t, n, i) {
            let r;
            const a = {},
                s = {};
            if ("string" == typeof e) r = e;
            else {
                if (Qa.decodeText(new Uint8Array(e, 0, 4)) === Es) {
                    try {
                        a[ps.KHR_BINARY_GLTF] = new Rs(e)
                    } catch (e) {
                        return void(i && i(e))
                    }
                    r = a[ps.KHR_BINARY_GLTF].content
                } else r = Qa.decodeText(new Uint8Array(e))
            }
            const o = JSON.parse(r);
            if (void 0 === o.asset || o.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
            const l = new Js(o, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            l.fileLoader.setRequestHeader(this.requestHeader);
            for (let e = 0; e < this.pluginCallbacks.length; e++) {
                const t = this.pluginCallbacks[e](l);
                s[t.name] = t, a[t.name] = !0
            }
            if (o.extensionsUsed)
                for (let e = 0; e < o.extensionsUsed.length; ++e) {
                    const t = o.extensionsUsed[e],
                        n = o.extensionsRequired || [];
                    switch (t) {
                        case ps.KHR_MATERIALS_UNLIT:
                            a[t] = new fs;
                            break;
                        case ps.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            a[t] = new Ds;
                            break;
                        case ps.KHR_DRACO_MESH_COMPRESSION:
                            a[t] = new Ls(o, this.dracoLoader);
                            break;
                        case ps.KHR_TEXTURE_TRANSFORM:
                            a[t] = new Cs;
                            break;
                        case ps.KHR_MESH_QUANTIZATION:
                            a[t] = new Ns;
                            break;
                        default:
                            n.indexOf(t) >= 0 && void 0 === s[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                    }
                }
            l.setExtensions(a), l.setPlugins(s), l.parse(n, i)
        }
        parseAsync(e, t) {
            const n = this;
            return new Promise((function(i, r) {
                n.parse(e, t, i, r)
            }))
        }
    }, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.Group = _a, e.HalfFloatType = M, e.IcosahedronGeometry = La, e.IntType = 1013, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.KeepStencilOp = z, e.LessDepth = 2, e.LessEqualDepth = 3, e.LinearEncoding = O, e.LinearFilter = m, e.LinearMipmapLinearFilter = g, e.LinearMipmapNearestFilter = f, e.LinearToneMapping = 1, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MathUtils = to, e.Matrix3 = ye, e.MaxEquation = 104, e.Mesh = yn, e.MinEquation = 103, e.MirroredRepeatWrapping = h, e.MixOperation = 1, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = u, e.NearestMipmapLinearFilter = p, e.NearestMipmapNearestFilter = d, e.NeverDepth = 0, e.NoBlending = 0, e.NoToneMapping = 0, e.NormalBlending = 1, e.NotEqualDepth = 7, e.ObjectSpaceNormalMap = 1, e.OctahedronGeometry = Ca, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = Vn, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.PerspectiveCamera = Fn, e.PlaneGeometry = Lt, e.REVISION = "136", e.RGBADepthPacking = 3201, e.RGBAFormat = b, e.RGBAIntegerFormat = 1033, e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_BPTC_Format = 36492, e.RGBA_ETC2_EAC_Format = F, e.RGBA_PVRTC_2BPPV1_Format = I, e.RGBA_PVRTC_4BPPV1_Format = N, e.RGBA_S3TC_DXT1_Format = R, e.RGBA_S3TC_DXT3_Format = L, e.RGBA_S3TC_DXT5_Format = C, e.RGBFormat = T, e.RGBIntegerFormat = 1032, e.RGB_ETC1_Format = 36196, e.RGB_ETC2_Format = U, e.RGB_PVRTC_2BPPV1_Format = D, e.RGB_PVRTC_4BPPV1_Format = P, e.RGB_S3TC_DXT1_Format = A, e.RGFormat = 1030, e.RGIntegerFormat = 1031, e.Raycaster = class {
        constructor(e, t, n = 0, i = 1 / 0) {
            this.ray = new kt(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new it, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }
        }
        set(e, t) {
            this.ray.set(e, t)
        }
        setFromCamera(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
        }
        intersectObject(e, t = !0, n = []) {
            return Xa(e, this, n, t), n.sort(Wa), n
        }
        intersectObjects(e, t = !0, n = []) {
            for (let i = 0, r = e.length; i < r; i++) Xa(e[i], this, n, t);
            return n.sort(Wa), n
        }
    }, e.RedFormat = 1028, e.RedIntegerFormat = 1029, e.ReinhardToneMapping = 2, e.RepeatWrapping = l, e.ReverseSubtractEquation = 102, e.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, e.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, e.SRGB8_ALPHA8_ASTC_10x6_Format = 37849, e.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, e.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, e.SRGB8_ALPHA8_ASTC_12x12_Format = 37853, e.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, e.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, e.SRGB8_ALPHA8_ASTC_5x5_Format = 37842, e.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, e.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, e.SRGB8_ALPHA8_ASTC_8x5_Format = 37845, e.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, e.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, e.Scene = ba, e.ShaderMaterial = Ut, e.ShortType = 1011, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticDrawUsage = G, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TangentSpaceNormalMap = 0, e.TetrahedronGeometry = Pa, e.Texture = Dn, e.TextureLoader = Fa, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.UVMapping = 300, e.UnsignedByteType = _, e.UnsignedInt248Type = S, e.UnsignedIntType = x, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedShortType = v, e.VSMShadowMap = 3, e.Vector2 = ze, e.WebGLRenderer = Ta, e.ZeroFactor = 200, e.sRGBEncoding = B, Object.defineProperty(e, "__esModule", {
        value: !0
    }), e
}({});